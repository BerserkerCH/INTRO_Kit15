
K64F-FreeRTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .interrupts   00000198  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00007100  00000410  00000410  00008410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000004  00007510  00007510  0000f510  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  00007514  00007514  0000f514  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000008  20000000  00007518  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000011b0  20000008  00007520  00010008  2**2
                  ALLOC
  6 .romp         00000024  200011b8  00007520  000111b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 ._user_heap_stack 00000400  200011dc  00007544  000111dc  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  000111dc  2**0
                  CONTENTS, READONLY
  9 .debug_info   00007a0f  00000000  00000000  0001120c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000184f  00000000  00000000  00018c1b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000350  00000000  00000000  0001a46a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00003588  00000000  00000000  0001a7ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000035d0  00000000  00000000  0001dd42  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .comment      00000082  00000000  00000000  00021312  2**0
                  CONTENTS, READONLY
 15 .debug_frame  000028d0  00000000  00000000  00021394  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c05      	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	b933      	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	4b04      	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	b113      	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	4804      	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	f3af 8000 	nop.w
     422:	2301      	movs	r3, #1
     424:	7023      	strb	r3, [r4, #0]
     426:	bd10      	pop	{r4, pc}
     428:	20000008 	.word	0x20000008
     42c:	00000000 	.word	0x00000000
     430:	000074f4 	.word	0x000074f4

00000434 <frame_dummy>:
     434:	b508      	push	{r3, lr}
     436:	4b03      	ldr	r3, [pc, #12]	; (444 <frame_dummy+0x10>)
     438:	b11b      	cbz	r3, 442 <frame_dummy+0xe>
     43a:	4803      	ldr	r0, [pc, #12]	; (448 <frame_dummy+0x14>)
     43c:	4903      	ldr	r1, [pc, #12]	; (44c <frame_dummy+0x18>)
     43e:	f3af 8000 	nop.w
     442:	bd08      	pop	{r3, pc}
     444:	00000000 	.word	0x00000000
     448:	000074f4 	.word	0x000074f4
     44c:	2000000c 	.word	0x2000000c

00000450 <UnhandledInterrupt>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(UnhandledInterrupt);
PE_ISR(UnhandledInterrupt)
{
     450:	4668      	mov	r0, sp
     452:	f020 0107 	bic.w	r1, r0, #7
     456:	468d      	mov	sp, r1
     458:	b481      	push	{r0, r7}
     45a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     45c:	beff      	bkpt	0x00ff
}
     45e:	46bd      	mov	sp, r7
     460:	bc81      	pop	{r0, r7}
     462:	4685      	mov	sp, r0
     464:	4770      	bx	lr
     466:	bf00      	nop

00000468 <Unhandled_ivINT_NMI>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_NMI);
PE_ISR(Unhandled_ivINT_NMI)
{
     468:	4668      	mov	r0, sp
     46a:	f020 0107 	bic.w	r1, r0, #7
     46e:	468d      	mov	sp, r1
     470:	b481      	push	{r0, r7}
     472:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     474:	beff      	bkpt	0x00ff
}
     476:	46bd      	mov	sp, r7
     478:	bc81      	pop	{r0, r7}
     47a:	4685      	mov	sp, r0
     47c:	4770      	bx	lr
     47e:	bf00      	nop

00000480 <Unhandled_ivINT_Hard_Fault>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Hard_Fault);
PE_ISR(Unhandled_ivINT_Hard_Fault)
{
     480:	4668      	mov	r0, sp
     482:	f020 0107 	bic.w	r1, r0, #7
     486:	468d      	mov	sp, r1
     488:	b481      	push	{r0, r7}
     48a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     48c:	beff      	bkpt	0x00ff
}
     48e:	46bd      	mov	sp, r7
     490:	bc81      	pop	{r0, r7}
     492:	4685      	mov	sp, r0
     494:	4770      	bx	lr
     496:	bf00      	nop

00000498 <Unhandled_ivINT_Mem_Manage_Fault>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Mem_Manage_Fault);
PE_ISR(Unhandled_ivINT_Mem_Manage_Fault)
{
     498:	4668      	mov	r0, sp
     49a:	f020 0107 	bic.w	r1, r0, #7
     49e:	468d      	mov	sp, r1
     4a0:	b481      	push	{r0, r7}
     4a2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     4a4:	beff      	bkpt	0x00ff
}
     4a6:	46bd      	mov	sp, r7
     4a8:	bc81      	pop	{r0, r7}
     4aa:	4685      	mov	sp, r0
     4ac:	4770      	bx	lr
     4ae:	bf00      	nop

000004b0 <Unhandled_ivINT_Bus_Fault>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Bus_Fault);
PE_ISR(Unhandled_ivINT_Bus_Fault)
{
     4b0:	4668      	mov	r0, sp
     4b2:	f020 0107 	bic.w	r1, r0, #7
     4b6:	468d      	mov	sp, r1
     4b8:	b481      	push	{r0, r7}
     4ba:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     4bc:	beff      	bkpt	0x00ff
}
     4be:	46bd      	mov	sp, r7
     4c0:	bc81      	pop	{r0, r7}
     4c2:	4685      	mov	sp, r0
     4c4:	4770      	bx	lr
     4c6:	bf00      	nop

000004c8 <Unhandled_ivINT_Usage_Fault>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Usage_Fault);
PE_ISR(Unhandled_ivINT_Usage_Fault)
{
     4c8:	4668      	mov	r0, sp
     4ca:	f020 0107 	bic.w	r1, r0, #7
     4ce:	468d      	mov	sp, r1
     4d0:	b481      	push	{r0, r7}
     4d2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     4d4:	beff      	bkpt	0x00ff
}
     4d6:	46bd      	mov	sp, r7
     4d8:	bc81      	pop	{r0, r7}
     4da:	4685      	mov	sp, r0
     4dc:	4770      	bx	lr
     4de:	bf00      	nop

000004e0 <Unhandled_ivINT_Reserved7>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved7);
PE_ISR(Unhandled_ivINT_Reserved7)
{
     4e0:	4668      	mov	r0, sp
     4e2:	f020 0107 	bic.w	r1, r0, #7
     4e6:	468d      	mov	sp, r1
     4e8:	b481      	push	{r0, r7}
     4ea:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     4ec:	beff      	bkpt	0x00ff
}
     4ee:	46bd      	mov	sp, r7
     4f0:	bc81      	pop	{r0, r7}
     4f2:	4685      	mov	sp, r0
     4f4:	4770      	bx	lr
     4f6:	bf00      	nop

000004f8 <Unhandled_ivINT_Reserved8>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved8);
PE_ISR(Unhandled_ivINT_Reserved8)
{
     4f8:	4668      	mov	r0, sp
     4fa:	f020 0107 	bic.w	r1, r0, #7
     4fe:	468d      	mov	sp, r1
     500:	b481      	push	{r0, r7}
     502:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     504:	beff      	bkpt	0x00ff
}
     506:	46bd      	mov	sp, r7
     508:	bc81      	pop	{r0, r7}
     50a:	4685      	mov	sp, r0
     50c:	4770      	bx	lr
     50e:	bf00      	nop

00000510 <Unhandled_ivINT_Reserved9>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved9);
PE_ISR(Unhandled_ivINT_Reserved9)
{
     510:	4668      	mov	r0, sp
     512:	f020 0107 	bic.w	r1, r0, #7
     516:	468d      	mov	sp, r1
     518:	b481      	push	{r0, r7}
     51a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     51c:	beff      	bkpt	0x00ff
}
     51e:	46bd      	mov	sp, r7
     520:	bc81      	pop	{r0, r7}
     522:	4685      	mov	sp, r0
     524:	4770      	bx	lr
     526:	bf00      	nop

00000528 <Unhandled_ivINT_Reserved10>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved10);
PE_ISR(Unhandled_ivINT_Reserved10)
{
     528:	4668      	mov	r0, sp
     52a:	f020 0107 	bic.w	r1, r0, #7
     52e:	468d      	mov	sp, r1
     530:	b481      	push	{r0, r7}
     532:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     534:	beff      	bkpt	0x00ff
}
     536:	46bd      	mov	sp, r7
     538:	bc81      	pop	{r0, r7}
     53a:	4685      	mov	sp, r0
     53c:	4770      	bx	lr
     53e:	bf00      	nop

00000540 <Unhandled_ivINT_SVCall>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SVCall);
PE_ISR(Unhandled_ivINT_SVCall)
{
     540:	4668      	mov	r0, sp
     542:	f020 0107 	bic.w	r1, r0, #7
     546:	468d      	mov	sp, r1
     548:	b481      	push	{r0, r7}
     54a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     54c:	beff      	bkpt	0x00ff
}
     54e:	46bd      	mov	sp, r7
     550:	bc81      	pop	{r0, r7}
     552:	4685      	mov	sp, r0
     554:	4770      	bx	lr
     556:	bf00      	nop

00000558 <Unhandled_ivINT_DebugMonitor>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DebugMonitor);
PE_ISR(Unhandled_ivINT_DebugMonitor)
{
     558:	4668      	mov	r0, sp
     55a:	f020 0107 	bic.w	r1, r0, #7
     55e:	468d      	mov	sp, r1
     560:	b481      	push	{r0, r7}
     562:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     564:	beff      	bkpt	0x00ff
}
     566:	46bd      	mov	sp, r7
     568:	bc81      	pop	{r0, r7}
     56a:	4685      	mov	sp, r0
     56c:	4770      	bx	lr
     56e:	bf00      	nop

00000570 <Unhandled_ivINT_Reserved13>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved13);
PE_ISR(Unhandled_ivINT_Reserved13)
{
     570:	4668      	mov	r0, sp
     572:	f020 0107 	bic.w	r1, r0, #7
     576:	468d      	mov	sp, r1
     578:	b481      	push	{r0, r7}
     57a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     57c:	beff      	bkpt	0x00ff
}
     57e:	46bd      	mov	sp, r7
     580:	bc81      	pop	{r0, r7}
     582:	4685      	mov	sp, r0
     584:	4770      	bx	lr
     586:	bf00      	nop

00000588 <Unhandled_ivINT_PendableSrvReq>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PendableSrvReq);
PE_ISR(Unhandled_ivINT_PendableSrvReq)
{
     588:	4668      	mov	r0, sp
     58a:	f020 0107 	bic.w	r1, r0, #7
     58e:	468d      	mov	sp, r1
     590:	b481      	push	{r0, r7}
     592:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     594:	beff      	bkpt	0x00ff
}
     596:	46bd      	mov	sp, r7
     598:	bc81      	pop	{r0, r7}
     59a:	4685      	mov	sp, r0
     59c:	4770      	bx	lr
     59e:	bf00      	nop

000005a0 <Unhandled_ivINT_SysTick>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SysTick);
PE_ISR(Unhandled_ivINT_SysTick)
{
     5a0:	4668      	mov	r0, sp
     5a2:	f020 0107 	bic.w	r1, r0, #7
     5a6:	468d      	mov	sp, r1
     5a8:	b481      	push	{r0, r7}
     5aa:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     5ac:	beff      	bkpt	0x00ff
}
     5ae:	46bd      	mov	sp, r7
     5b0:	bc81      	pop	{r0, r7}
     5b2:	4685      	mov	sp, r0
     5b4:	4770      	bx	lr
     5b6:	bf00      	nop

000005b8 <Unhandled_ivINT_DMA0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA0);
PE_ISR(Unhandled_ivINT_DMA0)
{
     5b8:	4668      	mov	r0, sp
     5ba:	f020 0107 	bic.w	r1, r0, #7
     5be:	468d      	mov	sp, r1
     5c0:	b481      	push	{r0, r7}
     5c2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     5c4:	beff      	bkpt	0x00ff
}
     5c6:	46bd      	mov	sp, r7
     5c8:	bc81      	pop	{r0, r7}
     5ca:	4685      	mov	sp, r0
     5cc:	4770      	bx	lr
     5ce:	bf00      	nop

000005d0 <Unhandled_ivINT_DMA1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA1);
PE_ISR(Unhandled_ivINT_DMA1)
{
     5d0:	4668      	mov	r0, sp
     5d2:	f020 0107 	bic.w	r1, r0, #7
     5d6:	468d      	mov	sp, r1
     5d8:	b481      	push	{r0, r7}
     5da:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     5dc:	beff      	bkpt	0x00ff
}
     5de:	46bd      	mov	sp, r7
     5e0:	bc81      	pop	{r0, r7}
     5e2:	4685      	mov	sp, r0
     5e4:	4770      	bx	lr
     5e6:	bf00      	nop

000005e8 <Unhandled_ivINT_DMA2>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA2);
PE_ISR(Unhandled_ivINT_DMA2)
{
     5e8:	4668      	mov	r0, sp
     5ea:	f020 0107 	bic.w	r1, r0, #7
     5ee:	468d      	mov	sp, r1
     5f0:	b481      	push	{r0, r7}
     5f2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     5f4:	beff      	bkpt	0x00ff
}
     5f6:	46bd      	mov	sp, r7
     5f8:	bc81      	pop	{r0, r7}
     5fa:	4685      	mov	sp, r0
     5fc:	4770      	bx	lr
     5fe:	bf00      	nop

00000600 <Unhandled_ivINT_DMA3>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA3);
PE_ISR(Unhandled_ivINT_DMA3)
{
     600:	4668      	mov	r0, sp
     602:	f020 0107 	bic.w	r1, r0, #7
     606:	468d      	mov	sp, r1
     608:	b481      	push	{r0, r7}
     60a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     60c:	beff      	bkpt	0x00ff
}
     60e:	46bd      	mov	sp, r7
     610:	bc81      	pop	{r0, r7}
     612:	4685      	mov	sp, r0
     614:	4770      	bx	lr
     616:	bf00      	nop

00000618 <Unhandled_ivINT_DMA4>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA4);
PE_ISR(Unhandled_ivINT_DMA4)
{
     618:	4668      	mov	r0, sp
     61a:	f020 0107 	bic.w	r1, r0, #7
     61e:	468d      	mov	sp, r1
     620:	b481      	push	{r0, r7}
     622:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     624:	beff      	bkpt	0x00ff
}
     626:	46bd      	mov	sp, r7
     628:	bc81      	pop	{r0, r7}
     62a:	4685      	mov	sp, r0
     62c:	4770      	bx	lr
     62e:	bf00      	nop

00000630 <Unhandled_ivINT_DMA5>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA5);
PE_ISR(Unhandled_ivINT_DMA5)
{
     630:	4668      	mov	r0, sp
     632:	f020 0107 	bic.w	r1, r0, #7
     636:	468d      	mov	sp, r1
     638:	b481      	push	{r0, r7}
     63a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     63c:	beff      	bkpt	0x00ff
}
     63e:	46bd      	mov	sp, r7
     640:	bc81      	pop	{r0, r7}
     642:	4685      	mov	sp, r0
     644:	4770      	bx	lr
     646:	bf00      	nop

00000648 <Unhandled_ivINT_DMA6>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA6);
PE_ISR(Unhandled_ivINT_DMA6)
{
     648:	4668      	mov	r0, sp
     64a:	f020 0107 	bic.w	r1, r0, #7
     64e:	468d      	mov	sp, r1
     650:	b481      	push	{r0, r7}
     652:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     654:	beff      	bkpt	0x00ff
}
     656:	46bd      	mov	sp, r7
     658:	bc81      	pop	{r0, r7}
     65a:	4685      	mov	sp, r0
     65c:	4770      	bx	lr
     65e:	bf00      	nop

00000660 <Unhandled_ivINT_DMA7>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA7);
PE_ISR(Unhandled_ivINT_DMA7)
{
     660:	4668      	mov	r0, sp
     662:	f020 0107 	bic.w	r1, r0, #7
     666:	468d      	mov	sp, r1
     668:	b481      	push	{r0, r7}
     66a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     66c:	beff      	bkpt	0x00ff
}
     66e:	46bd      	mov	sp, r7
     670:	bc81      	pop	{r0, r7}
     672:	4685      	mov	sp, r0
     674:	4770      	bx	lr
     676:	bf00      	nop

00000678 <Unhandled_ivINT_DMA8>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA8);
PE_ISR(Unhandled_ivINT_DMA8)
{
     678:	4668      	mov	r0, sp
     67a:	f020 0107 	bic.w	r1, r0, #7
     67e:	468d      	mov	sp, r1
     680:	b481      	push	{r0, r7}
     682:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     684:	beff      	bkpt	0x00ff
}
     686:	46bd      	mov	sp, r7
     688:	bc81      	pop	{r0, r7}
     68a:	4685      	mov	sp, r0
     68c:	4770      	bx	lr
     68e:	bf00      	nop

00000690 <Unhandled_ivINT_DMA9>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA9);
PE_ISR(Unhandled_ivINT_DMA9)
{
     690:	4668      	mov	r0, sp
     692:	f020 0107 	bic.w	r1, r0, #7
     696:	468d      	mov	sp, r1
     698:	b481      	push	{r0, r7}
     69a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     69c:	beff      	bkpt	0x00ff
}
     69e:	46bd      	mov	sp, r7
     6a0:	bc81      	pop	{r0, r7}
     6a2:	4685      	mov	sp, r0
     6a4:	4770      	bx	lr
     6a6:	bf00      	nop

000006a8 <Unhandled_ivINT_DMA10>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA10);
PE_ISR(Unhandled_ivINT_DMA10)
{
     6a8:	4668      	mov	r0, sp
     6aa:	f020 0107 	bic.w	r1, r0, #7
     6ae:	468d      	mov	sp, r1
     6b0:	b481      	push	{r0, r7}
     6b2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     6b4:	beff      	bkpt	0x00ff
}
     6b6:	46bd      	mov	sp, r7
     6b8:	bc81      	pop	{r0, r7}
     6ba:	4685      	mov	sp, r0
     6bc:	4770      	bx	lr
     6be:	bf00      	nop

000006c0 <Unhandled_ivINT_DMA11>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA11);
PE_ISR(Unhandled_ivINT_DMA11)
{
     6c0:	4668      	mov	r0, sp
     6c2:	f020 0107 	bic.w	r1, r0, #7
     6c6:	468d      	mov	sp, r1
     6c8:	b481      	push	{r0, r7}
     6ca:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     6cc:	beff      	bkpt	0x00ff
}
     6ce:	46bd      	mov	sp, r7
     6d0:	bc81      	pop	{r0, r7}
     6d2:	4685      	mov	sp, r0
     6d4:	4770      	bx	lr
     6d6:	bf00      	nop

000006d8 <Unhandled_ivINT_DMA12>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA12);
PE_ISR(Unhandled_ivINT_DMA12)
{
     6d8:	4668      	mov	r0, sp
     6da:	f020 0107 	bic.w	r1, r0, #7
     6de:	468d      	mov	sp, r1
     6e0:	b481      	push	{r0, r7}
     6e2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     6e4:	beff      	bkpt	0x00ff
}
     6e6:	46bd      	mov	sp, r7
     6e8:	bc81      	pop	{r0, r7}
     6ea:	4685      	mov	sp, r0
     6ec:	4770      	bx	lr
     6ee:	bf00      	nop

000006f0 <Unhandled_ivINT_DMA13>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA13);
PE_ISR(Unhandled_ivINT_DMA13)
{
     6f0:	4668      	mov	r0, sp
     6f2:	f020 0107 	bic.w	r1, r0, #7
     6f6:	468d      	mov	sp, r1
     6f8:	b481      	push	{r0, r7}
     6fa:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     6fc:	beff      	bkpt	0x00ff
}
     6fe:	46bd      	mov	sp, r7
     700:	bc81      	pop	{r0, r7}
     702:	4685      	mov	sp, r0
     704:	4770      	bx	lr
     706:	bf00      	nop

00000708 <Unhandled_ivINT_DMA14>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA14);
PE_ISR(Unhandled_ivINT_DMA14)
{
     708:	4668      	mov	r0, sp
     70a:	f020 0107 	bic.w	r1, r0, #7
     70e:	468d      	mov	sp, r1
     710:	b481      	push	{r0, r7}
     712:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     714:	beff      	bkpt	0x00ff
}
     716:	46bd      	mov	sp, r7
     718:	bc81      	pop	{r0, r7}
     71a:	4685      	mov	sp, r0
     71c:	4770      	bx	lr
     71e:	bf00      	nop

00000720 <Unhandled_ivINT_DMA15>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA15);
PE_ISR(Unhandled_ivINT_DMA15)
{
     720:	4668      	mov	r0, sp
     722:	f020 0107 	bic.w	r1, r0, #7
     726:	468d      	mov	sp, r1
     728:	b481      	push	{r0, r7}
     72a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     72c:	beff      	bkpt	0x00ff
}
     72e:	46bd      	mov	sp, r7
     730:	bc81      	pop	{r0, r7}
     732:	4685      	mov	sp, r0
     734:	4770      	bx	lr
     736:	bf00      	nop

00000738 <Unhandled_ivINT_DMA_Error>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DMA_Error);
PE_ISR(Unhandled_ivINT_DMA_Error)
{
     738:	4668      	mov	r0, sp
     73a:	f020 0107 	bic.w	r1, r0, #7
     73e:	468d      	mov	sp, r1
     740:	b481      	push	{r0, r7}
     742:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     744:	beff      	bkpt	0x00ff
}
     746:	46bd      	mov	sp, r7
     748:	bc81      	pop	{r0, r7}
     74a:	4685      	mov	sp, r0
     74c:	4770      	bx	lr
     74e:	bf00      	nop

00000750 <Unhandled_ivINT_MCM>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_MCM);
PE_ISR(Unhandled_ivINT_MCM)
{
     750:	4668      	mov	r0, sp
     752:	f020 0107 	bic.w	r1, r0, #7
     756:	468d      	mov	sp, r1
     758:	b481      	push	{r0, r7}
     75a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     75c:	beff      	bkpt	0x00ff
}
     75e:	46bd      	mov	sp, r7
     760:	bc81      	pop	{r0, r7}
     762:	4685      	mov	sp, r0
     764:	4770      	bx	lr
     766:	bf00      	nop

00000768 <Unhandled_ivINT_FTFE>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_FTFE);
PE_ISR(Unhandled_ivINT_FTFE)
{
     768:	4668      	mov	r0, sp
     76a:	f020 0107 	bic.w	r1, r0, #7
     76e:	468d      	mov	sp, r1
     770:	b481      	push	{r0, r7}
     772:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     774:	beff      	bkpt	0x00ff
}
     776:	46bd      	mov	sp, r7
     778:	bc81      	pop	{r0, r7}
     77a:	4685      	mov	sp, r0
     77c:	4770      	bx	lr
     77e:	bf00      	nop

00000780 <Unhandled_ivINT_Read_Collision>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Read_Collision);
PE_ISR(Unhandled_ivINT_Read_Collision)
{
     780:	4668      	mov	r0, sp
     782:	f020 0107 	bic.w	r1, r0, #7
     786:	468d      	mov	sp, r1
     788:	b481      	push	{r0, r7}
     78a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     78c:	beff      	bkpt	0x00ff
}
     78e:	46bd      	mov	sp, r7
     790:	bc81      	pop	{r0, r7}
     792:	4685      	mov	sp, r0
     794:	4770      	bx	lr
     796:	bf00      	nop

00000798 <Unhandled_ivINT_LVD_LVW>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_LVD_LVW);
PE_ISR(Unhandled_ivINT_LVD_LVW)
{
     798:	4668      	mov	r0, sp
     79a:	f020 0107 	bic.w	r1, r0, #7
     79e:	468d      	mov	sp, r1
     7a0:	b481      	push	{r0, r7}
     7a2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     7a4:	beff      	bkpt	0x00ff
}
     7a6:	46bd      	mov	sp, r7
     7a8:	bc81      	pop	{r0, r7}
     7aa:	4685      	mov	sp, r0
     7ac:	4770      	bx	lr
     7ae:	bf00      	nop

000007b0 <Unhandled_ivINT_LLWU>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_LLWU);
PE_ISR(Unhandled_ivINT_LLWU)
{
     7b0:	4668      	mov	r0, sp
     7b2:	f020 0107 	bic.w	r1, r0, #7
     7b6:	468d      	mov	sp, r1
     7b8:	b481      	push	{r0, r7}
     7ba:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     7bc:	beff      	bkpt	0x00ff
}
     7be:	46bd      	mov	sp, r7
     7c0:	bc81      	pop	{r0, r7}
     7c2:	4685      	mov	sp, r0
     7c4:	4770      	bx	lr
     7c6:	bf00      	nop

000007c8 <Unhandled_ivINT_WDOG_EWM>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_WDOG_EWM);
PE_ISR(Unhandled_ivINT_WDOG_EWM)
{
     7c8:	4668      	mov	r0, sp
     7ca:	f020 0107 	bic.w	r1, r0, #7
     7ce:	468d      	mov	sp, r1
     7d0:	b481      	push	{r0, r7}
     7d2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     7d4:	beff      	bkpt	0x00ff
}
     7d6:	46bd      	mov	sp, r7
     7d8:	bc81      	pop	{r0, r7}
     7da:	4685      	mov	sp, r0
     7dc:	4770      	bx	lr
     7de:	bf00      	nop

000007e0 <Unhandled_ivINT_RNG>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_RNG);
PE_ISR(Unhandled_ivINT_RNG)
{
     7e0:	4668      	mov	r0, sp
     7e2:	f020 0107 	bic.w	r1, r0, #7
     7e6:	468d      	mov	sp, r1
     7e8:	b481      	push	{r0, r7}
     7ea:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     7ec:	beff      	bkpt	0x00ff
}
     7ee:	46bd      	mov	sp, r7
     7f0:	bc81      	pop	{r0, r7}
     7f2:	4685      	mov	sp, r0
     7f4:	4770      	bx	lr
     7f6:	bf00      	nop

000007f8 <Unhandled_ivINT_I2C0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_I2C0);
PE_ISR(Unhandled_ivINT_I2C0)
{
     7f8:	4668      	mov	r0, sp
     7fa:	f020 0107 	bic.w	r1, r0, #7
     7fe:	468d      	mov	sp, r1
     800:	b481      	push	{r0, r7}
     802:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     804:	beff      	bkpt	0x00ff
}
     806:	46bd      	mov	sp, r7
     808:	bc81      	pop	{r0, r7}
     80a:	4685      	mov	sp, r0
     80c:	4770      	bx	lr
     80e:	bf00      	nop

00000810 <Unhandled_ivINT_I2C1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_I2C1);
PE_ISR(Unhandled_ivINT_I2C1)
{
     810:	4668      	mov	r0, sp
     812:	f020 0107 	bic.w	r1, r0, #7
     816:	468d      	mov	sp, r1
     818:	b481      	push	{r0, r7}
     81a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     81c:	beff      	bkpt	0x00ff
}
     81e:	46bd      	mov	sp, r7
     820:	bc81      	pop	{r0, r7}
     822:	4685      	mov	sp, r0
     824:	4770      	bx	lr
     826:	bf00      	nop

00000828 <Unhandled_ivINT_SPI0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SPI0);
PE_ISR(Unhandled_ivINT_SPI0)
{
     828:	4668      	mov	r0, sp
     82a:	f020 0107 	bic.w	r1, r0, #7
     82e:	468d      	mov	sp, r1
     830:	b481      	push	{r0, r7}
     832:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     834:	beff      	bkpt	0x00ff
}
     836:	46bd      	mov	sp, r7
     838:	bc81      	pop	{r0, r7}
     83a:	4685      	mov	sp, r0
     83c:	4770      	bx	lr
     83e:	bf00      	nop

00000840 <Unhandled_ivINT_SPI1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SPI1);
PE_ISR(Unhandled_ivINT_SPI1)
{
     840:	4668      	mov	r0, sp
     842:	f020 0107 	bic.w	r1, r0, #7
     846:	468d      	mov	sp, r1
     848:	b481      	push	{r0, r7}
     84a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     84c:	beff      	bkpt	0x00ff
}
     84e:	46bd      	mov	sp, r7
     850:	bc81      	pop	{r0, r7}
     852:	4685      	mov	sp, r0
     854:	4770      	bx	lr
     856:	bf00      	nop

00000858 <Unhandled_ivINT_I2S0_Tx>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_I2S0_Tx);
PE_ISR(Unhandled_ivINT_I2S0_Tx)
{
     858:	4668      	mov	r0, sp
     85a:	f020 0107 	bic.w	r1, r0, #7
     85e:	468d      	mov	sp, r1
     860:	b481      	push	{r0, r7}
     862:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     864:	beff      	bkpt	0x00ff
}
     866:	46bd      	mov	sp, r7
     868:	bc81      	pop	{r0, r7}
     86a:	4685      	mov	sp, r0
     86c:	4770      	bx	lr
     86e:	bf00      	nop

00000870 <Unhandled_ivINT_I2S0_Rx>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_I2S0_Rx);
PE_ISR(Unhandled_ivINT_I2S0_Rx)
{
     870:	4668      	mov	r0, sp
     872:	f020 0107 	bic.w	r1, r0, #7
     876:	468d      	mov	sp, r1
     878:	b481      	push	{r0, r7}
     87a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     87c:	beff      	bkpt	0x00ff
}
     87e:	46bd      	mov	sp, r7
     880:	bc81      	pop	{r0, r7}
     882:	4685      	mov	sp, r0
     884:	4770      	bx	lr
     886:	bf00      	nop

00000888 <Unhandled_ivINT_UART0_LON>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART0_LON);
PE_ISR(Unhandled_ivINT_UART0_LON)
{
     888:	4668      	mov	r0, sp
     88a:	f020 0107 	bic.w	r1, r0, #7
     88e:	468d      	mov	sp, r1
     890:	b481      	push	{r0, r7}
     892:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     894:	beff      	bkpt	0x00ff
}
     896:	46bd      	mov	sp, r7
     898:	bc81      	pop	{r0, r7}
     89a:	4685      	mov	sp, r0
     89c:	4770      	bx	lr
     89e:	bf00      	nop

000008a0 <Unhandled_ivINT_UART0_RX_TX>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART0_RX_TX);
PE_ISR(Unhandled_ivINT_UART0_RX_TX)
{
     8a0:	4668      	mov	r0, sp
     8a2:	f020 0107 	bic.w	r1, r0, #7
     8a6:	468d      	mov	sp, r1
     8a8:	b481      	push	{r0, r7}
     8aa:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     8ac:	beff      	bkpt	0x00ff
}
     8ae:	46bd      	mov	sp, r7
     8b0:	bc81      	pop	{r0, r7}
     8b2:	4685      	mov	sp, r0
     8b4:	4770      	bx	lr
     8b6:	bf00      	nop

000008b8 <Unhandled_ivINT_UART0_ERR>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART0_ERR);
PE_ISR(Unhandled_ivINT_UART0_ERR)
{
     8b8:	4668      	mov	r0, sp
     8ba:	f020 0107 	bic.w	r1, r0, #7
     8be:	468d      	mov	sp, r1
     8c0:	b481      	push	{r0, r7}
     8c2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     8c4:	beff      	bkpt	0x00ff
}
     8c6:	46bd      	mov	sp, r7
     8c8:	bc81      	pop	{r0, r7}
     8ca:	4685      	mov	sp, r0
     8cc:	4770      	bx	lr
     8ce:	bf00      	nop

000008d0 <Unhandled_ivINT_UART1_RX_TX>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART1_RX_TX);
PE_ISR(Unhandled_ivINT_UART1_RX_TX)
{
     8d0:	4668      	mov	r0, sp
     8d2:	f020 0107 	bic.w	r1, r0, #7
     8d6:	468d      	mov	sp, r1
     8d8:	b481      	push	{r0, r7}
     8da:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     8dc:	beff      	bkpt	0x00ff
}
     8de:	46bd      	mov	sp, r7
     8e0:	bc81      	pop	{r0, r7}
     8e2:	4685      	mov	sp, r0
     8e4:	4770      	bx	lr
     8e6:	bf00      	nop

000008e8 <Unhandled_ivINT_UART1_ERR>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART1_ERR);
PE_ISR(Unhandled_ivINT_UART1_ERR)
{
     8e8:	4668      	mov	r0, sp
     8ea:	f020 0107 	bic.w	r1, r0, #7
     8ee:	468d      	mov	sp, r1
     8f0:	b481      	push	{r0, r7}
     8f2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     8f4:	beff      	bkpt	0x00ff
}
     8f6:	46bd      	mov	sp, r7
     8f8:	bc81      	pop	{r0, r7}
     8fa:	4685      	mov	sp, r0
     8fc:	4770      	bx	lr
     8fe:	bf00      	nop

00000900 <Unhandled_ivINT_UART2_RX_TX>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART2_RX_TX);
PE_ISR(Unhandled_ivINT_UART2_RX_TX)
{
     900:	4668      	mov	r0, sp
     902:	f020 0107 	bic.w	r1, r0, #7
     906:	468d      	mov	sp, r1
     908:	b481      	push	{r0, r7}
     90a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     90c:	beff      	bkpt	0x00ff
}
     90e:	46bd      	mov	sp, r7
     910:	bc81      	pop	{r0, r7}
     912:	4685      	mov	sp, r0
     914:	4770      	bx	lr
     916:	bf00      	nop

00000918 <Unhandled_ivINT_UART2_ERR>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART2_ERR);
PE_ISR(Unhandled_ivINT_UART2_ERR)
{
     918:	4668      	mov	r0, sp
     91a:	f020 0107 	bic.w	r1, r0, #7
     91e:	468d      	mov	sp, r1
     920:	b481      	push	{r0, r7}
     922:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     924:	beff      	bkpt	0x00ff
}
     926:	46bd      	mov	sp, r7
     928:	bc81      	pop	{r0, r7}
     92a:	4685      	mov	sp, r0
     92c:	4770      	bx	lr
     92e:	bf00      	nop

00000930 <Unhandled_ivINT_UART3_RX_TX>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART3_RX_TX);
PE_ISR(Unhandled_ivINT_UART3_RX_TX)
{
     930:	4668      	mov	r0, sp
     932:	f020 0107 	bic.w	r1, r0, #7
     936:	468d      	mov	sp, r1
     938:	b481      	push	{r0, r7}
     93a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     93c:	beff      	bkpt	0x00ff
}
     93e:	46bd      	mov	sp, r7
     940:	bc81      	pop	{r0, r7}
     942:	4685      	mov	sp, r0
     944:	4770      	bx	lr
     946:	bf00      	nop

00000948 <Unhandled_ivINT_UART3_ERR>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART3_ERR);
PE_ISR(Unhandled_ivINT_UART3_ERR)
{
     948:	4668      	mov	r0, sp
     94a:	f020 0107 	bic.w	r1, r0, #7
     94e:	468d      	mov	sp, r1
     950:	b481      	push	{r0, r7}
     952:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     954:	beff      	bkpt	0x00ff
}
     956:	46bd      	mov	sp, r7
     958:	bc81      	pop	{r0, r7}
     95a:	4685      	mov	sp, r0
     95c:	4770      	bx	lr
     95e:	bf00      	nop

00000960 <Unhandled_ivINT_ADC0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_ADC0);
PE_ISR(Unhandled_ivINT_ADC0)
{
     960:	4668      	mov	r0, sp
     962:	f020 0107 	bic.w	r1, r0, #7
     966:	468d      	mov	sp, r1
     968:	b481      	push	{r0, r7}
     96a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     96c:	beff      	bkpt	0x00ff
}
     96e:	46bd      	mov	sp, r7
     970:	bc81      	pop	{r0, r7}
     972:	4685      	mov	sp, r0
     974:	4770      	bx	lr
     976:	bf00      	nop

00000978 <Unhandled_ivINT_CMP0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CMP0);
PE_ISR(Unhandled_ivINT_CMP0)
{
     978:	4668      	mov	r0, sp
     97a:	f020 0107 	bic.w	r1, r0, #7
     97e:	468d      	mov	sp, r1
     980:	b481      	push	{r0, r7}
     982:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     984:	beff      	bkpt	0x00ff
}
     986:	46bd      	mov	sp, r7
     988:	bc81      	pop	{r0, r7}
     98a:	4685      	mov	sp, r0
     98c:	4770      	bx	lr
     98e:	bf00      	nop

00000990 <Unhandled_ivINT_CMP1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CMP1);
PE_ISR(Unhandled_ivINT_CMP1)
{
     990:	4668      	mov	r0, sp
     992:	f020 0107 	bic.w	r1, r0, #7
     996:	468d      	mov	sp, r1
     998:	b481      	push	{r0, r7}
     99a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     99c:	beff      	bkpt	0x00ff
}
     99e:	46bd      	mov	sp, r7
     9a0:	bc81      	pop	{r0, r7}
     9a2:	4685      	mov	sp, r0
     9a4:	4770      	bx	lr
     9a6:	bf00      	nop

000009a8 <Unhandled_ivINT_FTM0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_FTM0);
PE_ISR(Unhandled_ivINT_FTM0)
{
     9a8:	4668      	mov	r0, sp
     9aa:	f020 0107 	bic.w	r1, r0, #7
     9ae:	468d      	mov	sp, r1
     9b0:	b481      	push	{r0, r7}
     9b2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     9b4:	beff      	bkpt	0x00ff
}
     9b6:	46bd      	mov	sp, r7
     9b8:	bc81      	pop	{r0, r7}
     9ba:	4685      	mov	sp, r0
     9bc:	4770      	bx	lr
     9be:	bf00      	nop

000009c0 <Unhandled_ivINT_FTM1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_FTM1);
PE_ISR(Unhandled_ivINT_FTM1)
{
     9c0:	4668      	mov	r0, sp
     9c2:	f020 0107 	bic.w	r1, r0, #7
     9c6:	468d      	mov	sp, r1
     9c8:	b481      	push	{r0, r7}
     9ca:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     9cc:	beff      	bkpt	0x00ff
}
     9ce:	46bd      	mov	sp, r7
     9d0:	bc81      	pop	{r0, r7}
     9d2:	4685      	mov	sp, r0
     9d4:	4770      	bx	lr
     9d6:	bf00      	nop

000009d8 <Unhandled_ivINT_FTM2>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_FTM2);
PE_ISR(Unhandled_ivINT_FTM2)
{
     9d8:	4668      	mov	r0, sp
     9da:	f020 0107 	bic.w	r1, r0, #7
     9de:	468d      	mov	sp, r1
     9e0:	b481      	push	{r0, r7}
     9e2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     9e4:	beff      	bkpt	0x00ff
}
     9e6:	46bd      	mov	sp, r7
     9e8:	bc81      	pop	{r0, r7}
     9ea:	4685      	mov	sp, r0
     9ec:	4770      	bx	lr
     9ee:	bf00      	nop

000009f0 <Unhandled_ivINT_CMT>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CMT);
PE_ISR(Unhandled_ivINT_CMT)
{
     9f0:	4668      	mov	r0, sp
     9f2:	f020 0107 	bic.w	r1, r0, #7
     9f6:	468d      	mov	sp, r1
     9f8:	b481      	push	{r0, r7}
     9fa:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     9fc:	beff      	bkpt	0x00ff
}
     9fe:	46bd      	mov	sp, r7
     a00:	bc81      	pop	{r0, r7}
     a02:	4685      	mov	sp, r0
     a04:	4770      	bx	lr
     a06:	bf00      	nop

00000a08 <Unhandled_ivINT_RTC>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_RTC);
PE_ISR(Unhandled_ivINT_RTC)
{
     a08:	4668      	mov	r0, sp
     a0a:	f020 0107 	bic.w	r1, r0, #7
     a0e:	468d      	mov	sp, r1
     a10:	b481      	push	{r0, r7}
     a12:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     a14:	beff      	bkpt	0x00ff
}
     a16:	46bd      	mov	sp, r7
     a18:	bc81      	pop	{r0, r7}
     a1a:	4685      	mov	sp, r0
     a1c:	4770      	bx	lr
     a1e:	bf00      	nop

00000a20 <Unhandled_ivINT_RTC_Seconds>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_RTC_Seconds);
PE_ISR(Unhandled_ivINT_RTC_Seconds)
{
     a20:	4668      	mov	r0, sp
     a22:	f020 0107 	bic.w	r1, r0, #7
     a26:	468d      	mov	sp, r1
     a28:	b481      	push	{r0, r7}
     a2a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     a2c:	beff      	bkpt	0x00ff
}
     a2e:	46bd      	mov	sp, r7
     a30:	bc81      	pop	{r0, r7}
     a32:	4685      	mov	sp, r0
     a34:	4770      	bx	lr
     a36:	bf00      	nop

00000a38 <Unhandled_ivINT_PIT0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PIT0);
PE_ISR(Unhandled_ivINT_PIT0)
{
     a38:	4668      	mov	r0, sp
     a3a:	f020 0107 	bic.w	r1, r0, #7
     a3e:	468d      	mov	sp, r1
     a40:	b481      	push	{r0, r7}
     a42:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     a44:	beff      	bkpt	0x00ff
}
     a46:	46bd      	mov	sp, r7
     a48:	bc81      	pop	{r0, r7}
     a4a:	4685      	mov	sp, r0
     a4c:	4770      	bx	lr
     a4e:	bf00      	nop

00000a50 <Unhandled_ivINT_PIT1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PIT1);
PE_ISR(Unhandled_ivINT_PIT1)
{
     a50:	4668      	mov	r0, sp
     a52:	f020 0107 	bic.w	r1, r0, #7
     a56:	468d      	mov	sp, r1
     a58:	b481      	push	{r0, r7}
     a5a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     a5c:	beff      	bkpt	0x00ff
}
     a5e:	46bd      	mov	sp, r7
     a60:	bc81      	pop	{r0, r7}
     a62:	4685      	mov	sp, r0
     a64:	4770      	bx	lr
     a66:	bf00      	nop

00000a68 <Unhandled_ivINT_PIT2>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PIT2);
PE_ISR(Unhandled_ivINT_PIT2)
{
     a68:	4668      	mov	r0, sp
     a6a:	f020 0107 	bic.w	r1, r0, #7
     a6e:	468d      	mov	sp, r1
     a70:	b481      	push	{r0, r7}
     a72:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     a74:	beff      	bkpt	0x00ff
}
     a76:	46bd      	mov	sp, r7
     a78:	bc81      	pop	{r0, r7}
     a7a:	4685      	mov	sp, r0
     a7c:	4770      	bx	lr
     a7e:	bf00      	nop

00000a80 <Unhandled_ivINT_PIT3>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PIT3);
PE_ISR(Unhandled_ivINT_PIT3)
{
     a80:	4668      	mov	r0, sp
     a82:	f020 0107 	bic.w	r1, r0, #7
     a86:	468d      	mov	sp, r1
     a88:	b481      	push	{r0, r7}
     a8a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     a8c:	beff      	bkpt	0x00ff
}
     a8e:	46bd      	mov	sp, r7
     a90:	bc81      	pop	{r0, r7}
     a92:	4685      	mov	sp, r0
     a94:	4770      	bx	lr
     a96:	bf00      	nop

00000a98 <Unhandled_ivINT_PDB0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PDB0);
PE_ISR(Unhandled_ivINT_PDB0)
{
     a98:	4668      	mov	r0, sp
     a9a:	f020 0107 	bic.w	r1, r0, #7
     a9e:	468d      	mov	sp, r1
     aa0:	b481      	push	{r0, r7}
     aa2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     aa4:	beff      	bkpt	0x00ff
}
     aa6:	46bd      	mov	sp, r7
     aa8:	bc81      	pop	{r0, r7}
     aaa:	4685      	mov	sp, r0
     aac:	4770      	bx	lr
     aae:	bf00      	nop

00000ab0 <Unhandled_ivINT_USB0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_USB0);
PE_ISR(Unhandled_ivINT_USB0)
{
     ab0:	4668      	mov	r0, sp
     ab2:	f020 0107 	bic.w	r1, r0, #7
     ab6:	468d      	mov	sp, r1
     ab8:	b481      	push	{r0, r7}
     aba:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     abc:	beff      	bkpt	0x00ff
}
     abe:	46bd      	mov	sp, r7
     ac0:	bc81      	pop	{r0, r7}
     ac2:	4685      	mov	sp, r0
     ac4:	4770      	bx	lr
     ac6:	bf00      	nop

00000ac8 <Unhandled_ivINT_USBDCD>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_USBDCD);
PE_ISR(Unhandled_ivINT_USBDCD)
{
     ac8:	4668      	mov	r0, sp
     aca:	f020 0107 	bic.w	r1, r0, #7
     ace:	468d      	mov	sp, r1
     ad0:	b481      	push	{r0, r7}
     ad2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     ad4:	beff      	bkpt	0x00ff
}
     ad6:	46bd      	mov	sp, r7
     ad8:	bc81      	pop	{r0, r7}
     ada:	4685      	mov	sp, r0
     adc:	4770      	bx	lr
     ade:	bf00      	nop

00000ae0 <Unhandled_ivINT_Reserved71>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved71);
PE_ISR(Unhandled_ivINT_Reserved71)
{
     ae0:	4668      	mov	r0, sp
     ae2:	f020 0107 	bic.w	r1, r0, #7
     ae6:	468d      	mov	sp, r1
     ae8:	b481      	push	{r0, r7}
     aea:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     aec:	beff      	bkpt	0x00ff
}
     aee:	46bd      	mov	sp, r7
     af0:	bc81      	pop	{r0, r7}
     af2:	4685      	mov	sp, r0
     af4:	4770      	bx	lr
     af6:	bf00      	nop

00000af8 <Unhandled_ivINT_DAC0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_DAC0);
PE_ISR(Unhandled_ivINT_DAC0)
{
     af8:	4668      	mov	r0, sp
     afa:	f020 0107 	bic.w	r1, r0, #7
     afe:	468d      	mov	sp, r1
     b00:	b481      	push	{r0, r7}
     b02:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b04:	beff      	bkpt	0x00ff
}
     b06:	46bd      	mov	sp, r7
     b08:	bc81      	pop	{r0, r7}
     b0a:	4685      	mov	sp, r0
     b0c:	4770      	bx	lr
     b0e:	bf00      	nop

00000b10 <Unhandled_ivINT_MCG>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_MCG);
PE_ISR(Unhandled_ivINT_MCG)
{
     b10:	4668      	mov	r0, sp
     b12:	f020 0107 	bic.w	r1, r0, #7
     b16:	468d      	mov	sp, r1
     b18:	b481      	push	{r0, r7}
     b1a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b1c:	beff      	bkpt	0x00ff
}
     b1e:	46bd      	mov	sp, r7
     b20:	bc81      	pop	{r0, r7}
     b22:	4685      	mov	sp, r0
     b24:	4770      	bx	lr
     b26:	bf00      	nop

00000b28 <Unhandled_ivINT_LPTMR0>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_LPTMR0);
PE_ISR(Unhandled_ivINT_LPTMR0)
{
     b28:	4668      	mov	r0, sp
     b2a:	f020 0107 	bic.w	r1, r0, #7
     b2e:	468d      	mov	sp, r1
     b30:	b481      	push	{r0, r7}
     b32:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b34:	beff      	bkpt	0x00ff
}
     b36:	46bd      	mov	sp, r7
     b38:	bc81      	pop	{r0, r7}
     b3a:	4685      	mov	sp, r0
     b3c:	4770      	bx	lr
     b3e:	bf00      	nop

00000b40 <Unhandled_ivINT_PORTA>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PORTA);
PE_ISR(Unhandled_ivINT_PORTA)
{
     b40:	4668      	mov	r0, sp
     b42:	f020 0107 	bic.w	r1, r0, #7
     b46:	468d      	mov	sp, r1
     b48:	b481      	push	{r0, r7}
     b4a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b4c:	beff      	bkpt	0x00ff
}
     b4e:	46bd      	mov	sp, r7
     b50:	bc81      	pop	{r0, r7}
     b52:	4685      	mov	sp, r0
     b54:	4770      	bx	lr
     b56:	bf00      	nop

00000b58 <Unhandled_ivINT_PORTB>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PORTB);
PE_ISR(Unhandled_ivINT_PORTB)
{
     b58:	4668      	mov	r0, sp
     b5a:	f020 0107 	bic.w	r1, r0, #7
     b5e:	468d      	mov	sp, r1
     b60:	b481      	push	{r0, r7}
     b62:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b64:	beff      	bkpt	0x00ff
}
     b66:	46bd      	mov	sp, r7
     b68:	bc81      	pop	{r0, r7}
     b6a:	4685      	mov	sp, r0
     b6c:	4770      	bx	lr
     b6e:	bf00      	nop

00000b70 <Unhandled_ivINT_PORTC>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PORTC);
PE_ISR(Unhandled_ivINT_PORTC)
{
     b70:	4668      	mov	r0, sp
     b72:	f020 0107 	bic.w	r1, r0, #7
     b76:	468d      	mov	sp, r1
     b78:	b481      	push	{r0, r7}
     b7a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b7c:	beff      	bkpt	0x00ff
}
     b7e:	46bd      	mov	sp, r7
     b80:	bc81      	pop	{r0, r7}
     b82:	4685      	mov	sp, r0
     b84:	4770      	bx	lr
     b86:	bf00      	nop

00000b88 <Unhandled_ivINT_PORTD>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PORTD);
PE_ISR(Unhandled_ivINT_PORTD)
{
     b88:	4668      	mov	r0, sp
     b8a:	f020 0107 	bic.w	r1, r0, #7
     b8e:	468d      	mov	sp, r1
     b90:	b481      	push	{r0, r7}
     b92:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     b94:	beff      	bkpt	0x00ff
}
     b96:	46bd      	mov	sp, r7
     b98:	bc81      	pop	{r0, r7}
     b9a:	4685      	mov	sp, r0
     b9c:	4770      	bx	lr
     b9e:	bf00      	nop

00000ba0 <Unhandled_ivINT_PORTE>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_PORTE);
PE_ISR(Unhandled_ivINT_PORTE)
{
     ba0:	4668      	mov	r0, sp
     ba2:	f020 0107 	bic.w	r1, r0, #7
     ba6:	468d      	mov	sp, r1
     ba8:	b481      	push	{r0, r7}
     baa:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     bac:	beff      	bkpt	0x00ff
}
     bae:	46bd      	mov	sp, r7
     bb0:	bc81      	pop	{r0, r7}
     bb2:	4685      	mov	sp, r0
     bb4:	4770      	bx	lr
     bb6:	bf00      	nop

00000bb8 <Unhandled_ivINT_SWI>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SWI);
PE_ISR(Unhandled_ivINT_SWI)
{
     bb8:	4668      	mov	r0, sp
     bba:	f020 0107 	bic.w	r1, r0, #7
     bbe:	468d      	mov	sp, r1
     bc0:	b481      	push	{r0, r7}
     bc2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     bc4:	beff      	bkpt	0x00ff
}
     bc6:	46bd      	mov	sp, r7
     bc8:	bc81      	pop	{r0, r7}
     bca:	4685      	mov	sp, r0
     bcc:	4770      	bx	lr
     bce:	bf00      	nop

00000bd0 <Unhandled_ivINT_SPI2>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SPI2);
PE_ISR(Unhandled_ivINT_SPI2)
{
     bd0:	4668      	mov	r0, sp
     bd2:	f020 0107 	bic.w	r1, r0, #7
     bd6:	468d      	mov	sp, r1
     bd8:	b481      	push	{r0, r7}
     bda:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     bdc:	beff      	bkpt	0x00ff
}
     bde:	46bd      	mov	sp, r7
     be0:	bc81      	pop	{r0, r7}
     be2:	4685      	mov	sp, r0
     be4:	4770      	bx	lr
     be6:	bf00      	nop

00000be8 <Unhandled_ivINT_UART4_RX_TX>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART4_RX_TX);
PE_ISR(Unhandled_ivINT_UART4_RX_TX)
{
     be8:	4668      	mov	r0, sp
     bea:	f020 0107 	bic.w	r1, r0, #7
     bee:	468d      	mov	sp, r1
     bf0:	b481      	push	{r0, r7}
     bf2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     bf4:	beff      	bkpt	0x00ff
}
     bf6:	46bd      	mov	sp, r7
     bf8:	bc81      	pop	{r0, r7}
     bfa:	4685      	mov	sp, r0
     bfc:	4770      	bx	lr
     bfe:	bf00      	nop

00000c00 <Unhandled_ivINT_UART4_ERR>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART4_ERR);
PE_ISR(Unhandled_ivINT_UART4_ERR)
{
     c00:	4668      	mov	r0, sp
     c02:	f020 0107 	bic.w	r1, r0, #7
     c06:	468d      	mov	sp, r1
     c08:	b481      	push	{r0, r7}
     c0a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c0c:	beff      	bkpt	0x00ff
}
     c0e:	46bd      	mov	sp, r7
     c10:	bc81      	pop	{r0, r7}
     c12:	4685      	mov	sp, r0
     c14:	4770      	bx	lr
     c16:	bf00      	nop

00000c18 <Unhandled_ivINT_UART5_RX_TX>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART5_RX_TX);
PE_ISR(Unhandled_ivINT_UART5_RX_TX)
{
     c18:	4668      	mov	r0, sp
     c1a:	f020 0107 	bic.w	r1, r0, #7
     c1e:	468d      	mov	sp, r1
     c20:	b481      	push	{r0, r7}
     c22:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c24:	beff      	bkpt	0x00ff
}
     c26:	46bd      	mov	sp, r7
     c28:	bc81      	pop	{r0, r7}
     c2a:	4685      	mov	sp, r0
     c2c:	4770      	bx	lr
     c2e:	bf00      	nop

00000c30 <Unhandled_ivINT_UART5_ERR>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_UART5_ERR);
PE_ISR(Unhandled_ivINT_UART5_ERR)
{
     c30:	4668      	mov	r0, sp
     c32:	f020 0107 	bic.w	r1, r0, #7
     c36:	468d      	mov	sp, r1
     c38:	b481      	push	{r0, r7}
     c3a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c3c:	beff      	bkpt	0x00ff
}
     c3e:	46bd      	mov	sp, r7
     c40:	bc81      	pop	{r0, r7}
     c42:	4685      	mov	sp, r0
     c44:	4770      	bx	lr
     c46:	bf00      	nop

00000c48 <Unhandled_ivINT_CMP2>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CMP2);
PE_ISR(Unhandled_ivINT_CMP2)
{
     c48:	4668      	mov	r0, sp
     c4a:	f020 0107 	bic.w	r1, r0, #7
     c4e:	468d      	mov	sp, r1
     c50:	b481      	push	{r0, r7}
     c52:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c54:	beff      	bkpt	0x00ff
}
     c56:	46bd      	mov	sp, r7
     c58:	bc81      	pop	{r0, r7}
     c5a:	4685      	mov	sp, r0
     c5c:	4770      	bx	lr
     c5e:	bf00      	nop

00000c60 <Unhandled_ivINT_FTM3>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_FTM3);
PE_ISR(Unhandled_ivINT_FTM3)
{
     c60:	4668      	mov	r0, sp
     c62:	f020 0107 	bic.w	r1, r0, #7
     c66:	468d      	mov	sp, r1
     c68:	b481      	push	{r0, r7}
     c6a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c6c:	beff      	bkpt	0x00ff
}
     c6e:	46bd      	mov	sp, r7
     c70:	bc81      	pop	{r0, r7}
     c72:	4685      	mov	sp, r0
     c74:	4770      	bx	lr
     c76:	bf00      	nop

00000c78 <Unhandled_ivINT_Reserved88>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_Reserved88);
PE_ISR(Unhandled_ivINT_Reserved88)
{
     c78:	4668      	mov	r0, sp
     c7a:	f020 0107 	bic.w	r1, r0, #7
     c7e:	468d      	mov	sp, r1
     c80:	b481      	push	{r0, r7}
     c82:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c84:	beff      	bkpt	0x00ff
}
     c86:	46bd      	mov	sp, r7
     c88:	bc81      	pop	{r0, r7}
     c8a:	4685      	mov	sp, r0
     c8c:	4770      	bx	lr
     c8e:	bf00      	nop

00000c90 <Unhandled_ivINT_ADC1>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_ADC1);
PE_ISR(Unhandled_ivINT_ADC1)
{
     c90:	4668      	mov	r0, sp
     c92:	f020 0107 	bic.w	r1, r0, #7
     c96:	468d      	mov	sp, r1
     c98:	b481      	push	{r0, r7}
     c9a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     c9c:	beff      	bkpt	0x00ff
}
     c9e:	46bd      	mov	sp, r7
     ca0:	bc81      	pop	{r0, r7}
     ca2:	4685      	mov	sp, r0
     ca4:	4770      	bx	lr
     ca6:	bf00      	nop

00000ca8 <Unhandled_ivINT_I2C2>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_I2C2);
PE_ISR(Unhandled_ivINT_I2C2)
{
     ca8:	4668      	mov	r0, sp
     caa:	f020 0107 	bic.w	r1, r0, #7
     cae:	468d      	mov	sp, r1
     cb0:	b481      	push	{r0, r7}
     cb2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     cb4:	beff      	bkpt	0x00ff
}
     cb6:	46bd      	mov	sp, r7
     cb8:	bc81      	pop	{r0, r7}
     cba:	4685      	mov	sp, r0
     cbc:	4770      	bx	lr
     cbe:	bf00      	nop

00000cc0 <Unhandled_ivINT_CAN0_ORed_Message_buffer>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CAN0_ORed_Message_buffer);
PE_ISR(Unhandled_ivINT_CAN0_ORed_Message_buffer)
{
     cc0:	4668      	mov	r0, sp
     cc2:	f020 0107 	bic.w	r1, r0, #7
     cc6:	468d      	mov	sp, r1
     cc8:	b481      	push	{r0, r7}
     cca:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     ccc:	beff      	bkpt	0x00ff
}
     cce:	46bd      	mov	sp, r7
     cd0:	bc81      	pop	{r0, r7}
     cd2:	4685      	mov	sp, r0
     cd4:	4770      	bx	lr
     cd6:	bf00      	nop

00000cd8 <Unhandled_ivINT_CAN0_Bus_Off>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CAN0_Bus_Off);
PE_ISR(Unhandled_ivINT_CAN0_Bus_Off)
{
     cd8:	4668      	mov	r0, sp
     cda:	f020 0107 	bic.w	r1, r0, #7
     cde:	468d      	mov	sp, r1
     ce0:	b481      	push	{r0, r7}
     ce2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     ce4:	beff      	bkpt	0x00ff
}
     ce6:	46bd      	mov	sp, r7
     ce8:	bc81      	pop	{r0, r7}
     cea:	4685      	mov	sp, r0
     cec:	4770      	bx	lr
     cee:	bf00      	nop

00000cf0 <Unhandled_ivINT_CAN0_Error>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CAN0_Error);
PE_ISR(Unhandled_ivINT_CAN0_Error)
{
     cf0:	4668      	mov	r0, sp
     cf2:	f020 0107 	bic.w	r1, r0, #7
     cf6:	468d      	mov	sp, r1
     cf8:	b481      	push	{r0, r7}
     cfa:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     cfc:	beff      	bkpt	0x00ff
}
     cfe:	46bd      	mov	sp, r7
     d00:	bc81      	pop	{r0, r7}
     d02:	4685      	mov	sp, r0
     d04:	4770      	bx	lr
     d06:	bf00      	nop

00000d08 <Unhandled_ivINT_CAN0_Tx_Warning>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CAN0_Tx_Warning);
PE_ISR(Unhandled_ivINT_CAN0_Tx_Warning)
{
     d08:	4668      	mov	r0, sp
     d0a:	f020 0107 	bic.w	r1, r0, #7
     d0e:	468d      	mov	sp, r1
     d10:	b481      	push	{r0, r7}
     d12:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     d14:	beff      	bkpt	0x00ff
}
     d16:	46bd      	mov	sp, r7
     d18:	bc81      	pop	{r0, r7}
     d1a:	4685      	mov	sp, r0
     d1c:	4770      	bx	lr
     d1e:	bf00      	nop

00000d20 <Unhandled_ivINT_CAN0_Rx_Warning>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CAN0_Rx_Warning);
PE_ISR(Unhandled_ivINT_CAN0_Rx_Warning)
{
     d20:	4668      	mov	r0, sp
     d22:	f020 0107 	bic.w	r1, r0, #7
     d26:	468d      	mov	sp, r1
     d28:	b481      	push	{r0, r7}
     d2a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     d2c:	beff      	bkpt	0x00ff
}
     d2e:	46bd      	mov	sp, r7
     d30:	bc81      	pop	{r0, r7}
     d32:	4685      	mov	sp, r0
     d34:	4770      	bx	lr
     d36:	bf00      	nop

00000d38 <Unhandled_ivINT_CAN0_Wake_Up>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_CAN0_Wake_Up);
PE_ISR(Unhandled_ivINT_CAN0_Wake_Up)
{
     d38:	4668      	mov	r0, sp
     d3a:	f020 0107 	bic.w	r1, r0, #7
     d3e:	468d      	mov	sp, r1
     d40:	b481      	push	{r0, r7}
     d42:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     d44:	beff      	bkpt	0x00ff
}
     d46:	46bd      	mov	sp, r7
     d48:	bc81      	pop	{r0, r7}
     d4a:	4685      	mov	sp, r0
     d4c:	4770      	bx	lr
     d4e:	bf00      	nop

00000d50 <Unhandled_ivINT_SDHC>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_SDHC);
PE_ISR(Unhandled_ivINT_SDHC)
{
     d50:	4668      	mov	r0, sp
     d52:	f020 0107 	bic.w	r1, r0, #7
     d56:	468d      	mov	sp, r1
     d58:	b481      	push	{r0, r7}
     d5a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     d5c:	beff      	bkpt	0x00ff
}
     d5e:	46bd      	mov	sp, r7
     d60:	bc81      	pop	{r0, r7}
     d62:	4685      	mov	sp, r0
     d64:	4770      	bx	lr
     d66:	bf00      	nop

00000d68 <Unhandled_ivINT_ENET_1588_Timer>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_ENET_1588_Timer);
PE_ISR(Unhandled_ivINT_ENET_1588_Timer)
{
     d68:	4668      	mov	r0, sp
     d6a:	f020 0107 	bic.w	r1, r0, #7
     d6e:	468d      	mov	sp, r1
     d70:	b481      	push	{r0, r7}
     d72:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     d74:	beff      	bkpt	0x00ff
}
     d76:	46bd      	mov	sp, r7
     d78:	bc81      	pop	{r0, r7}
     d7a:	4685      	mov	sp, r0
     d7c:	4770      	bx	lr
     d7e:	bf00      	nop

00000d80 <Unhandled_ivINT_ENET_Transmit>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_ENET_Transmit);
PE_ISR(Unhandled_ivINT_ENET_Transmit)
{
     d80:	4668      	mov	r0, sp
     d82:	f020 0107 	bic.w	r1, r0, #7
     d86:	468d      	mov	sp, r1
     d88:	b481      	push	{r0, r7}
     d8a:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     d8c:	beff      	bkpt	0x00ff
}
     d8e:	46bd      	mov	sp, r7
     d90:	bc81      	pop	{r0, r7}
     d92:	4685      	mov	sp, r0
     d94:	4770      	bx	lr
     d96:	bf00      	nop

00000d98 <Unhandled_ivINT_ENET_Receive>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_ENET_Receive);
PE_ISR(Unhandled_ivINT_ENET_Receive)
{
     d98:	4668      	mov	r0, sp
     d9a:	f020 0107 	bic.w	r1, r0, #7
     d9e:	468d      	mov	sp, r1
     da0:	b481      	push	{r0, r7}
     da2:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     da4:	beff      	bkpt	0x00ff
}
     da6:	46bd      	mov	sp, r7
     da8:	bc81      	pop	{r0, r7}
     daa:	4685      	mov	sp, r0
     dac:	4770      	bx	lr
     dae:	bf00      	nop

00000db0 <Unhandled_ivINT_ENET_Error>:
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Unhandled_ivINT_ENET_Error);
PE_ISR(Unhandled_ivINT_ENET_Error)
{
     db0:	4668      	mov	r0, sp
     db2:	f020 0107 	bic.w	r1, r0, #7
     db6:	468d      	mov	sp, r1
     db8:	b481      	push	{r0, r7}
     dba:	af00      	add	r7, sp, #0
  PE_DEBUGHALT();
     dbc:	beff      	bkpt	0x00ff
}
     dbe:	46bd      	mov	sp, r7
     dc0:	bc81      	pop	{r0, r7}
     dc2:	4685      	mov	sp, r0
     dc4:	4770      	bx	lr
     dc6:	bf00      	nop

00000dc8 <Peripherals_Init>:
#ifdef __cplusplus
extern "C" {
#endif

void Peripherals_Init(void)
{
     dc8:	b480      	push	{r7}
     dca:	af00      	add	r7, sp, #0
  VREF_Init();
#endif /* VREF_AUTOINIT */
#ifdef WDOG_AUTOINIT
  WDOG_Init();
#endif /* WDOG_AUTOINIT */
}
     dcc:	46bd      	mov	sp, r7
     dce:	f85d 7b04 	ldr.w	r7, [sp], #4
     dd2:	4770      	bx	lr

00000dd4 <CPU_SetBASEPRI>:
asm void CPU_SetBASEPRI(register uint32_t Level) {
  MSR BASEPRI,R0;
  MOV PC,LR
}
#elif defined(__GNUC__)
void CPU_SetBASEPRI(uint32_t Level) {
     dd4:	b480      	push	{r7}
     dd6:	b083      	sub	sp, #12
     dd8:	af00      	add	r7, sp, #0
     dda:	6078      	str	r0, [r7, #4]
  __asm ("msr basepri, %[input]"::[input] "r" (Level):);
     ddc:	687b      	ldr	r3, [r7, #4]
     dde:	f383 8811 	msr	BASEPRI, r3
}
     de2:	370c      	adds	r7, #12
     de4:	46bd      	mov	sp, r7
     de6:	f85d 7b04 	ldr.w	r7, [sp], #4
     dea:	4770      	bx	lr

00000dec <__init_hardware>:
  #if defined(__IAR_SYSTEMS_ICC__)    
    #define PEX_ENTRYPOINT_FUNCTION_RETURN return 1;
  #endif
#endif
PEX_ENTRYPOINT_FUNCTION_TYPE PEX_ENTRYPOINT_FUNCTION()
{
     dec:	b580      	push	{r7, lr}
     dee:	af00      	add	r7, sp, #0
  /* Interrupt vector placement initialization */
  #if PEX_VECTOR_TABLE
    #if defined(__IAR_SYSTEMS_ICC__)
  SCB_VTOR = (uint32_t)(&__vector_table); /* Set the interrupt vector table position */
    #elif defined(__CWCC__) | defined(__GNUC__) | defined(__CC_ARM)
  SCB_VTOR = (uint32_t)(&__vect_table); /* Set the interrupt vector table position */
     df0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     df4:	4a2f      	ldr	r2, [pc, #188]	; (eb4 <__init_hardware+0xc8>)
     df6:	f8c3 2d08 	str.w	r2, [r3, #3336]	; 0xd08
    #endif
  #endif
  /* Disable the WDOG module */
  #if STARTUP_WDOG
  WDOG_UNLOCK = (uint16_t)STARTUP_WDOG_KEY_1; /* Key 1 */
     dfa:	4b2f      	ldr	r3, [pc, #188]	; (eb8 <__init_hardware+0xcc>)
     dfc:	f24c 5220 	movw	r2, #50464	; 0xc520
     e00:	81da      	strh	r2, [r3, #14]
  WDOG_UNLOCK = (uint16_t)STARTUP_WDOG_KEY_2; /* Key 2 */
     e02:	4b2d      	ldr	r3, [pc, #180]	; (eb8 <__init_hardware+0xcc>)
     e04:	f64d 1228 	movw	r2, #55592	; 0xd928
     e08:	81da      	strh	r2, [r3, #14]
  WDOG_STCTRLH = (uint16_t)STARTUP_WDOG_STCTRLH_VALUE; /* Disable WDOG */
     e0a:	4b2b      	ldr	r3, [pc, #172]	; (eb8 <__init_hardware+0xcc>)
     e0c:	f44f 72e9 	mov.w	r2, #466	; 0x1d2
     e10:	801a      	strh	r2, [r3, #0]
  SIM_SCGC4 |= SIM_SCGC4_USBOTG_MASK;
  SIM_SCGC4 &= (uint32_t)~(uint32_t)(SIM_SCGC4_USBOTG_MASK);
#endif 
#if STARTUP_RTCOSC
  /* SIM_SCGC6: RTC=1 */
  SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
     e12:	492a      	ldr	r1, [pc, #168]	; (ebc <__init_hardware+0xd0>)
     e14:	4b29      	ldr	r3, [pc, #164]	; (ebc <__init_hardware+0xd0>)
     e16:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
     e1a:	331c      	adds	r3, #28
     e1c:	681b      	ldr	r3, [r3, #0]
     e1e:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
     e22:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
     e26:	331c      	adds	r3, #28
     e28:	601a      	str	r2, [r3, #0]
  if ((RTC_CR & RTC_CR_OSCE_MASK) == 0u) { /* Only if the OSCILLATOR is not already enabled */
     e2a:	4b25      	ldr	r3, [pc, #148]	; (ec0 <__init_hardware+0xd4>)
     e2c:	691b      	ldr	r3, [r3, #16]
     e2e:	f403 7380 	and.w	r3, r3, #256	; 0x100
     e32:	2b00      	cmp	r3, #0
     e34:	d111      	bne.n	e5a <__init_hardware+0x6e>
    RTC_CR = (uint32_t)((RTC_CR & (uint32_t)~(uint32_t)(RTC_CR_SC2P_MASK | RTC_CR_SC4P_MASK | RTC_CR_SC8P_MASK | RTC_CR_SC16P_MASK)) | (uint32_t)STARTUP_RTC_CR_SC_VALUE);
     e36:	4b22      	ldr	r3, [pc, #136]	; (ec0 <__init_hardware+0xd4>)
     e38:	4a21      	ldr	r2, [pc, #132]	; (ec0 <__init_hardware+0xd4>)
     e3a:	6912      	ldr	r2, [r2, #16]
     e3c:	f422 5270 	bic.w	r2, r2, #15360	; 0x3c00
     e40:	611a      	str	r2, [r3, #16]
    RTC_CR |= (uint32_t)RTC_CR_OSCE_MASK;
     e42:	4b1f      	ldr	r3, [pc, #124]	; (ec0 <__init_hardware+0xd4>)
     e44:	4a1e      	ldr	r2, [pc, #120]	; (ec0 <__init_hardware+0xd4>)
     e46:	6912      	ldr	r2, [r2, #16]
     e48:	f442 7280 	orr.w	r2, r2, #256	; 0x100
     e4c:	611a      	str	r2, [r3, #16]
    RTC_CR &= (uint32_t)~(uint32_t)RTC_CR_CLKO_MASK;
     e4e:	4b1c      	ldr	r3, [pc, #112]	; (ec0 <__init_hardware+0xd4>)
     e50:	4a1b      	ldr	r2, [pc, #108]	; (ec0 <__init_hardware+0xd4>)
     e52:	6912      	ldr	r2, [r2, #16]
     e54:	f422 7200 	bic.w	r2, r2, #512	; 0x200
     e58:	611a      	str	r2, [r3, #16]
    #endif /* defined(STARTUP_CLOCK_INTERNAL_FAST_TRIM_ADDRESS) */
  #endif /* STARTUP_CLOCK_INTERNAL_FAST_TRIM */
  /* Low power modes protection */
  
  /* Disable very low power mode protection */
  SMC_PMPROT = (CPU_LOW_POWER_ALLOW_VLP? SMC_PMPROT_AVLP_MASK : 0) |
     e5a:	4b1a      	ldr	r3, [pc, #104]	; (ec4 <__init_hardware+0xd8>)
     e5c:	2220      	movs	r2, #32
     e5e:	701a      	strb	r2, [r3, #0]
               (CPU_LOW_POWER_ALLOW_LLS? SMC_PMPROT_ALLS_MASK : 0) |
               (CPU_LOW_POWER_ALLOW_VLLS? SMC_PMPROT_AVLLS_MASK : 0);
  /* SIM_CLKDIV1: OUTDIV1=0,OUTDIV2=1,OUTDIV3=4,OUTDIV4=4,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0x00) |
     e60:	4b16      	ldr	r3, [pc, #88]	; (ebc <__init_hardware+0xd0>)
     e62:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
     e66:	3304      	adds	r3, #4
     e68:	f04f 72a2 	mov.w	r2, #21233664	; 0x1440000
     e6c:	601a      	str	r2, [r3, #0]
                SIM_CLKDIV1_OUTDIV2(0x01) |
                SIM_CLKDIV1_OUTDIV3(0x04) |
                SIM_CLKDIV1_OUTDIV4(0x04); /* Set the system prescalers to safe value */
  CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_0);
     e6e:	2000      	movs	r0, #0
     e70:	f000 f87c 	bl	f6c <CPU_SetClockConfigGenMode>
  SIM_CLKDIV1 = (uint32_t)CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_0].SysRegs.SIM_CLKDIV1_value; /* Update system prescalers */
     e74:	4b11      	ldr	r3, [pc, #68]	; (ebc <__init_hardware+0xd0>)
     e76:	f44f 1288 	mov.w	r2, #1114112	; 0x110000
     e7a:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
     e7e:	3304      	adds	r3, #4
     e80:	601a      	str	r2, [r3, #0]
  SIM_SOPT1 = (uint32_t)((SIM_SOPT1 & (uint32_t)~(uint32_t)SIM_SOPT1_OSC32KSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_0].SysRegs.SIM_SOPT1_value); /* Update 32 kHz oscillator clock source (ERCLK32K) */
     e82:	4b0e      	ldr	r3, [pc, #56]	; (ebc <__init_hardware+0xd0>)
     e84:	4a0d      	ldr	r2, [pc, #52]	; (ebc <__init_hardware+0xd0>)
     e86:	6812      	ldr	r2, [r2, #0]
     e88:	f422 2140 	bic.w	r1, r2, #786432	; 0xc0000
     e8c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
     e90:	430a      	orrs	r2, r1
     e92:	601a      	str	r2, [r3, #0]
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)SIM_SOPT2_PLLFLLSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_0].SysRegs.SIM_SOPT2_value); /* Update PLL/FLL clock select */
     e94:	4909      	ldr	r1, [pc, #36]	; (ebc <__init_hardware+0xd0>)
     e96:	4b09      	ldr	r3, [pc, #36]	; (ebc <__init_hardware+0xd0>)
     e98:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     e9c:	3304      	adds	r3, #4
     e9e:	681b      	ldr	r3, [r3, #0]
     ea0:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
     ea4:	2300      	movs	r3, #0
     ea6:	431a      	orrs	r2, r3
     ea8:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
     eac:	3304      	adds	r3, #4
     eae:	601a      	str	r2, [r3, #0]
  #if defined(PEX_ENTRYPOINT_FUNCTION_RETURN)
  PEX_ENTRYPOINT_FUNCTION_RETURN
  #endif  
}
     eb0:	bd80      	pop	{r7, pc}
     eb2:	bf00      	nop
     eb4:	00000000 	.word	0x00000000
     eb8:	40052000 	.word	0x40052000
     ebc:	40047000 	.word	0x40047000
     ec0:	4003d000 	.word	0x4003d000
     ec4:	4007e000 	.word	0x4007e000

00000ec8 <PE_low_level_init>:
**         of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void PE_low_level_init(void)
{
     ec8:	b580      	push	{r7, lr}
     eca:	af00      	add	r7, sp, #0
  /* RTOS initialization */

  #ifdef PEX_RTOS_INIT
    PEX_RTOS_INIT();                   /* Initialization of the selected RTOS. Macro is defined by the RTOS component. */
     ecc:	b672      	cpsid	i
  #endif /* CPU_ON_RESET_EVENT_NAME */
  
  /* Rest of components initialization */
  
  #if CPU_COMPONENTS_INIT
  Components_Init();
     ece:	f005 ff93 	bl	6df8 <Components_Init>
    #if defined(__IAR_SYSTEMS_ICC__)
    __set_BASEPRI(CPU_INT_PRIORITY);
    #elif defined(__CWCC__)
    CPU_SetBASEPRI(CPU_INT_PRIORITY);
    #elif defined(__GNUC__)
    CPU_SetBASEPRI(CPU_INT_PRIORITY);
     ed2:	20f0      	movs	r0, #240	; 0xf0
     ed4:	f7ff ff7e 	bl	dd4 <CPU_SetBASEPRI>
    CPU_SetBASEPRI(CPU_INT_PRIORITY);
  	#else /* defined(compiler ID) */
  	  #error Unsupported compiler
  	#endif /* defined(compiler ID) */
  #endif
}
     ed8:	bd80      	pop	{r7, pc}
     eda:	bf00      	nop

00000edc <CPU_GetClockGenMode>:

CPU_TClockGenMode CPU_GetClockGenMode(void)
{
     edc:	b480      	push	{r7}
     ede:	af00      	add	r7, sp, #0
  switch (MCG_C1  & MCG_C1_CLKS_MASK) {
     ee0:	4b21      	ldr	r3, [pc, #132]	; (f68 <CPU_GetClockGenMode+0x8c>)
     ee2:	781b      	ldrb	r3, [r3, #0]
     ee4:	b2db      	uxtb	r3, r3
     ee6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
     eea:	2b40      	cmp	r3, #64	; 0x40
     eec:	d017      	beq.n	f1e <CPU_GetClockGenMode+0x42>
     eee:	2b80      	cmp	r3, #128	; 0x80
     ef0:	d020      	beq.n	f34 <CPU_GetClockGenMode+0x58>
     ef2:	2b00      	cmp	r3, #0
     ef4:	d132      	bne.n	f5c <CPU_GetClockGenMode+0x80>
    case  0x00U:
      /* Output of FLL or PLL is selected */
      if ((MCG_C6 & MCG_C6_PLLS_MASK) == 0x00U) {
     ef6:	4b1c      	ldr	r3, [pc, #112]	; (f68 <CPU_GetClockGenMode+0x8c>)
     ef8:	795b      	ldrb	r3, [r3, #5]
     efa:	b2db      	uxtb	r3, r3
     efc:	f003 0340 	and.w	r3, r3, #64	; 0x40
     f00:	2b00      	cmp	r3, #0
     f02:	d10a      	bne.n	f1a <CPU_GetClockGenMode+0x3e>
        /* Output of FLL is selected */
        if ((MCG_C1 & MCG_C1_IREFS_MASK) == 0x00U) {
     f04:	4b18      	ldr	r3, [pc, #96]	; (f68 <CPU_GetClockGenMode+0x8c>)
     f06:	781b      	ldrb	r3, [r3, #0]
     f08:	b2db      	uxtb	r3, r3
     f0a:	f003 0304 	and.w	r3, r3, #4
     f0e:	2b00      	cmp	r3, #0
     f10:	d101      	bne.n	f16 <CPU_GetClockGenMode+0x3a>
          /* External reference clock is selected */
          return CPU_MCG_MODE_FEE;
     f12:	2303      	movs	r3, #3
     f14:	e023      	b.n	f5e <CPU_GetClockGenMode+0x82>
        } else {
          /* Internal reference clock is selected */
          return CPU_MCG_MODE_FEI;
     f16:	2300      	movs	r3, #0
     f18:	e021      	b.n	f5e <CPU_GetClockGenMode+0x82>
        }
      } else {
        /* Output of FLL is selected */
	      return CPU_MCG_MODE_PEE;
     f1a:	2307      	movs	r3, #7
     f1c:	e01f      	b.n	f5e <CPU_GetClockGenMode+0x82>
	    }  
    case 0x40U:
      /* Internal reference clock is selected */
      if ((MCG_C2 & MCG_C2_LP_MASK) == 0x00U) {
     f1e:	4b12      	ldr	r3, [pc, #72]	; (f68 <CPU_GetClockGenMode+0x8c>)
     f20:	785b      	ldrb	r3, [r3, #1]
     f22:	b2db      	uxtb	r3, r3
     f24:	f003 0302 	and.w	r3, r3, #2
     f28:	2b00      	cmp	r3, #0
     f2a:	d101      	bne.n	f30 <CPU_GetClockGenMode+0x54>
        /* Low power mode is disabled */
        return CPU_MCG_MODE_FBI;
     f2c:	2301      	movs	r3, #1
     f2e:	e016      	b.n	f5e <CPU_GetClockGenMode+0x82>
      } else {
        /* Low power mode is enabled */
        return CPU_MCG_MODE_BLPI;
     f30:	2302      	movs	r3, #2
     f32:	e014      	b.n	f5e <CPU_GetClockGenMode+0x82>
      }
    case 0x80U:
      /* External reference clock is selected */
      if ((MCG_C6 & MCG_C6_PLLS_MASK) == 0x00U) {
     f34:	4b0c      	ldr	r3, [pc, #48]	; (f68 <CPU_GetClockGenMode+0x8c>)
     f36:	795b      	ldrb	r3, [r3, #5]
     f38:	b2db      	uxtb	r3, r3
     f3a:	f003 0340 	and.w	r3, r3, #64	; 0x40
     f3e:	2b00      	cmp	r3, #0
     f40:	d10a      	bne.n	f58 <CPU_GetClockGenMode+0x7c>
        /* FLL or PLL is selected */
        if ((MCG_C2 & MCG_C2_LP_MASK) == 0x00U) {
     f42:	4b09      	ldr	r3, [pc, #36]	; (f68 <CPU_GetClockGenMode+0x8c>)
     f44:	785b      	ldrb	r3, [r3, #1]
     f46:	b2db      	uxtb	r3, r3
     f48:	f003 0302 	and.w	r3, r3, #2
     f4c:	2b00      	cmp	r3, #0
     f4e:	d101      	bne.n	f54 <CPU_GetClockGenMode+0x78>
          /* FLL is selected */
          return CPU_MCG_MODE_FBE;
     f50:	2304      	movs	r3, #4
     f52:	e004      	b.n	f5e <CPU_GetClockGenMode+0x82>
        } else {
          /* Low power mode is enabled */
          return CPU_MCG_MODE_BLPE;
     f54:	2305      	movs	r3, #5
     f56:	e002      	b.n	f5e <CPU_GetClockGenMode+0x82>
        }
      } else {
        /* PLL is selected */
        return CPU_MCG_MODE_PBE;
     f58:	2306      	movs	r3, #6
     f5a:	e000      	b.n	f5e <CPU_GetClockGenMode+0x82>
      }
    default:
      return (CPU_TClockGenMode)0x00U;
     f5c:	2300      	movs	r3, #0
  }
}
     f5e:	4618      	mov	r0, r3
     f60:	46bd      	mov	sp, r7
     f62:	f85d 7b04 	ldr.w	r7, [sp], #4
     f66:	4770      	bx	lr
     f68:	40064000 	.word	0x40064000

00000f6c <CPU_SetClockConfigGenMode>:

void CPU_SetClockConfigGenMode(LDD_TClockConfiguration ConfigID)
{
     f6c:	b590      	push	{r4, r7, lr}
     f6e:	b087      	sub	sp, #28
     f70:	af00      	add	r7, sp, #0
     f72:	4603      	mov	r3, r0
     f74:	71fb      	strb	r3, [r7, #7]
  CPU_TClockGenMode NextMode, TargetMCGMode;
  CPU_TClockGenRegs NextModeRegs;
  CPU_TClockGenMode TargetMode = CPU_ClockConfigDescriptors[ConfigID].Mode;
     f76:	79fa      	ldrb	r2, [r7, #7]
     f78:	49aa      	ldr	r1, [pc, #680]	; (1224 <malloc_getpagesize_P+0x224>)
     f7a:	4613      	mov	r3, r2
     f7c:	00db      	lsls	r3, r3, #3
     f7e:	1a9b      	subs	r3, r3, r2
     f80:	009b      	lsls	r3, r3, #2
     f82:	440b      	add	r3, r1
     f84:	881b      	ldrh	r3, [r3, #0]
     f86:	82bb      	strh	r3, [r7, #20]
  
  /* External clock source pin routing */
  if ((TargetMode & (CPU_CLOCK_EXTERNAL_CLOCK_MASK | CPU_CLOCK_EXTERNAL_CRYSTAL_MASK)) != 0) { /* Is external clock source used in targeted clock configuration? */
     f88:	8abb      	ldrh	r3, [r7, #20]
     f8a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
     f8e:	2b00      	cmp	r3, #0
     f90:	d020      	beq.n	fd4 <CPU_SetClockConfigGenMode+0x68>
    /* If yes, initialize the EXTAL pin routing */
    SIM_SCGC5 |= (uint32_t)SIM_SCGC5_PORTA_MASK; /* Enable EXTAL/XTAL pins clock gate */
     f92:	49a5      	ldr	r1, [pc, #660]	; (1228 <malloc_getpagesize_P+0x228>)
     f94:	4ba4      	ldr	r3, [pc, #656]	; (1228 <malloc_getpagesize_P+0x228>)
     f96:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
     f9a:	3318      	adds	r3, #24
     f9c:	681b      	ldr	r3, [r3, #0]
     f9e:	f443 7200 	orr.w	r2, r3, #512	; 0x200
     fa2:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
     fa6:	3318      	adds	r3, #24
     fa8:	601a      	str	r2, [r3, #0]
    /* PORTA_PCR18: ISF=0,MUX=0 */
    PORTA_PCR18 &= (uint32_t)~(uint32_t)(
     faa:	4aa0      	ldr	r2, [pc, #640]	; (122c <malloc_getpagesize_P+0x22c>)
     fac:	4b9f      	ldr	r3, [pc, #636]	; (122c <malloc_getpagesize_P+0x22c>)
     fae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     fb0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
     fb4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
     fb8:	6493      	str	r3, [r2, #72]	; 0x48
                    PORT_PCR_ISF_MASK |
                    PORT_PCR_MUX(0x07)
                   );
    if ((TargetMode & CPU_CLOCK_EXTERNAL_CRYSTAL_MASK) != 0) { /* Is external crystal/resonator used in targeted clock configuration? */
     fba:	8abb      	ldrh	r3, [r7, #20]
     fbc:	f003 0380 	and.w	r3, r3, #128	; 0x80
     fc0:	2b00      	cmp	r3, #0
     fc2:	d007      	beq.n	fd4 <CPU_SetClockConfigGenMode+0x68>
      /* If yes, initialize also XTAL pin routing */
      /* PORTA_PCR19: ISF=0,MUX=0 */
      PORTA_PCR19 &= (uint32_t)~(uint32_t)(
     fc4:	4a99      	ldr	r2, [pc, #612]	; (122c <malloc_getpagesize_P+0x22c>)
     fc6:	4b99      	ldr	r3, [pc, #612]	; (122c <malloc_getpagesize_P+0x22c>)
     fc8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
     fca:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
     fce:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
     fd2:	64d3      	str	r3, [r2, #76]	; 0x4c
                      PORT_PCR_MUX(0x07)
                     );
    }
  }
  
  if ((MCG_SC & MCG_SC_FCRDIV_MASK) != CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value) { /* Check if it is necessary to update Fast Clock Internal Reference Divider */ 
     fd4:	4b96      	ldr	r3, [pc, #600]	; (1230 <malloc_getpagesize_P+0x230>)
     fd6:	7a1b      	ldrb	r3, [r3, #8]
     fd8:	b2db      	uxtb	r3, r3
     fda:	f003 010e 	and.w	r1, r3, #14
     fde:	79fa      	ldrb	r2, [r7, #7]
     fe0:	4890      	ldr	r0, [pc, #576]	; (1224 <malloc_getpagesize_P+0x224>)
     fe2:	4613      	mov	r3, r2
     fe4:	00db      	lsls	r3, r3, #3
     fe6:	1a9b      	subs	r3, r3, r2
     fe8:	009b      	lsls	r3, r3, #2
     fea:	4403      	add	r3, r0
     fec:	7a5b      	ldrb	r3, [r3, #9]
     fee:	4299      	cmp	r1, r3
     ff0:	f000 8082 	beq.w	10f8 <malloc_getpagesize_P+0xf8>
    if ((MCG_C2 & MCG_C2_IRCS_MASK) == 0x00U) {
     ff4:	4b8e      	ldr	r3, [pc, #568]	; (1230 <malloc_getpagesize_P+0x230>)
     ff6:	785b      	ldrb	r3, [r3, #1]
     ff8:	b2db      	uxtb	r3, r3
     ffa:	f003 0301 	and.w	r3, r3, #1
     ffe:	2b00      	cmp	r3, #0
    1000:	d116      	bne.n	1030 <malloc_getpagesize_P+0x30>
      MCG_SC = (MCG_SC & (uint8_t)(~(MCG_SC_FCRDIV_MASK))) | CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value;
    1002:	498b      	ldr	r1, [pc, #556]	; (1230 <malloc_getpagesize_P+0x230>)
    1004:	4b8a      	ldr	r3, [pc, #552]	; (1230 <malloc_getpagesize_P+0x230>)
    1006:	7a1b      	ldrb	r3, [r3, #8]
    1008:	b2db      	uxtb	r3, r3
    100a:	b2db      	uxtb	r3, r3
    100c:	f023 030e 	bic.w	r3, r3, #14
    1010:	b2d8      	uxtb	r0, r3
    1012:	79fa      	ldrb	r2, [r7, #7]
    1014:	4c83      	ldr	r4, [pc, #524]	; (1224 <malloc_getpagesize_P+0x224>)
    1016:	4613      	mov	r3, r2
    1018:	00db      	lsls	r3, r3, #3
    101a:	1a9b      	subs	r3, r3, r2
    101c:	009b      	lsls	r3, r3, #2
    101e:	4423      	add	r3, r4
    1020:	7a5b      	ldrb	r3, [r3, #9]
    1022:	b2db      	uxtb	r3, r3
    1024:	4602      	mov	r2, r0
    1026:	4313      	orrs	r3, r2
    1028:	b2db      	uxtb	r3, r3
    102a:	b2db      	uxtb	r3, r3
    102c:	720b      	strb	r3, [r1, #8]
    102e:	e063      	b.n	10f8 <malloc_getpagesize_P+0xf8>
    } else {
      if ((MCG_C1 & (MCG_C1_IREFS_MASK || MCG_C1_IRCLKEN_MASK)) != 0x00U) { /* Is internal reference clock active? */      
    1030:	4b7f      	ldr	r3, [pc, #508]	; (1230 <malloc_getpagesize_P+0x230>)
    1032:	781b      	ldrb	r3, [r3, #0]
    1034:	b2db      	uxtb	r3, r3
    1036:	f003 0301 	and.w	r3, r3, #1
    103a:	2b00      	cmp	r3, #0
    103c:	d036      	beq.n	10ac <malloc_getpagesize_P+0xac>
        MCG_C2 &= (uint8_t)(~(MCG_C2_IRCS_MASK)); /* Disable the fast internal clock */
    103e:	4b7c      	ldr	r3, [pc, #496]	; (1230 <malloc_getpagesize_P+0x230>)
    1040:	4a7b      	ldr	r2, [pc, #492]	; (1230 <malloc_getpagesize_P+0x230>)
    1042:	7852      	ldrb	r2, [r2, #1]
    1044:	b2d2      	uxtb	r2, r2
    1046:	f022 0201 	bic.w	r2, r2, #1
    104a:	b2d2      	uxtb	r2, r2
    104c:	705a      	strb	r2, [r3, #1]
        while((MCG_S & MCG_S_IRCST_MASK) != 0x00U) { /* Check that the source internal reference clock is slow clock. */
    104e:	bf00      	nop
    1050:	4b77      	ldr	r3, [pc, #476]	; (1230 <malloc_getpagesize_P+0x230>)
    1052:	799b      	ldrb	r3, [r3, #6]
    1054:	b2db      	uxtb	r3, r3
    1056:	f003 0301 	and.w	r3, r3, #1
    105a:	2b00      	cmp	r3, #0
    105c:	d1f8      	bne.n	1050 <malloc_getpagesize_P+0x50>
        }
        MCG_SC = (MCG_SC & (uint8_t)(~(MCG_SC_FCRDIV_MASK))) | CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value;    
    105e:	4974      	ldr	r1, [pc, #464]	; (1230 <malloc_getpagesize_P+0x230>)
    1060:	4b73      	ldr	r3, [pc, #460]	; (1230 <malloc_getpagesize_P+0x230>)
    1062:	7a1b      	ldrb	r3, [r3, #8]
    1064:	b2db      	uxtb	r3, r3
    1066:	b2db      	uxtb	r3, r3
    1068:	f023 030e 	bic.w	r3, r3, #14
    106c:	b2d8      	uxtb	r0, r3
    106e:	79fa      	ldrb	r2, [r7, #7]
    1070:	4c6c      	ldr	r4, [pc, #432]	; (1224 <malloc_getpagesize_P+0x224>)
    1072:	4613      	mov	r3, r2
    1074:	00db      	lsls	r3, r3, #3
    1076:	1a9b      	subs	r3, r3, r2
    1078:	009b      	lsls	r3, r3, #2
    107a:	4423      	add	r3, r4
    107c:	7a5b      	ldrb	r3, [r3, #9]
    107e:	b2db      	uxtb	r3, r3
    1080:	4602      	mov	r2, r0
    1082:	4313      	orrs	r3, r2
    1084:	b2db      	uxtb	r3, r3
    1086:	b2db      	uxtb	r3, r3
    1088:	720b      	strb	r3, [r1, #8]
        MCG_C2 |= MCG_C2_IRCS_MASK;    /* Re-enable the fast internal clock */
    108a:	4b69      	ldr	r3, [pc, #420]	; (1230 <malloc_getpagesize_P+0x230>)
    108c:	4a68      	ldr	r2, [pc, #416]	; (1230 <malloc_getpagesize_P+0x230>)
    108e:	7852      	ldrb	r2, [r2, #1]
    1090:	b2d2      	uxtb	r2, r2
    1092:	f042 0201 	orr.w	r2, r2, #1
    1096:	b2d2      	uxtb	r2, r2
    1098:	705a      	strb	r2, [r3, #1]
        while((MCG_S & MCG_S_IRCST_MASK) == 0x00U) { /* Check that the source internal reference clock is fast clock. */
    109a:	bf00      	nop
    109c:	4b64      	ldr	r3, [pc, #400]	; (1230 <malloc_getpagesize_P+0x230>)
    109e:	799b      	ldrb	r3, [r3, #6]
    10a0:	b2db      	uxtb	r3, r3
    10a2:	f003 0301 	and.w	r3, r3, #1
    10a6:	2b00      	cmp	r3, #0
    10a8:	d0f8      	beq.n	109c <malloc_getpagesize_P+0x9c>
    10aa:	e025      	b.n	10f8 <malloc_getpagesize_P+0xf8>
        }
      } else {
        MCG_C2 &= (uint8_t)(~(MCG_C2_IRCS_MASK)); /* Disable the fast internal clock */
    10ac:	4b60      	ldr	r3, [pc, #384]	; (1230 <malloc_getpagesize_P+0x230>)
    10ae:	4a60      	ldr	r2, [pc, #384]	; (1230 <malloc_getpagesize_P+0x230>)
    10b0:	7852      	ldrb	r2, [r2, #1]
    10b2:	b2d2      	uxtb	r2, r2
    10b4:	f022 0201 	bic.w	r2, r2, #1
    10b8:	b2d2      	uxtb	r2, r2
    10ba:	705a      	strb	r2, [r3, #1]
        MCG_SC = (MCG_SC & (uint8_t)(~(MCG_SC_FCRDIV_MASK))) | CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value;    
    10bc:	495c      	ldr	r1, [pc, #368]	; (1230 <malloc_getpagesize_P+0x230>)
    10be:	4b5c      	ldr	r3, [pc, #368]	; (1230 <malloc_getpagesize_P+0x230>)
    10c0:	7a1b      	ldrb	r3, [r3, #8]
    10c2:	b2db      	uxtb	r3, r3
    10c4:	b2db      	uxtb	r3, r3
    10c6:	f023 030e 	bic.w	r3, r3, #14
    10ca:	b2d8      	uxtb	r0, r3
    10cc:	79fa      	ldrb	r2, [r7, #7]
    10ce:	4c55      	ldr	r4, [pc, #340]	; (1224 <malloc_getpagesize_P+0x224>)
    10d0:	4613      	mov	r3, r2
    10d2:	00db      	lsls	r3, r3, #3
    10d4:	1a9b      	subs	r3, r3, r2
    10d6:	009b      	lsls	r3, r3, #2
    10d8:	4423      	add	r3, r4
    10da:	7a5b      	ldrb	r3, [r3, #9]
    10dc:	b2db      	uxtb	r3, r3
    10de:	4602      	mov	r2, r0
    10e0:	4313      	orrs	r3, r2
    10e2:	b2db      	uxtb	r3, r3
    10e4:	b2db      	uxtb	r3, r3
    10e6:	720b      	strb	r3, [r1, #8]
        MCG_C2 |= MCG_C2_IRCS_MASK;    /* Re-enable the fast internal clock */
    10e8:	4b51      	ldr	r3, [pc, #324]	; (1230 <malloc_getpagesize_P+0x230>)
    10ea:	4a51      	ldr	r2, [pc, #324]	; (1230 <malloc_getpagesize_P+0x230>)
    10ec:	7852      	ldrb	r2, [r2, #1]
    10ee:	b2d2      	uxtb	r2, r2
    10f0:	f042 0201 	orr.w	r2, r2, #1
    10f4:	b2d2      	uxtb	r2, r2
    10f6:	705a      	strb	r2, [r3, #1]
      }
    }
  }      
  NextMode = CPU_GetClockGenMode(); /* Identify the currently active MCG mode */
    10f8:	f7ff fef0 	bl	edc <CPU_GetClockGenMode>
    10fc:	4603      	mov	r3, r0
    10fe:	82fb      	strh	r3, [r7, #22]
  TargetMCGMode = TargetMode & CPU_MCG_MODE_INDEX_MASK;
    1100:	8abb      	ldrh	r3, [r7, #20]
    1102:	f003 030f 	and.w	r3, r3, #15
    1106:	827b      	strh	r3, [r7, #18]
  do {
    NextMode = ClockGenModeMatrix[NextMode & CPU_MCG_MODE_INDEX_MASK][TargetMode & CPU_MCG_MODE_INDEX_MASK];
    1108:	8afb      	ldrh	r3, [r7, #22]
    110a:	f003 010f 	and.w	r1, r3, #15
    110e:	8abb      	ldrh	r3, [r7, #20]
    1110:	f003 020f 	and.w	r2, r3, #15
    1114:	4b47      	ldr	r3, [pc, #284]	; (1234 <malloc_getpagesize_P+0x234>)
    1116:	00c9      	lsls	r1, r1, #3
    1118:	440a      	add	r2, r1
    111a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    111e:	82fb      	strh	r3, [r7, #22]
    if (((NextMode == CPU_MCG_MODE_PBE) && (TargetMCGMode == CPU_MCG_MODE_PEE)) || ((NextMode == CPU_MCG_MODE_FBE) && (TargetMCGMode == CPU_MCG_MODE_FEE)) || (NextMode == TargetMCGMode)) {
    1120:	8afb      	ldrh	r3, [r7, #22]
    1122:	2b06      	cmp	r3, #6
    1124:	d102      	bne.n	112c <malloc_getpagesize_P+0x12c>
    1126:	8a7b      	ldrh	r3, [r7, #18]
    1128:	2b07      	cmp	r3, #7
    112a:	d009      	beq.n	1140 <malloc_getpagesize_P+0x140>
    112c:	8afb      	ldrh	r3, [r7, #22]
    112e:	2b04      	cmp	r3, #4
    1130:	d102      	bne.n	1138 <malloc_getpagesize_P+0x138>
    1132:	8a7b      	ldrh	r3, [r7, #18]
    1134:	2b03      	cmp	r3, #3
    1136:	d003      	beq.n	1140 <malloc_getpagesize_P+0x140>
    1138:	8afa      	ldrh	r2, [r7, #22]
    113a:	8a7b      	ldrh	r3, [r7, #18]
    113c:	429a      	cmp	r2, r3
    113e:	d10d      	bne.n	115c <malloc_getpagesize_P+0x15c>
      NextModeRegs = CPU_ClockConfigDescriptors[ConfigID].GenRegs;
    1140:	79fa      	ldrb	r2, [r7, #7]
    1142:	4938      	ldr	r1, [pc, #224]	; (1224 <malloc_getpagesize_P+0x224>)
    1144:	4613      	mov	r3, r2
    1146:	00db      	lsls	r3, r3, #3
    1148:	1a9b      	subs	r3, r3, r2
    114a:	009b      	lsls	r3, r3, #2
    114c:	18ca      	adds	r2, r1, r3
    114e:	f107 0308 	add.w	r3, r7, #8
    1152:	3203      	adds	r2, #3
    1154:	6810      	ldr	r0, [r2, #0]
    1156:	6851      	ldr	r1, [r2, #4]
    1158:	c303      	stmia	r3!, {r0, r1}
    115a:	e00a      	b.n	1172 <malloc_getpagesize_P+0x172>
    } else {
      NextModeRegs = *CPU_ClockGenModeRegs[NextMode & CPU_MCG_MODE_INDEX_MASK];
    115c:	8afb      	ldrh	r3, [r7, #22]
    115e:	f003 020f 	and.w	r2, r3, #15
    1162:	4b35      	ldr	r3, [pc, #212]	; (1238 <malloc_getpagesize_P+0x238>)
    1164:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    1168:	f107 0308 	add.w	r3, r7, #8
    116c:	6810      	ldr	r0, [r2, #0]
    116e:	6851      	ldr	r1, [r2, #4]
    1170:	c303      	stmia	r3!, {r0, r1}
    }
    switch (NextMode) {
    1172:	8afb      	ldrh	r3, [r7, #22]
    1174:	2b07      	cmp	r3, #7
    1176:	f200 8154 	bhi.w	1422 <malloc_getpagesize_P+0x422>
    117a:	a201      	add	r2, pc, #4	; (adr r2, 1180 <malloc_getpagesize_P+0x180>)
    117c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1180:	000011a1 	.word	0x000011a1
    1184:	000011a1 	.word	0x000011a1
    1188:	00001241 	.word	0x00001241
    118c:	00001295 	.word	0x00001295
    1190:	00001295 	.word	0x00001295
    1194:	00001345 	.word	0x00001345
    1198:	0000138f 	.word	0x0000138f
    119c:	0000138f 	.word	0x0000138f
      case CPU_MCG_MODE_FEI:
      case CPU_MCG_MODE_FBI:
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    11a0:	4b23      	ldr	r3, [pc, #140]	; (1230 <malloc_getpagesize_P+0x230>)
    11a2:	7a3a      	ldrb	r2, [r7, #8]
    11a4:	701a      	strb	r2, [r3, #0]
        while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
    11a6:	bf00      	nop
    11a8:	4b21      	ldr	r3, [pc, #132]	; (1230 <malloc_getpagesize_P+0x230>)
    11aa:	799b      	ldrb	r3, [r3, #6]
    11ac:	b2db      	uxtb	r3, r3
    11ae:	f003 0310 	and.w	r3, r3, #16
    11b2:	2b00      	cmp	r3, #0
    11b4:	d0f8      	beq.n	11a8 <malloc_getpagesize_P+0x1a8>
        }
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
    11b6:	4b1e      	ldr	r3, [pc, #120]	; (1230 <malloc_getpagesize_P+0x230>)
    11b8:	7a7a      	ldrb	r2, [r7, #9]
    11ba:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    11be:	b2d1      	uxtb	r1, r2
    11c0:	4a1b      	ldr	r2, [pc, #108]	; (1230 <malloc_getpagesize_P+0x230>)
    11c2:	7852      	ldrb	r2, [r2, #1]
    11c4:	b2d2      	uxtb	r2, r2
    11c6:	f002 0240 	and.w	r2, r2, #64	; 0x40
    11ca:	b2d2      	uxtb	r2, r2
    11cc:	430a      	orrs	r2, r1
    11ce:	b2d2      	uxtb	r2, r2
    11d0:	705a      	strb	r2, [r3, #1]
        MCG_C4 = ((NextModeRegs.MCG_C4_value) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG_C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
    11d2:	4b17      	ldr	r3, [pc, #92]	; (1230 <malloc_getpagesize_P+0x230>)
    11d4:	7aba      	ldrb	r2, [r7, #10]
    11d6:	f022 021f 	bic.w	r2, r2, #31
    11da:	b2d1      	uxtb	r1, r2
    11dc:	4a14      	ldr	r2, [pc, #80]	; (1230 <malloc_getpagesize_P+0x230>)
    11de:	78d2      	ldrb	r2, [r2, #3]
    11e0:	b2d2      	uxtb	r2, r2
    11e2:	f002 021f 	and.w	r2, r2, #31
    11e6:	b2d2      	uxtb	r2, r2
    11e8:	430a      	orrs	r2, r1
    11ea:	b2d2      	uxtb	r2, r2
    11ec:	70da      	strb	r2, [r3, #3]
        MCG_C7 = NextModeRegs.MCG_C7_value; /* Select MCG OSC clock source */
    11ee:	4b10      	ldr	r3, [pc, #64]	; (1230 <malloc_getpagesize_P+0x230>)
    11f0:	7b7a      	ldrb	r2, [r7, #13]
    11f2:	731a      	strb	r2, [r3, #12]
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    11f4:	4b11      	ldr	r3, [pc, #68]	; (123c <malloc_getpagesize_P+0x23c>)
    11f6:	7bfa      	ldrb	r2, [r7, #15]
    11f8:	701a      	strb	r2, [r3, #0]
        MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
    11fa:	4b0d      	ldr	r3, [pc, #52]	; (1230 <malloc_getpagesize_P+0x230>)
    11fc:	7afa      	ldrb	r2, [r7, #11]
    11fe:	711a      	strb	r2, [r3, #4]
        MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
    1200:	4b0b      	ldr	r3, [pc, #44]	; (1230 <malloc_getpagesize_P+0x230>)
    1202:	7b3a      	ldrb	r2, [r7, #12]
    1204:	715a      	strb	r2, [r3, #5]
        if (TargetMode & CPU_CLOCK_PLL_MASK) {
    1206:	8abb      	ldrh	r3, [r7, #20]
    1208:	f403 7300 	and.w	r3, r3, #512	; 0x200
    120c:	2b00      	cmp	r3, #0
    120e:	d008      	beq.n	1222 <malloc_getpagesize_P+0x222>
          MCG_C5 |= MCG_C5_PLLCLKEN0_MASK;
    1210:	4b07      	ldr	r3, [pc, #28]	; (1230 <malloc_getpagesize_P+0x230>)
    1212:	4a07      	ldr	r2, [pc, #28]	; (1230 <malloc_getpagesize_P+0x230>)
    1214:	7912      	ldrb	r2, [r2, #4]
    1216:	b2d2      	uxtb	r2, r2
    1218:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    121c:	b2d2      	uxtb	r2, r2
    121e:	711a      	strb	r2, [r3, #4]
        }
        break;
    1220:	e100      	b.n	1424 <malloc_getpagesize_P+0x424>
    1222:	e0ff      	b.n	1424 <malloc_getpagesize_P+0x424>
    1224:	000072e8 	.word	0x000072e8
    1228:	40047000 	.word	0x40047000
    122c:	40049000 	.word	0x40049000
    1230:	40064000 	.word	0x40064000
    1234:	00007268 	.word	0x00007268
    1238:	000073b4 	.word	0x000073b4
    123c:	40065000 	.word	0x40065000
      case CPU_MCG_MODE_BLPI:
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    1240:	4b9a      	ldr	r3, [pc, #616]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1242:	7a3a      	ldrb	r2, [r7, #8]
    1244:	701a      	strb	r2, [r3, #0]
        while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
    1246:	bf00      	nop
    1248:	4b98      	ldr	r3, [pc, #608]	; (14ac <malloc_getpagesize_P+0x4ac>)
    124a:	799b      	ldrb	r3, [r3, #6]
    124c:	b2db      	uxtb	r3, r3
    124e:	f003 0310 	and.w	r3, r3, #16
    1252:	2b00      	cmp	r3, #0
    1254:	d0f8      	beq.n	1248 <malloc_getpagesize_P+0x248>
        }
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
    1256:	4b95      	ldr	r3, [pc, #596]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1258:	7a7a      	ldrb	r2, [r7, #9]
    125a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    125e:	b2d1      	uxtb	r1, r2
    1260:	4a92      	ldr	r2, [pc, #584]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1262:	7852      	ldrb	r2, [r2, #1]
    1264:	b2d2      	uxtb	r2, r2
    1266:	f002 0240 	and.w	r2, r2, #64	; 0x40
    126a:	b2d2      	uxtb	r2, r2
    126c:	430a      	orrs	r2, r1
    126e:	b2d2      	uxtb	r2, r2
    1270:	705a      	strb	r2, [r3, #1]
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    1272:	4b8f      	ldr	r3, [pc, #572]	; (14b0 <malloc_getpagesize_P+0x4b0>)
    1274:	7bfa      	ldrb	r2, [r7, #15]
    1276:	701a      	strb	r2, [r3, #0]
        if (TargetMode & CPU_CLOCK_FAST_MASK) {
    1278:	8abb      	ldrh	r3, [r7, #20]
    127a:	f003 0320 	and.w	r3, r3, #32
    127e:	2b00      	cmp	r3, #0
    1280:	d007      	beq.n	1292 <malloc_getpagesize_P+0x292>
          while((MCG_S & MCG_S_IRCST_MASK) == 0x00U) { /* Check that the fast external reference clock is selected. */
    1282:	bf00      	nop
    1284:	4b89      	ldr	r3, [pc, #548]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1286:	799b      	ldrb	r3, [r3, #6]
    1288:	b2db      	uxtb	r3, r3
    128a:	f003 0301 	and.w	r3, r3, #1
    128e:	2b00      	cmp	r3, #0
    1290:	d0f8      	beq.n	1284 <malloc_getpagesize_P+0x284>
      	  }
      	}      	
        break;
    1292:	e0c7      	b.n	1424 <malloc_getpagesize_P+0x424>
      case CPU_MCG_MODE_FEE:
      case CPU_MCG_MODE_FBE:
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
    1294:	4b85      	ldr	r3, [pc, #532]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1296:	7a7a      	ldrb	r2, [r7, #9]
    1298:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    129c:	b2d1      	uxtb	r1, r2
    129e:	4a83      	ldr	r2, [pc, #524]	; (14ac <malloc_getpagesize_P+0x4ac>)
    12a0:	7852      	ldrb	r2, [r2, #1]
    12a2:	b2d2      	uxtb	r2, r2
    12a4:	f002 0240 	and.w	r2, r2, #64	; 0x40
    12a8:	b2d2      	uxtb	r2, r2
    12aa:	430a      	orrs	r2, r1
    12ac:	b2d2      	uxtb	r2, r2
    12ae:	705a      	strb	r2, [r3, #1]
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */      	
    12b0:	4b7f      	ldr	r3, [pc, #508]	; (14b0 <malloc_getpagesize_P+0x4b0>)
    12b2:	7bfa      	ldrb	r2, [r7, #15]
    12b4:	701a      	strb	r2, [r3, #0]
        MCG_C7 = NextModeRegs.MCG_C7_value; /* Select MCG OSC clock source */
    12b6:	4b7d      	ldr	r3, [pc, #500]	; (14ac <malloc_getpagesize_P+0x4ac>)
    12b8:	7b7a      	ldrb	r2, [r7, #13]
    12ba:	731a      	strb	r2, [r3, #12]
        if (NextMode == CPU_MCG_MODE_FBE) {
    12bc:	8afb      	ldrh	r3, [r7, #22]
    12be:	2b04      	cmp	r3, #4
    12c0:	d106      	bne.n	12d0 <malloc_getpagesize_P+0x2d0>
          MCG_C1 = NextModeRegs.MCG_C1_value | MCG_C1_CLKS(0x02); /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    12c2:	4b7a      	ldr	r3, [pc, #488]	; (14ac <malloc_getpagesize_P+0x4ac>)
    12c4:	7a3a      	ldrb	r2, [r7, #8]
    12c6:	f062 027f 	orn	r2, r2, #127	; 0x7f
    12ca:	b2d2      	uxtb	r2, r2
    12cc:	701a      	strb	r2, [r3, #0]
    12ce:	e002      	b.n	12d6 <malloc_getpagesize_P+0x2d6>
        } else {
          MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    12d0:	4b76      	ldr	r3, [pc, #472]	; (14ac <malloc_getpagesize_P+0x4ac>)
    12d2:	7a3a      	ldrb	r2, [r7, #8]
    12d4:	701a      	strb	r2, [r3, #0]
        }
        if ((TargetMode & CPU_CLOCK_EXTERNAL_CRYSTAL_MASK) != 0) {
    12d6:	8abb      	ldrh	r3, [r7, #20]
    12d8:	f003 0380 	and.w	r3, r3, #128	; 0x80
    12dc:	2b00      	cmp	r3, #0
    12de:	d007      	beq.n	12f0 <malloc_getpagesize_P+0x2f0>
          while((MCG_S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
    12e0:	bf00      	nop
    12e2:	4b72      	ldr	r3, [pc, #456]	; (14ac <malloc_getpagesize_P+0x4ac>)
    12e4:	799b      	ldrb	r3, [r3, #6]
    12e6:	b2db      	uxtb	r3, r3
    12e8:	f003 0302 	and.w	r3, r3, #2
    12ec:	2b00      	cmp	r3, #0
    12ee:	d0f8      	beq.n	12e2 <malloc_getpagesize_P+0x2e2>
          }
        }
        while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
    12f0:	bf00      	nop
    12f2:	4b6e      	ldr	r3, [pc, #440]	; (14ac <malloc_getpagesize_P+0x4ac>)
    12f4:	799b      	ldrb	r3, [r3, #6]
    12f6:	b2db      	uxtb	r3, r3
    12f8:	f003 0310 	and.w	r3, r3, #16
    12fc:	2b00      	cmp	r3, #0
    12fe:	d1f8      	bne.n	12f2 <malloc_getpagesize_P+0x2f2>
        }
        MCG_C4 = ((NextModeRegs.MCG_C4_value) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG_C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
    1300:	4b6a      	ldr	r3, [pc, #424]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1302:	7aba      	ldrb	r2, [r7, #10]
    1304:	f022 021f 	bic.w	r2, r2, #31
    1308:	b2d1      	uxtb	r1, r2
    130a:	4a68      	ldr	r2, [pc, #416]	; (14ac <malloc_getpagesize_P+0x4ac>)
    130c:	78d2      	ldrb	r2, [r2, #3]
    130e:	b2d2      	uxtb	r2, r2
    1310:	f002 021f 	and.w	r2, r2, #31
    1314:	b2d2      	uxtb	r2, r2
    1316:	430a      	orrs	r2, r1
    1318:	b2d2      	uxtb	r2, r2
    131a:	70da      	strb	r2, [r3, #3]
        MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
    131c:	4b63      	ldr	r3, [pc, #396]	; (14ac <malloc_getpagesize_P+0x4ac>)
    131e:	7afa      	ldrb	r2, [r7, #11]
    1320:	711a      	strb	r2, [r3, #4]
        if (TargetMode & CPU_CLOCK_PLL_MASK) {
    1322:	8abb      	ldrh	r3, [r7, #20]
    1324:	f403 7300 	and.w	r3, r3, #512	; 0x200
    1328:	2b00      	cmp	r3, #0
    132a:	d007      	beq.n	133c <malloc_getpagesize_P+0x33c>
          MCG_C5 |= MCG_C5_PLLCLKEN0_MASK;
    132c:	4b5f      	ldr	r3, [pc, #380]	; (14ac <malloc_getpagesize_P+0x4ac>)
    132e:	4a5f      	ldr	r2, [pc, #380]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1330:	7912      	ldrb	r2, [r2, #4]
    1332:	b2d2      	uxtb	r2, r2
    1334:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    1338:	b2d2      	uxtb	r2, r2
    133a:	711a      	strb	r2, [r3, #4]
        }
        MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
    133c:	4b5b      	ldr	r3, [pc, #364]	; (14ac <malloc_getpagesize_P+0x4ac>)
    133e:	7b3a      	ldrb	r2, [r7, #12]
    1340:	715a      	strb	r2, [r3, #5]
        break;
    1342:	e06f      	b.n	1424 <malloc_getpagesize_P+0x424>
      case CPU_MCG_MODE_BLPE:
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    1344:	4b59      	ldr	r3, [pc, #356]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1346:	7a3a      	ldrb	r2, [r7, #8]
    1348:	701a      	strb	r2, [r3, #0]
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
    134a:	4b58      	ldr	r3, [pc, #352]	; (14ac <malloc_getpagesize_P+0x4ac>)
    134c:	7a7a      	ldrb	r2, [r7, #9]
    134e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    1352:	b2d1      	uxtb	r1, r2
    1354:	4a55      	ldr	r2, [pc, #340]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1356:	7852      	ldrb	r2, [r2, #1]
    1358:	b2d2      	uxtb	r2, r2
    135a:	f002 0240 	and.w	r2, r2, #64	; 0x40
    135e:	b2d2      	uxtb	r2, r2
    1360:	430a      	orrs	r2, r1
    1362:	b2d2      	uxtb	r2, r2
    1364:	705a      	strb	r2, [r3, #1]
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */      	
    1366:	4b52      	ldr	r3, [pc, #328]	; (14b0 <malloc_getpagesize_P+0x4b0>)
    1368:	7bfa      	ldrb	r2, [r7, #15]
    136a:	701a      	strb	r2, [r3, #0]
        MCG_C7 = NextModeRegs.MCG_C7_value; /* Select MCG OSC clock source */
    136c:	4b4f      	ldr	r3, [pc, #316]	; (14ac <malloc_getpagesize_P+0x4ac>)
    136e:	7b7a      	ldrb	r2, [r7, #13]
    1370:	731a      	strb	r2, [r3, #12]
        if ((TargetMode & CPU_CLOCK_EXTERNAL_CRYSTAL_MASK) != 0) {
    1372:	8abb      	ldrh	r3, [r7, #20]
    1374:	f003 0380 	and.w	r3, r3, #128	; 0x80
    1378:	2b00      	cmp	r3, #0
    137a:	d007      	beq.n	138c <malloc_getpagesize_P+0x38c>
          while((MCG_S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
    137c:	bf00      	nop
    137e:	4b4b      	ldr	r3, [pc, #300]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1380:	799b      	ldrb	r3, [r3, #6]
    1382:	b2db      	uxtb	r3, r3
    1384:	f003 0302 	and.w	r3, r3, #2
    1388:	2b00      	cmp	r3, #0
    138a:	d0f8      	beq.n	137e <malloc_getpagesize_P+0x37e>
          }
        }
        break;
    138c:	e04a      	b.n	1424 <malloc_getpagesize_P+0x424>
      case CPU_MCG_MODE_PEE:
      case CPU_MCG_MODE_PBE:
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
    138e:	4b48      	ldr	r3, [pc, #288]	; (14b0 <malloc_getpagesize_P+0x4b0>)
    1390:	7bfa      	ldrb	r2, [r7, #15]
    1392:	701a      	strb	r2, [r3, #0]
        MCG_C7 = NextModeRegs.MCG_C7_value; /* Select MCG OSC clock source */
    1394:	4b45      	ldr	r3, [pc, #276]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1396:	7b7a      	ldrb	r2, [r7, #13]
    1398:	731a      	strb	r2, [r3, #12]
        if (NextMode == CPU_MCG_MODE_PBE) {
    139a:	8afb      	ldrh	r3, [r7, #22]
    139c:	2b06      	cmp	r3, #6
    139e:	d106      	bne.n	13ae <malloc_getpagesize_P+0x3ae>
          MCG_C1 = NextModeRegs.MCG_C1_value | MCG_C1_CLKS(0x02); /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    13a0:	4b42      	ldr	r3, [pc, #264]	; (14ac <malloc_getpagesize_P+0x4ac>)
    13a2:	7a3a      	ldrb	r2, [r7, #8]
    13a4:	f062 027f 	orn	r2, r2, #127	; 0x7f
    13a8:	b2d2      	uxtb	r2, r2
    13aa:	701a      	strb	r2, [r3, #0]
    13ac:	e002      	b.n	13b4 <malloc_getpagesize_P+0x3b4>
        } else {
          MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
    13ae:	4b3f      	ldr	r3, [pc, #252]	; (14ac <malloc_getpagesize_P+0x4ac>)
    13b0:	7a3a      	ldrb	r2, [r7, #8]
    13b2:	701a      	strb	r2, [r3, #0]
        }
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
    13b4:	4b3d      	ldr	r3, [pc, #244]	; (14ac <malloc_getpagesize_P+0x4ac>)
    13b6:	7a7a      	ldrb	r2, [r7, #9]
    13b8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    13bc:	b2d1      	uxtb	r1, r2
    13be:	4a3b      	ldr	r2, [pc, #236]	; (14ac <malloc_getpagesize_P+0x4ac>)
    13c0:	7852      	ldrb	r2, [r2, #1]
    13c2:	b2d2      	uxtb	r2, r2
    13c4:	f002 0240 	and.w	r2, r2, #64	; 0x40
    13c8:	b2d2      	uxtb	r2, r2
    13ca:	430a      	orrs	r2, r1
    13cc:	b2d2      	uxtb	r2, r2
    13ce:	705a      	strb	r2, [r3, #1]
        if ((TargetMode & CPU_MCG_MODE_INDEX_MASK) == CPU_MCG_MODE_PEE) {
    13d0:	8abb      	ldrh	r3, [r7, #20]
    13d2:	f003 030f 	and.w	r3, r3, #15
    13d6:	2b07      	cmp	r3, #7
    13d8:	d114      	bne.n	1404 <malloc_getpagesize_P+0x404>
          MCG_C5 = CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
    13da:	4934      	ldr	r1, [pc, #208]	; (14ac <malloc_getpagesize_P+0x4ac>)
    13dc:	79fa      	ldrb	r2, [r7, #7]
    13de:	4835      	ldr	r0, [pc, #212]	; (14b4 <malloc_getpagesize_P+0x4b4>)
    13e0:	4613      	mov	r3, r2
    13e2:	00db      	lsls	r3, r3, #3
    13e4:	1a9b      	subs	r3, r3, r2
    13e6:	009b      	lsls	r3, r3, #2
    13e8:	4403      	add	r3, r0
    13ea:	799b      	ldrb	r3, [r3, #6]
    13ec:	710b      	strb	r3, [r1, #4]
          MCG_C6 = CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
    13ee:	492f      	ldr	r1, [pc, #188]	; (14ac <malloc_getpagesize_P+0x4ac>)
    13f0:	79fa      	ldrb	r2, [r7, #7]
    13f2:	4830      	ldr	r0, [pc, #192]	; (14b4 <malloc_getpagesize_P+0x4b4>)
    13f4:	4613      	mov	r3, r2
    13f6:	00db      	lsls	r3, r3, #3
    13f8:	1a9b      	subs	r3, r3, r2
    13fa:	009b      	lsls	r3, r3, #2
    13fc:	4403      	add	r3, r0
    13fe:	79db      	ldrb	r3, [r3, #7]
    1400:	714b      	strb	r3, [r1, #5]
        } else {
          MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
          MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
        }
        while((MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
    1402:	e005      	b.n	1410 <malloc_getpagesize_P+0x410>
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
        if ((TargetMode & CPU_MCG_MODE_INDEX_MASK) == CPU_MCG_MODE_PEE) {
          MCG_C5 = CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
          MCG_C6 = CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
        } else {
          MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
    1404:	4b29      	ldr	r3, [pc, #164]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1406:	7afa      	ldrb	r2, [r7, #11]
    1408:	711a      	strb	r2, [r3, #4]
          MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
    140a:	4b28      	ldr	r3, [pc, #160]	; (14ac <malloc_getpagesize_P+0x4ac>)
    140c:	7b3a      	ldrb	r2, [r7, #12]
    140e:	715a      	strb	r2, [r3, #5]
        }
        while((MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
    1410:	bf00      	nop
    1412:	4b26      	ldr	r3, [pc, #152]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1414:	799b      	ldrb	r3, [r3, #6]
    1416:	b2db      	uxtb	r3, r3
    1418:	f003 0340 	and.w	r3, r3, #64	; 0x40
    141c:	2b00      	cmp	r3, #0
    141e:	d0f8      	beq.n	1412 <malloc_getpagesize_P+0x412>
        }
        break;
    1420:	e000      	b.n	1424 <malloc_getpagesize_P+0x424>
      default:
        break;            
    1422:	bf00      	nop
    }
    switch (NextMode) {
    1424:	8afb      	ldrh	r3, [r7, #22]
    1426:	2b07      	cmp	r3, #7
    1428:	d836      	bhi.n	1498 <malloc_getpagesize_P+0x498>
    142a:	a201      	add	r2, pc, #4	; (adr r2, 1430 <malloc_getpagesize_P+0x430>)
    142c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1430:	00001451 	.word	0x00001451
    1434:	00001463 	.word	0x00001463
    1438:	00001463 	.word	0x00001463
    143c:	00001451 	.word	0x00001451
    1440:	00001475 	.word	0x00001475
    1444:	00001475 	.word	0x00001475
    1448:	00001475 	.word	0x00001475
    144c:	00001487 	.word	0x00001487
      case CPU_MCG_MODE_FEI:
      case CPU_MCG_MODE_FEE:
        while((MCG_S & 0x0CU) != 0x00U) { /* Wait until output of the FLL is selected */
    1450:	bf00      	nop
    1452:	4b16      	ldr	r3, [pc, #88]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1454:	799b      	ldrb	r3, [r3, #6]
    1456:	b2db      	uxtb	r3, r3
    1458:	f003 030c 	and.w	r3, r3, #12
    145c:	2b00      	cmp	r3, #0
    145e:	d1f8      	bne.n	1452 <malloc_getpagesize_P+0x452>
        }
        break;
    1460:	e01a      	b.n	1498 <malloc_getpagesize_P+0x498>
      case CPU_MCG_MODE_FBI:
      case CPU_MCG_MODE_BLPI:
        while((MCG_S & 0x0CU) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
    1462:	bf00      	nop
    1464:	4b11      	ldr	r3, [pc, #68]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1466:	799b      	ldrb	r3, [r3, #6]
    1468:	b2db      	uxtb	r3, r3
    146a:	f003 030c 	and.w	r3, r3, #12
    146e:	2b04      	cmp	r3, #4
    1470:	d1f8      	bne.n	1464 <malloc_getpagesize_P+0x464>
        }
        break;
    1472:	e011      	b.n	1498 <malloc_getpagesize_P+0x498>
      case CPU_MCG_MODE_FBE:
      case CPU_MCG_MODE_BLPE:
      case CPU_MCG_MODE_PBE:
        while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
    1474:	bf00      	nop
    1476:	4b0d      	ldr	r3, [pc, #52]	; (14ac <malloc_getpagesize_P+0x4ac>)
    1478:	799b      	ldrb	r3, [r3, #6]
    147a:	b2db      	uxtb	r3, r3
    147c:	f003 030c 	and.w	r3, r3, #12
    1480:	2b08      	cmp	r3, #8
    1482:	d1f8      	bne.n	1476 <malloc_getpagesize_P+0x476>
        }
        break;
    1484:	e008      	b.n	1498 <malloc_getpagesize_P+0x498>
      case CPU_MCG_MODE_PEE:
        while((MCG_S & 0x0CU) != 0x0CU) { /* Wait until output of the PLL is selected */
    1486:	bf00      	nop
    1488:	4b08      	ldr	r3, [pc, #32]	; (14ac <malloc_getpagesize_P+0x4ac>)
    148a:	799b      	ldrb	r3, [r3, #6]
    148c:	b2db      	uxtb	r3, r3
    148e:	f003 030c 	and.w	r3, r3, #12
    1492:	2b0c      	cmp	r3, #12
    1494:	d1f8      	bne.n	1488 <malloc_getpagesize_P+0x488>
        }
        break;
    1496:	bf00      	nop
    }
  } while (NextMode != (TargetMode & CPU_MCG_MODE_INDEX_MASK)); /* Loop until the target MCG mode is set */
    1498:	8afa      	ldrh	r2, [r7, #22]
    149a:	8abb      	ldrh	r3, [r7, #20]
    149c:	f003 030f 	and.w	r3, r3, #15
    14a0:	429a      	cmp	r2, r3
    14a2:	f47f ae31 	bne.w	1108 <malloc_getpagesize_P+0x108>
}
    14a6:	371c      	adds	r7, #28
    14a8:	46bd      	mov	sp, r7
    14aa:	bd90      	pop	{r4, r7, pc}
    14ac:	40064000 	.word	0x40064000
    14b0:	40065000 	.word	0x40065000
    14b4:	000072e8 	.word	0x000072e8

000014b8 <CPU_SetClockConfiguration>:
**                           ERR_RANGE - Mode parameter out of range
*/
/* ===================================================================*/
#if CPU_SET_CLOCK_CONFIGURATION
LDD_TError CPU_SetClockConfiguration(LDD_TClockConfiguration ModeID)
{
    14b8:	b590      	push	{r4, r7, lr}
    14ba:	b083      	sub	sp, #12
    14bc:	af00      	add	r7, sp, #0
    14be:	4603      	mov	r3, r0
    14c0:	71fb      	strb	r3, [r7, #7]
  if (ModeID > (CPU_CLOCK_CONFIG_NUMBER - 1U)) {
    14c2:	79fb      	ldrb	r3, [r7, #7]
    14c4:	2b04      	cmp	r3, #4
    14c6:	d901      	bls.n	14cc <CPU_SetClockConfiguration+0x14>
    return ERR_RANGE;
    14c8:	2302      	movs	r3, #2
    14ca:	e0ad      	b.n	1628 <CPU_SetClockConfiguration+0x170>
  }
  
  if (SMC_PMSTAT == 0x04U) {           /* Test if in VLPR mode */
    14cc:	4b58      	ldr	r3, [pc, #352]	; (1630 <CPU_SetClockConfiguration+0x178>)
    14ce:	78db      	ldrb	r3, [r3, #3]
    14d0:	b2db      	uxtb	r3, r3
    14d2:	2b04      	cmp	r3, #4
    14d4:	d110      	bne.n	14f8 <CPU_SetClockConfiguration+0x40>
    /* SMC_PMCTRL: LPWUI=0,RUNM=0,??=0,STOPA=0,STOPM=0 */
    SMC_PMCTRL = (SMC_PMCTRL_RUNM(0x00) | SMC_PMCTRL_STOPM(0x00)); /* Disable very low power mode */
    14d6:	4b56      	ldr	r3, [pc, #344]	; (1630 <CPU_SetClockConfiguration+0x178>)
    14d8:	2200      	movs	r2, #0
    14da:	705a      	strb	r2, [r3, #1]
    while((PMC_REGSC & PMC_REGSC_REGONS_MASK) == 0x00U) { /* Wait until the regulator is in run regulation */
    14dc:	bf00      	nop
    14de:	4b55      	ldr	r3, [pc, #340]	; (1634 <CPU_SetClockConfiguration+0x17c>)
    14e0:	789b      	ldrb	r3, [r3, #2]
    14e2:	b2db      	uxtb	r3, r3
    14e4:	f003 0304 	and.w	r3, r3, #4
    14e8:	2b00      	cmp	r3, #0
    14ea:	d0f8      	beq.n	14de <CPU_SetClockConfiguration+0x26>
    }
    while(SMC_PMSTAT == 0x04U) {       /* Wait until the system is back in RUN mode */
    14ec:	bf00      	nop
    14ee:	4b50      	ldr	r3, [pc, #320]	; (1630 <CPU_SetClockConfiguration+0x178>)
    14f0:	78db      	ldrb	r3, [r3, #3]
    14f2:	b2db      	uxtb	r3, r3
    14f4:	2b04      	cmp	r3, #4
    14f6:	d0fa      	beq.n	14ee <CPU_SetClockConfiguration+0x36>
    }
  }
  /* SIM_CLKDIV1: OUTDIV1=0,OUTDIV2=1,OUTDIV3=4,OUTDIV4=4,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0x00) |
    14f8:	4b4f      	ldr	r3, [pc, #316]	; (1638 <CPU_SetClockConfiguration+0x180>)
    14fa:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    14fe:	3304      	adds	r3, #4
    1500:	f04f 72a2 	mov.w	r2, #21233664	; 0x1440000
    1504:	601a      	str	r2, [r3, #0]
                SIM_CLKDIV1_OUTDIV2(0x01) |
                SIM_CLKDIV1_OUTDIV3(0x04) |
                SIM_CLKDIV1_OUTDIV4(0x04); /* Set the system prescalers to safe value */
  switch (ModeID) {
    1506:	79fb      	ldrb	r3, [r7, #7]
    1508:	2b04      	cmp	r3, #4
    150a:	d821      	bhi.n	1550 <CPU_SetClockConfiguration+0x98>
    150c:	a201      	add	r2, pc, #4	; (adr r2, 1514 <CPU_SetClockConfiguration+0x5c>)
    150e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1512:	bf00      	nop
    1514:	00001529 	.word	0x00001529
    1518:	00001531 	.word	0x00001531
    151c:	00001539 	.word	0x00001539
    1520:	00001541 	.word	0x00001541
    1524:	00001549 	.word	0x00001549
  #if defined(CPU_CLOCK_CONFIG_0)
    case CPU_CLOCK_CONFIG_0:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_0);
    1528:	2000      	movs	r0, #0
    152a:	f7ff fd1f 	bl	f6c <CPU_SetClockConfigGenMode>
      break;
    152e:	e010      	b.n	1552 <CPU_SetClockConfiguration+0x9a>
  #endif /* defined(CPU_CLOCK_CONFIG_0) */
  #if defined(CPU_CLOCK_CONFIG_1)
    case CPU_CLOCK_CONFIG_1:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_1);
    1530:	2001      	movs	r0, #1
    1532:	f7ff fd1b 	bl	f6c <CPU_SetClockConfigGenMode>
      break;
    1536:	e00c      	b.n	1552 <CPU_SetClockConfiguration+0x9a>
  #endif /* defined(CPU_CLOCK_CONFIG_1) */
  #if defined(CPU_CLOCK_CONFIG_2)
    case CPU_CLOCK_CONFIG_2:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_2);
    1538:	2002      	movs	r0, #2
    153a:	f7ff fd17 	bl	f6c <CPU_SetClockConfigGenMode>
      break;
    153e:	e008      	b.n	1552 <CPU_SetClockConfiguration+0x9a>
  #endif /* defined(CPU_CLOCK_CONFIG_2) */
  #if defined(CPU_CLOCK_CONFIG_3)
    case CPU_CLOCK_CONFIG_3:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_3);
    1540:	2003      	movs	r0, #3
    1542:	f7ff fd13 	bl	f6c <CPU_SetClockConfigGenMode>
      break;
    1546:	e004      	b.n	1552 <CPU_SetClockConfiguration+0x9a>
  #endif /* defined(CPU_CLOCK_CONFIG_3) */
  #if defined(CPU_CLOCK_CONFIG_4)
    case CPU_CLOCK_CONFIG_4:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_4);
    1548:	2004      	movs	r0, #4
    154a:	f7ff fd0f 	bl	f6c <CPU_SetClockConfigGenMode>
      break;
    154e:	e000      	b.n	1552 <CPU_SetClockConfiguration+0x9a>
    case CPU_CLOCK_CONFIG_7:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_7);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_7) */
    default:
      break;
    1550:	bf00      	nop
  }
  SIM_CLKDIV1 = (uint32_t)CPU_ClockConfigDescriptors[ModeID].SysRegs.SIM_CLKDIV1_value; /* Update system prescalers */
    1552:	4939      	ldr	r1, [pc, #228]	; (1638 <CPU_SetClockConfiguration+0x180>)
    1554:	79fa      	ldrb	r2, [r7, #7]
    1556:	4839      	ldr	r0, [pc, #228]	; (163c <CPU_SetClockConfiguration+0x184>)
    1558:	4613      	mov	r3, r2
    155a:	00db      	lsls	r3, r3, #3
    155c:	1a9b      	subs	r3, r3, r2
    155e:	009b      	lsls	r3, r3, #2
    1560:	4403      	add	r3, r0
    1562:	3310      	adds	r3, #16
    1564:	685a      	ldr	r2, [r3, #4]
    1566:	f501 5382 	add.w	r3, r1, #4160	; 0x1040
    156a:	3304      	adds	r3, #4
    156c:	601a      	str	r2, [r3, #0]
  SIM_SOPT1 = (uint32_t)((SIM_SOPT1 & (uint32_t)~(uint32_t)SIM_SOPT1_OSC32KSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[ModeID].SysRegs.SIM_SOPT1_value); /* Update 32 kHz oscillator clock source (ERCLK32K) */
    156e:	4932      	ldr	r1, [pc, #200]	; (1638 <CPU_SetClockConfiguration+0x180>)
    1570:	4b31      	ldr	r3, [pc, #196]	; (1638 <CPU_SetClockConfiguration+0x180>)
    1572:	681b      	ldr	r3, [r3, #0]
    1574:	f423 2040 	bic.w	r0, r3, #786432	; 0xc0000
    1578:	79fa      	ldrb	r2, [r7, #7]
    157a:	4c30      	ldr	r4, [pc, #192]	; (163c <CPU_SetClockConfiguration+0x184>)
    157c:	4613      	mov	r3, r2
    157e:	00db      	lsls	r3, r3, #3
    1580:	1a9b      	subs	r3, r3, r2
    1582:	009b      	lsls	r3, r3, #2
    1584:	4423      	add	r3, r4
    1586:	3308      	adds	r3, #8
    1588:	685b      	ldr	r3, [r3, #4]
    158a:	4303      	orrs	r3, r0
    158c:	600b      	str	r3, [r1, #0]
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)SIM_SOPT2_PLLFLLSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[ModeID].SysRegs.SIM_SOPT2_value); /* Update PLL/FLL clock select */
    158e:	492a      	ldr	r1, [pc, #168]	; (1638 <CPU_SetClockConfiguration+0x180>)
    1590:	4b29      	ldr	r3, [pc, #164]	; (1638 <CPU_SetClockConfiguration+0x180>)
    1592:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1596:	3304      	adds	r3, #4
    1598:	681b      	ldr	r3, [r3, #0]
    159a:	f423 3040 	bic.w	r0, r3, #196608	; 0x30000
    159e:	79fa      	ldrb	r2, [r7, #7]
    15a0:	4c26      	ldr	r4, [pc, #152]	; (163c <CPU_SetClockConfiguration+0x184>)
    15a2:	4613      	mov	r3, r2
    15a4:	00db      	lsls	r3, r3, #3
    15a6:	1a9b      	subs	r3, r3, r2
    15a8:	009b      	lsls	r3, r3, #2
    15aa:	4423      	add	r3, r4
    15ac:	3308      	adds	r3, #8
    15ae:	689b      	ldr	r3, [r3, #8]
    15b0:	ea40 0203 	orr.w	r2, r0, r3
    15b4:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    15b8:	3304      	adds	r3, #4
    15ba:	601a      	str	r2, [r3, #0]
  LDD_SetClockConfiguration(ModeID);   /* Call all LDD components to update the clock configuration */
    15bc:	79fb      	ldrb	r3, [r7, #7]
    15be:	4618      	mov	r0, r3
    15c0:	f005 fba8 	bl	6d14 <LDD_SetClockConfiguration>
  ClockConfigurationID = ModeID;       /* Store clock configuration identifier */
    15c4:	4b1e      	ldr	r3, [pc, #120]	; (1640 <CPU_SetClockConfiguration+0x188>)
    15c6:	79fa      	ldrb	r2, [r7, #7]
    15c8:	701a      	strb	r2, [r3, #0]
  if ((CPU_ClockConfigDescriptors[ClockConfigurationID].PowerMode & CPU_CLOCK_VLP_AUTO_ENABLE_MASK) != 0U) {
    15ca:	4b1d      	ldr	r3, [pc, #116]	; (1640 <CPU_SetClockConfiguration+0x188>)
    15cc:	781b      	ldrb	r3, [r3, #0]
    15ce:	461a      	mov	r2, r3
    15d0:	491a      	ldr	r1, [pc, #104]	; (163c <CPU_SetClockConfiguration+0x184>)
    15d2:	4613      	mov	r3, r2
    15d4:	00db      	lsls	r3, r3, #3
    15d6:	1a9b      	subs	r3, r3, r2
    15d8:	009b      	lsls	r3, r3, #2
    15da:	440b      	add	r3, r1
    15dc:	789b      	ldrb	r3, [r3, #2]
    15de:	f003 0302 	and.w	r3, r3, #2
    15e2:	2b00      	cmp	r3, #0
    15e4:	d01f      	beq.n	1626 <CPU_SetClockConfiguration+0x16e>
    /* SMC_PMCTRL: LPWUI=0,RUNM=2,??=0,STOPA=0,STOPM=0 */
    SMC_PMCTRL = (SMC_PMCTRL_RUNM(0x02) | SMC_PMCTRL_STOPM(0x00)); /* Enable very low power mode */
    15e6:	4b12      	ldr	r3, [pc, #72]	; (1630 <CPU_SetClockConfiguration+0x178>)
    15e8:	2240      	movs	r2, #64	; 0x40
    15ea:	705a      	strb	r2, [r3, #1]
    if ((CPU_ClockConfigDescriptors[ClockConfigurationID].PowerMode & CPU_CLOCK_VLP_WAKEUP_MASK) != 0U) {
    15ec:	4b14      	ldr	r3, [pc, #80]	; (1640 <CPU_SetClockConfiguration+0x188>)
    15ee:	781b      	ldrb	r3, [r3, #0]
    15f0:	461a      	mov	r2, r3
    15f2:	4912      	ldr	r1, [pc, #72]	; (163c <CPU_SetClockConfiguration+0x184>)
    15f4:	4613      	mov	r3, r2
    15f6:	00db      	lsls	r3, r3, #3
    15f8:	1a9b      	subs	r3, r3, r2
    15fa:	009b      	lsls	r3, r3, #2
    15fc:	440b      	add	r3, r1
    15fe:	789b      	ldrb	r3, [r3, #2]
    1600:	f003 0304 	and.w	r3, r3, #4
    1604:	2b00      	cmp	r3, #0
    1606:	d008      	beq.n	161a <CPU_SetClockConfiguration+0x162>
      /* SMC_PMCTRL: LPWUI=1 */
      SMC_PMCTRL |= SMC_PMCTRL_LPWUI_MASK; /* Enable exits to Normal RUN mode on an interrupt */
    1608:	4b09      	ldr	r3, [pc, #36]	; (1630 <CPU_SetClockConfiguration+0x178>)
    160a:	4a09      	ldr	r2, [pc, #36]	; (1630 <CPU_SetClockConfiguration+0x178>)
    160c:	7852      	ldrb	r2, [r2, #1]
    160e:	b2d2      	uxtb	r2, r2
    1610:	f062 027f 	orn	r2, r2, #127	; 0x7f
    1614:	b2d2      	uxtb	r2, r2
    1616:	705a      	strb	r2, [r3, #1]
    }
    while(SMC_PMSTAT != 0x04U) {       /* Wait until in the Very Low Power run mode */
    1618:	e7ff      	b.n	161a <CPU_SetClockConfiguration+0x162>
    161a:	bf00      	nop
    161c:	4b04      	ldr	r3, [pc, #16]	; (1630 <CPU_SetClockConfiguration+0x178>)
    161e:	78db      	ldrb	r3, [r3, #3]
    1620:	b2db      	uxtb	r3, r3
    1622:	2b04      	cmp	r3, #4
    1624:	d1fa      	bne.n	161c <CPU_SetClockConfiguration+0x164>
    }
  }
  return ERR_OK;
    1626:	2300      	movs	r3, #0
}
    1628:	4618      	mov	r0, r3
    162a:	370c      	adds	r7, #12
    162c:	46bd      	mov	sp, r7
    162e:	bd90      	pop	{r4, r7, pc}
    1630:	4007e000 	.word	0x4007e000
    1634:	4007d000 	.word	0x4007d000
    1638:	40047000 	.word	0x40047000
    163c:	000072e8 	.word	0x000072e8
    1640:	20000025 	.word	0x20000025

00001644 <CPU_GetClockConfiguration>:
**                         - Active clock configuration identifier
*/
/* ===================================================================*/
#if CPU_GET_CLOCK_CONFIGURATION
LDD_TClockConfiguration CPU_GetClockConfiguration(void)
{
    1644:	b480      	push	{r7}
    1646:	af00      	add	r7, sp, #0
#if CPU_CLOCK_CONFIG_NUMBER > 1
  return ClockConfigurationID;         /* Return the actual clock configuration identifier */
    1648:	4b03      	ldr	r3, [pc, #12]	; (1658 <CPU_GetClockConfiguration+0x14>)
    164a:	781b      	ldrb	r3, [r3, #0]
#else
  return CPU_CLOCK_CONFIG_0;           /* Return the actual clock configuration identifier */
#endif
}
    164c:	4618      	mov	r0, r3
    164e:	46bd      	mov	sp, r7
    1650:	f85d 7b04 	ldr.w	r7, [sp], #4
    1654:	4770      	bx	lr
    1656:	bf00      	nop
    1658:	20000025 	.word	0x20000025

0000165c <Led_BlueBlink>:
#include "PDD_Includes.h"
#include "Init_Config.h"
/* User includes (#include below this line is not maintained by Processor Expert) */

void Led_BlueBlink(void *pvParameters)
{
    165c:	b580      	push	{r7, lr}
    165e:	b084      	sub	sp, #16
    1660:	af00      	add	r7, sp, #0
    1662:	6078      	str	r0, [r7, #4]
   const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
    1664:	2332      	movs	r3, #50	; 0x32
    1666:	60fb      	str	r3, [r7, #12]
   for(;;)
   {
	   LED_Blue_On();
    1668:	4b08      	ldr	r3, [pc, #32]	; (168c <Led_BlueBlink+0x30>)
    166a:	681b      	ldr	r3, [r3, #0]
    166c:	4618      	mov	r0, r3
    166e:	f005 fd59 	bl	7124 <BitIoLdd1_ClrVal>
	   vTaskDelay(xDelay);
    1672:	68f8      	ldr	r0, [r7, #12]
    1674:	f000 fb1c 	bl	1cb0 <vTaskDelay>
	   LED_Blue_Off();
    1678:	4b04      	ldr	r3, [pc, #16]	; (168c <Led_BlueBlink+0x30>)
    167a:	681b      	ldr	r3, [r3, #0]
    167c:	4618      	mov	r0, r3
    167e:	f005 fd61 	bl	7144 <BitIoLdd1_SetVal>
	   vTaskDelay(xDelay);
    1682:	68f8      	ldr	r0, [r7, #12]
    1684:	f000 fb14 	bl	1cb0 <vTaskDelay>
   }
    1688:	e7ee      	b.n	1668 <Led_BlueBlink+0xc>
    168a:	bf00      	nop
    168c:	2000119c 	.word	0x2000119c

00001690 <Led_RedBlink>:
}

void Led_RedBlink( void *pvParameters )
{
    1690:	b580      	push	{r7, lr}
    1692:	b084      	sub	sp, #16
    1694:	af00      	add	r7, sp, #0
    1696:	6078      	str	r0, [r7, #4]
	const TickType_t xDelay = 100 / portTICK_PERIOD_MS;
    1698:	230a      	movs	r3, #10
    169a:	60fb      	str	r3, [r7, #12]

	for( ;; )
	{
		LED_Red_On();
    169c:	4b08      	ldr	r3, [pc, #32]	; (16c0 <Led_RedBlink+0x30>)
    169e:	685b      	ldr	r3, [r3, #4]
    16a0:	4618      	mov	r0, r3
    16a2:	f005 fcb7 	bl	7014 <BitIoLdd2_ClrVal>
		vTaskDelay( xDelay );
    16a6:	68f8      	ldr	r0, [r7, #12]
    16a8:	f000 fb02 	bl	1cb0 <vTaskDelay>
		LED_Red_Off();
    16ac:	4b04      	ldr	r3, [pc, #16]	; (16c0 <Led_RedBlink+0x30>)
    16ae:	685b      	ldr	r3, [r3, #4]
    16b0:	4618      	mov	r0, r3
    16b2:	f005 fcbf 	bl	7034 <BitIoLdd2_SetVal>
		vTaskDelay( xDelay );
    16b6:	68f8      	ldr	r0, [r7, #12]
    16b8:	f000 fafa 	bl	1cb0 <vTaskDelay>
	}
    16bc:	e7ee      	b.n	169c <Led_RedBlink+0xc>
    16be:	bf00      	nop
    16c0:	2000119c 	.word	0x2000119c

000016c4 <Led_GreenBlink>:
}

void Led_GreenBlink( void *pvParameters )
{
    16c4:	b580      	push	{r7, lr}
    16c6:	b084      	sub	sp, #16
    16c8:	af00      	add	r7, sp, #0
    16ca:	6078      	str	r0, [r7, #4]
	const TickType_t xDelay = 250 / portTICK_PERIOD_MS;
    16cc:	2319      	movs	r3, #25
    16ce:	60fb      	str	r3, [r7, #12]

	for( ;; )
	{
		LED_Green_On();
    16d0:	4b08      	ldr	r3, [pc, #32]	; (16f4 <Led_GreenBlink+0x30>)
    16d2:	689b      	ldr	r3, [r3, #8]
    16d4:	4618      	mov	r0, r3
    16d6:	f005 fc15 	bl	6f04 <BitIoLdd3_ClrVal>
		vTaskDelay( xDelay );
    16da:	68f8      	ldr	r0, [r7, #12]
    16dc:	f000 fae8 	bl	1cb0 <vTaskDelay>
		LED_Green_Off();
    16e0:	4b04      	ldr	r3, [pc, #16]	; (16f4 <Led_GreenBlink+0x30>)
    16e2:	689b      	ldr	r3, [r3, #8]
    16e4:	4618      	mov	r0, r3
    16e6:	f005 fc1d 	bl	6f24 <BitIoLdd3_SetVal>
		vTaskDelay( xDelay );
    16ea:	68f8      	ldr	r0, [r7, #12]
    16ec:	f000 fae0 	bl	1cb0 <vTaskDelay>
	}
    16f0:	e7ee      	b.n	16d0 <Led_GreenBlink+0xc>
    16f2:	bf00      	nop
    16f4:	2000119c 	.word	0x2000119c

000016f8 <main>:
}

/*lint -save  -e970 Disable MISRA rule (6.3) checking. */
int main(void)
/*lint -restore Enable MISRA rule (6.3) checking. */
{
    16f8:	b580      	push	{r7, lr}
    16fa:	b084      	sub	sp, #16
    16fc:	af04      	add	r7, sp, #16
  /* Write your local variable definition here */

  /*** Processor Expert internal initialization. DON'T REMOVE THIS CODE!!! ***/
  PE_low_level_init();
    16fe:	f7ff fbe3 	bl	ec8 <PE_low_level_init>
  /*** End of Processor Expert internal initialization.                    ***/

  /* Write your code here */
  /* For example: for(;;) { } */
  xTaskCreate(Led_BlueBlink, (const char* const)"led_blue",configMINIMAL_STACK_SIZE,0,1,0);
    1702:	2301      	movs	r3, #1
    1704:	9300      	str	r3, [sp, #0]
    1706:	2300      	movs	r3, #0
    1708:	9301      	str	r3, [sp, #4]
    170a:	2300      	movs	r3, #0
    170c:	9302      	str	r3, [sp, #8]
    170e:	2300      	movs	r3, #0
    1710:	9303      	str	r3, [sp, #12]
    1712:	4812      	ldr	r0, [pc, #72]	; (175c <main+0x64>)
    1714:	4912      	ldr	r1, [pc, #72]	; (1760 <main+0x68>)
    1716:	22c8      	movs	r2, #200	; 0xc8
    1718:	2300      	movs	r3, #0
    171a:	f000 f9a9 	bl	1a70 <xTaskGenericCreate>
  xTaskCreate(Led_RedBlink, (const char* const)"led_red",configMINIMAL_STACK_SIZE,0,1,0);
    171e:	2301      	movs	r3, #1
    1720:	9300      	str	r3, [sp, #0]
    1722:	2300      	movs	r3, #0
    1724:	9301      	str	r3, [sp, #4]
    1726:	2300      	movs	r3, #0
    1728:	9302      	str	r3, [sp, #8]
    172a:	2300      	movs	r3, #0
    172c:	9303      	str	r3, [sp, #12]
    172e:	480d      	ldr	r0, [pc, #52]	; (1764 <main+0x6c>)
    1730:	490d      	ldr	r1, [pc, #52]	; (1768 <main+0x70>)
    1732:	22c8      	movs	r2, #200	; 0xc8
    1734:	2300      	movs	r3, #0
    1736:	f000 f99b 	bl	1a70 <xTaskGenericCreate>
  xTaskCreate(Led_GreenBlink, (const char* const)"led_green",configMINIMAL_STACK_SIZE,0,1,0);
    173a:	2301      	movs	r3, #1
    173c:	9300      	str	r3, [sp, #0]
    173e:	2300      	movs	r3, #0
    1740:	9301      	str	r3, [sp, #4]
    1742:	2300      	movs	r3, #0
    1744:	9302      	str	r3, [sp, #8]
    1746:	2300      	movs	r3, #0
    1748:	9303      	str	r3, [sp, #12]
    174a:	4808      	ldr	r0, [pc, #32]	; (176c <main+0x74>)
    174c:	4908      	ldr	r1, [pc, #32]	; (1770 <main+0x78>)
    174e:	22c8      	movs	r2, #200	; 0xc8
    1750:	2300      	movs	r3, #0
    1752:	f000 f98d 	bl	1a70 <xTaskGenericCreate>

  /*** Don't write any code pass this line, or it will be deleted during code generation. ***/
  /*** RTOS startup code. Macro PEX_RTOS_START is defined by the RTOS component. DON'T MODIFY THIS CODE!!! ***/
  #ifdef PEX_RTOS_START
    PEX_RTOS_START();                  /* Startup of the selected RTOS. Macro is defined by the RTOS component. */
    1756:	f000 fcf3 	bl	2140 <vTaskStartScheduler>
  #endif
  /*** End of RTOS startup code.  ***/
  /*** Processor Expert end of main routine. DON'T MODIFY THIS CODE!!! ***/
  for(;;){}
    175a:	e7fe      	b.n	175a <main+0x62>
    175c:	0000165d 	.word	0x0000165d
    1760:	000073d4 	.word	0x000073d4
    1764:	00001691 	.word	0x00001691
    1768:	000073e0 	.word	0x000073e0
    176c:	000016c5 	.word	0x000016c5
    1770:	000073e8 	.word	0x000073e8

00001774 <Cpu_OnNMI>:
**         occurred. This event is automatically enabled when the [NMI
**         interrupt] property is set to 'Enabled'.
*/
/* ===================================================================*/
void Cpu_OnNMI(void)
{
    1774:	b480      	push	{r7}
    1776:	af00      	add	r7, sp, #0
  /* Write your code here ... */
}
    1778:	46bd      	mov	sp, r7
    177a:	f85d 7b04 	ldr.w	r7, [sp], #4
    177e:	4770      	bx	lr

00001780 <FRTOS1_vApplicationStackOverflowHook>:
**       * pcTaskName      - Pointer to task name
**     Returns     : Nothing
** ===================================================================
*/
void FRTOS1_vApplicationStackOverflowHook(xTaskHandle pxTask, char *pcTaskName)
{
    1780:	b480      	push	{r7}
    1782:	b083      	sub	sp, #12
    1784:	af00      	add	r7, sp, #0
    1786:	6078      	str	r0, [r7, #4]
    1788:	6039      	str	r1, [r7, #0]
     switch.  Set configCHECK_FOR_STACK_OVERFLOWS to 2 to also check for stack
     problems within nested interrupts, but only do this for debug purposes as
     it will increase the context switch time. */
  (void)pxTask;
  (void)pcTaskName;
  taskDISABLE_INTERRUPTS();
    178a:	f04f 0050 	mov.w	r0, #80	; 0x50
    178e:	f380 8811 	msr	BASEPRI, r0
  /* Write your code here ... */
  for(;;) {}
    1792:	e7fe      	b.n	1792 <FRTOS1_vApplicationStackOverflowHook+0x12>

00001794 <FRTOS1_vApplicationTickHook>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FRTOS1_vApplicationTickHook(void)
{
    1794:	b480      	push	{r7}
    1796:	af00      	add	r7, sp, #0
  /* Called for every RTOS tick. */
  /* Write your code here ... */
}
    1798:	46bd      	mov	sp, r7
    179a:	f85d 7b04 	ldr.w	r7, [sp], #4
    179e:	4770      	bx	lr

000017a0 <FRTOS1_vApplicationIdleHook>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FRTOS1_vApplicationIdleHook(void)
{
    17a0:	b480      	push	{r7}
    17a2:	af00      	add	r7, sp, #0
  /* Called whenever the RTOS is idle (from the IDLE task).
     Here would be a good place to put the CPU into low power mode. */
  /* Write your code here ... */
}
    17a4:	46bd      	mov	sp, r7
    17a6:	f85d 7b04 	ldr.w	r7, [sp], #4
    17aa:	4770      	bx	lr

000017ac <FRTOS1_vApplicationMallocFailedHook>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FRTOS1_vApplicationMallocFailedHook(void)
{
    17ac:	b480      	push	{r7}
    17ae:	af00      	add	r7, sp, #0
  /* Called if a call to pvPortMalloc() fails because there is insufficient
     free memory available in the FreeRTOS heap.  pvPortMalloc() is called
     internally by FreeRTOS API functions that create tasks, queues, software
     timers, and semaphores.  The size of the FreeRTOS heap is set by the
     configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
  taskDISABLE_INTERRUPTS();
    17b0:	f04f 0050 	mov.w	r0, #80	; 0x50
    17b4:	f380 8811 	msr	BASEPRI, r0
  /* Write your code here ... */
  for(;;) {}
    17b8:	e7fe      	b.n	17b8 <FRTOS1_vApplicationMallocFailedHook+0xc>
    17ba:	bf00      	nop

000017bc <__copy_rom_section>:

/*
 *	Routine to copy a single section from ROM to RAM ...
 */
void __copy_rom_section(unsigned long dst, unsigned long src, unsigned long size)
{
    17bc:	b480      	push	{r7}
    17be:	b08b      	sub	sp, #44	; 0x2c
    17c0:	af00      	add	r7, sp, #0
    17c2:	60f8      	str	r0, [r7, #12]
    17c4:	60b9      	str	r1, [r7, #8]
    17c6:	607a      	str	r2, [r7, #4]
	unsigned long len = size;
    17c8:	687b      	ldr	r3, [r7, #4]
    17ca:	627b      	str	r3, [r7, #36]	; 0x24

	const unsigned int size_int = sizeof(int);
    17cc:	2304      	movs	r3, #4
    17ce:	623b      	str	r3, [r7, #32]
	const unsigned int mask_int = sizeof(int)-1;
    17d0:	2303      	movs	r3, #3
    17d2:	61fb      	str	r3, [r7, #28]

	const unsigned int size_short = sizeof(short);
    17d4:	2302      	movs	r3, #2
    17d6:	61bb      	str	r3, [r7, #24]
	const unsigned int mask_short = sizeof(short)-1;
    17d8:	2301      	movs	r3, #1
    17da:	617b      	str	r3, [r7, #20]

	const unsigned int size_char = sizeof(char);
    17dc:	2301      	movs	r3, #1
    17de:	613b      	str	r3, [r7, #16]

	if( dst == src || size == 0)
    17e0:	68fa      	ldr	r2, [r7, #12]
    17e2:	68bb      	ldr	r3, [r7, #8]
    17e4:	429a      	cmp	r2, r3
    17e6:	d002      	beq.n	17ee <__copy_rom_section+0x32>
    17e8:	687b      	ldr	r3, [r7, #4]
    17ea:	2b00      	cmp	r3, #0
    17ec:	d100      	bne.n	17f0 <__copy_rom_section+0x34>
	{
		return;
    17ee:	e051      	b.n	1894 <__copy_rom_section+0xd8>
	}


	while( len > 0)
    17f0:	e04d      	b.n	188e <__copy_rom_section+0xd2>
	{

		if( !(src & mask_int) && !(dst & mask_int) && len >= size_int)
    17f2:	68ba      	ldr	r2, [r7, #8]
    17f4:	69fb      	ldr	r3, [r7, #28]
    17f6:	4013      	ands	r3, r2
    17f8:	2b00      	cmp	r3, #0
    17fa:	d119      	bne.n	1830 <__copy_rom_section+0x74>
    17fc:	68fa      	ldr	r2, [r7, #12]
    17fe:	69fb      	ldr	r3, [r7, #28]
    1800:	4013      	ands	r3, r2
    1802:	2b00      	cmp	r3, #0
    1804:	d114      	bne.n	1830 <__copy_rom_section+0x74>
    1806:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1808:	6a3b      	ldr	r3, [r7, #32]
    180a:	429a      	cmp	r2, r3
    180c:	d310      	bcc.n	1830 <__copy_rom_section+0x74>
		{
			*((int *)dst)  = *((int*)src);
    180e:	68fb      	ldr	r3, [r7, #12]
    1810:	68ba      	ldr	r2, [r7, #8]
    1812:	6812      	ldr	r2, [r2, #0]
    1814:	601a      	str	r2, [r3, #0]
			dst += size_int;
    1816:	68fa      	ldr	r2, [r7, #12]
    1818:	6a3b      	ldr	r3, [r7, #32]
    181a:	4413      	add	r3, r2
    181c:	60fb      	str	r3, [r7, #12]
			src += size_int;
    181e:	68ba      	ldr	r2, [r7, #8]
    1820:	6a3b      	ldr	r3, [r7, #32]
    1822:	4413      	add	r3, r2
    1824:	60bb      	str	r3, [r7, #8]
			len -= size_int;
    1826:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1828:	6a3b      	ldr	r3, [r7, #32]
    182a:	1ad3      	subs	r3, r2, r3
    182c:	627b      	str	r3, [r7, #36]	; 0x24
    182e:	e02e      	b.n	188e <__copy_rom_section+0xd2>
		}
		else if( !(src & mask_short) && !(dst & mask_short) && len >= size_short)
    1830:	68ba      	ldr	r2, [r7, #8]
    1832:	697b      	ldr	r3, [r7, #20]
    1834:	4013      	ands	r3, r2
    1836:	2b00      	cmp	r3, #0
    1838:	d119      	bne.n	186e <__copy_rom_section+0xb2>
    183a:	68fa      	ldr	r2, [r7, #12]
    183c:	697b      	ldr	r3, [r7, #20]
    183e:	4013      	ands	r3, r2
    1840:	2b00      	cmp	r3, #0
    1842:	d114      	bne.n	186e <__copy_rom_section+0xb2>
    1844:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1846:	69bb      	ldr	r3, [r7, #24]
    1848:	429a      	cmp	r2, r3
    184a:	d310      	bcc.n	186e <__copy_rom_section+0xb2>
		{
			*((short *)dst)  = *((short*)src);
    184c:	68fb      	ldr	r3, [r7, #12]
    184e:	68ba      	ldr	r2, [r7, #8]
    1850:	8812      	ldrh	r2, [r2, #0]
    1852:	801a      	strh	r2, [r3, #0]
			dst += size_short;
    1854:	68fa      	ldr	r2, [r7, #12]
    1856:	69bb      	ldr	r3, [r7, #24]
    1858:	4413      	add	r3, r2
    185a:	60fb      	str	r3, [r7, #12]
			src += size_short;
    185c:	68ba      	ldr	r2, [r7, #8]
    185e:	69bb      	ldr	r3, [r7, #24]
    1860:	4413      	add	r3, r2
    1862:	60bb      	str	r3, [r7, #8]
			len -= size_short;
    1864:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1866:	69bb      	ldr	r3, [r7, #24]
    1868:	1ad3      	subs	r3, r2, r3
    186a:	627b      	str	r3, [r7, #36]	; 0x24
    186c:	e00f      	b.n	188e <__copy_rom_section+0xd2>
		}
		else
		{
			*((char *)dst)  = *((char*)src);
    186e:	68fb      	ldr	r3, [r7, #12]
    1870:	68ba      	ldr	r2, [r7, #8]
    1872:	7812      	ldrb	r2, [r2, #0]
    1874:	701a      	strb	r2, [r3, #0]
			dst += size_char;
    1876:	68fa      	ldr	r2, [r7, #12]
    1878:	693b      	ldr	r3, [r7, #16]
    187a:	4413      	add	r3, r2
    187c:	60fb      	str	r3, [r7, #12]
			src += size_char;
    187e:	68ba      	ldr	r2, [r7, #8]
    1880:	693b      	ldr	r3, [r7, #16]
    1882:	4413      	add	r3, r2
    1884:	60bb      	str	r3, [r7, #8]
			len -= size_char;
    1886:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1888:	693b      	ldr	r3, [r7, #16]
    188a:	1ad3      	subs	r3, r2, r3
    188c:	627b      	str	r3, [r7, #36]	; 0x24
	{
		return;
	}


	while( len > 0)
    188e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1890:	2b00      	cmp	r3, #0
    1892:	d1ae      	bne.n	17f2 <__copy_rom_section+0x36>
			dst += size_char;
			src += size_char;
			len -= size_char;
		}
	}
}
    1894:	372c      	adds	r7, #44	; 0x2c
    1896:	46bd      	mov	sp, r7
    1898:	f85d 7b04 	ldr.w	r7, [sp], #4
    189c:	4770      	bx	lr
    189e:	bf00      	nop

000018a0 <__copy_rom_sections_to_ram>:
 *  It is a table of RomInfo
 *	structures.  The final entry in the table has all-zero
 *	fields.
 */
void __copy_rom_sections_to_ram(void)
{
    18a0:	b590      	push	{r4, r7, lr}
    18a2:	b083      	sub	sp, #12
    18a4:	af00      	add	r7, sp, #0

	int				index;

	if (__S_romp == 0L) return;
    18a6:	4b24      	ldr	r3, [pc, #144]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    18a8:	2b00      	cmp	r3, #0
    18aa:	d100      	bne.n	18ae <__copy_rom_sections_to_ram+0xe>
    18ac:	e040      	b.n	1930 <__copy_rom_sections_to_ram+0x90>

	/*
	 *	Go through the entire table, copying sections from ROM to RAM.
	 */
	for (index = 0;
    18ae:	2300      	movs	r3, #0
    18b0:	607b      	str	r3, [r7, #4]
    18b2:	e01e      	b.n	18f2 <__copy_rom_sections_to_ram+0x52>
		 __S_romp[index].Source != 0 ||
		 __S_romp[index].Target != 0 ||
		 __S_romp[index].Size != 0;
		 ++index)
	{
		__copy_rom_section( __S_romp[index].Target,
    18b4:	4920      	ldr	r1, [pc, #128]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    18b6:	687a      	ldr	r2, [r7, #4]
    18b8:	4613      	mov	r3, r2
    18ba:	005b      	lsls	r3, r3, #1
    18bc:	4413      	add	r3, r2
    18be:	009b      	lsls	r3, r3, #2
    18c0:	440b      	add	r3, r1
    18c2:	6858      	ldr	r0, [r3, #4]
    18c4:	491c      	ldr	r1, [pc, #112]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    18c6:	687a      	ldr	r2, [r7, #4]
    18c8:	4613      	mov	r3, r2
    18ca:	005b      	lsls	r3, r3, #1
    18cc:	4413      	add	r3, r2
    18ce:	009b      	lsls	r3, r3, #2
    18d0:	440b      	add	r3, r1
    18d2:	6819      	ldr	r1, [r3, #0]
    18d4:	4c18      	ldr	r4, [pc, #96]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    18d6:	687a      	ldr	r2, [r7, #4]
    18d8:	4613      	mov	r3, r2
    18da:	005b      	lsls	r3, r3, #1
    18dc:	4413      	add	r3, r2
    18de:	009b      	lsls	r3, r3, #2
    18e0:	4423      	add	r3, r4
    18e2:	3308      	adds	r3, #8
    18e4:	681b      	ldr	r3, [r3, #0]
    18e6:	461a      	mov	r2, r3
    18e8:	f7ff ff68 	bl	17bc <__copy_rom_section>
	 */
	for (index = 0;
		 __S_romp[index].Source != 0 ||
		 __S_romp[index].Target != 0 ||
		 __S_romp[index].Size != 0;
		 ++index)
    18ec:	687b      	ldr	r3, [r7, #4]
    18ee:	3301      	adds	r3, #1
    18f0:	607b      	str	r3, [r7, #4]

	/*
	 *	Go through the entire table, copying sections from ROM to RAM.
	 */
	for (index = 0;
		 __S_romp[index].Source != 0 ||
    18f2:	4911      	ldr	r1, [pc, #68]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    18f4:	687a      	ldr	r2, [r7, #4]
    18f6:	4613      	mov	r3, r2
    18f8:	005b      	lsls	r3, r3, #1
    18fa:	4413      	add	r3, r2
    18fc:	009b      	lsls	r3, r3, #2
    18fe:	440b      	add	r3, r1
    1900:	681b      	ldr	r3, [r3, #0]
	if (__S_romp == 0L) return;

	/*
	 *	Go through the entire table, copying sections from ROM to RAM.
	 */
	for (index = 0;
    1902:	2b00      	cmp	r3, #0
    1904:	d1d6      	bne.n	18b4 <__copy_rom_sections_to_ram+0x14>
		 __S_romp[index].Source != 0 ||
		 __S_romp[index].Target != 0 ||
    1906:	490c      	ldr	r1, [pc, #48]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    1908:	687a      	ldr	r2, [r7, #4]
    190a:	4613      	mov	r3, r2
    190c:	005b      	lsls	r3, r3, #1
    190e:	4413      	add	r3, r2
    1910:	009b      	lsls	r3, r3, #2
    1912:	440b      	add	r3, r1
    1914:	685b      	ldr	r3, [r3, #4]

	/*
	 *	Go through the entire table, copying sections from ROM to RAM.
	 */
	for (index = 0;
		 __S_romp[index].Source != 0 ||
    1916:	2b00      	cmp	r3, #0
    1918:	d1cc      	bne.n	18b4 <__copy_rom_sections_to_ram+0x14>
		 __S_romp[index].Target != 0 ||
		 __S_romp[index].Size != 0;
    191a:	4907      	ldr	r1, [pc, #28]	; (1938 <__copy_rom_sections_to_ram+0x98>)
    191c:	687a      	ldr	r2, [r7, #4]
    191e:	4613      	mov	r3, r2
    1920:	005b      	lsls	r3, r3, #1
    1922:	4413      	add	r3, r2
    1924:	009b      	lsls	r3, r3, #2
    1926:	440b      	add	r3, r1
    1928:	3308      	adds	r3, #8
    192a:	681b      	ldr	r3, [r3, #0]
	/*
	 *	Go through the entire table, copying sections from ROM to RAM.
	 */
	for (index = 0;
		 __S_romp[index].Source != 0 ||
		 __S_romp[index].Target != 0 ||
    192c:	2b00      	cmp	r3, #0
    192e:	d1c1      	bne.n	18b4 <__copy_rom_sections_to_ram+0x14>
		__copy_rom_section( __S_romp[index].Target,
							__S_romp[index].Source,
							__S_romp[index].Size );

	}
}
    1930:	370c      	adds	r7, #12
    1932:	46bd      	mov	sp, r7
    1934:	bd90      	pop	{r4, r7, pc}
    1936:	bf00      	nop
    1938:	00007520 	.word	0x00007520

0000193c <zero_fill_bss>:

#ifdef __ATOLLIC__
static void zero_fill_bss(void)
{
    193c:	b480      	push	{r7}
    193e:	b089      	sub	sp, #36	; 0x24
    1940:	af00      	add	r7, sp, #0
  extern char __START_BSS[];
  extern char __END_BSS[];
  
  unsigned long len = __END_BSS - __START_BSS;
    1942:	4a29      	ldr	r2, [pc, #164]	; (19e8 <zero_fill_bss+0xac>)
    1944:	4b29      	ldr	r3, [pc, #164]	; (19ec <zero_fill_bss+0xb0>)
    1946:	1ad3      	subs	r3, r2, r3
    1948:	61fb      	str	r3, [r7, #28]
  unsigned long dst = (unsigned long) __START_BSS;
    194a:	4b28      	ldr	r3, [pc, #160]	; (19ec <zero_fill_bss+0xb0>)
    194c:	61bb      	str	r3, [r7, #24]
  
  const int size_int = sizeof(int);
    194e:	2304      	movs	r3, #4
    1950:	617b      	str	r3, [r7, #20]
  const int mask_int = sizeof(int)-1;
    1952:	2303      	movs	r3, #3
    1954:	613b      	str	r3, [r7, #16]
  
  const int size_short = sizeof(short);
    1956:	2302      	movs	r3, #2
    1958:	60fb      	str	r3, [r7, #12]
  const int mask_short = sizeof(short)-1;
    195a:	2301      	movs	r3, #1
    195c:	60bb      	str	r3, [r7, #8]
  
  const int size_char = sizeof(char);
    195e:	2301      	movs	r3, #1
    1960:	607b      	str	r3, [r7, #4]
  
  if( len == 0)
    1962:	69fb      	ldr	r3, [r7, #28]
    1964:	2b00      	cmp	r3, #0
    1966:	d100      	bne.n	196a <zero_fill_bss+0x2e>
  {
    return;
    1968:	e038      	b.n	19dc <zero_fill_bss+0xa0>
  }


  while( len > 0)
    196a:	e034      	b.n	19d6 <zero_fill_bss+0x9a>
  {
    if( !(dst & mask_int) && len >= size_int)
    196c:	693a      	ldr	r2, [r7, #16]
    196e:	69bb      	ldr	r3, [r7, #24]
    1970:	4013      	ands	r3, r2
    1972:	2b00      	cmp	r3, #0
    1974:	d10f      	bne.n	1996 <zero_fill_bss+0x5a>
    1976:	697a      	ldr	r2, [r7, #20]
    1978:	69fb      	ldr	r3, [r7, #28]
    197a:	429a      	cmp	r2, r3
    197c:	d80b      	bhi.n	1996 <zero_fill_bss+0x5a>
    {
      *((int *)dst)  = 0;
    197e:	69bb      	ldr	r3, [r7, #24]
    1980:	2200      	movs	r2, #0
    1982:	601a      	str	r2, [r3, #0]
      dst += size_int;
    1984:	697b      	ldr	r3, [r7, #20]
    1986:	69ba      	ldr	r2, [r7, #24]
    1988:	4413      	add	r3, r2
    198a:	61bb      	str	r3, [r7, #24]
      len -= size_int;
    198c:	697b      	ldr	r3, [r7, #20]
    198e:	69fa      	ldr	r2, [r7, #28]
    1990:	1ad3      	subs	r3, r2, r3
    1992:	61fb      	str	r3, [r7, #28]
    1994:	e01f      	b.n	19d6 <zero_fill_bss+0x9a>
    }
    else if( !(dst & mask_short) && len >= size_short)
    1996:	68ba      	ldr	r2, [r7, #8]
    1998:	69bb      	ldr	r3, [r7, #24]
    199a:	4013      	ands	r3, r2
    199c:	2b00      	cmp	r3, #0
    199e:	d10f      	bne.n	19c0 <zero_fill_bss+0x84>
    19a0:	68fa      	ldr	r2, [r7, #12]
    19a2:	69fb      	ldr	r3, [r7, #28]
    19a4:	429a      	cmp	r2, r3
    19a6:	d80b      	bhi.n	19c0 <zero_fill_bss+0x84>
    {
      *((short *)dst)  = 0;
    19a8:	69bb      	ldr	r3, [r7, #24]
    19aa:	2200      	movs	r2, #0
    19ac:	801a      	strh	r2, [r3, #0]
      dst += size_short;
    19ae:	68fb      	ldr	r3, [r7, #12]
    19b0:	69ba      	ldr	r2, [r7, #24]
    19b2:	4413      	add	r3, r2
    19b4:	61bb      	str	r3, [r7, #24]
      len -= size_short;
    19b6:	68fb      	ldr	r3, [r7, #12]
    19b8:	69fa      	ldr	r2, [r7, #28]
    19ba:	1ad3      	subs	r3, r2, r3
    19bc:	61fb      	str	r3, [r7, #28]
    19be:	e00a      	b.n	19d6 <zero_fill_bss+0x9a>
    }
    else
    {
      *((char *)dst)  = 0;
    19c0:	69bb      	ldr	r3, [r7, #24]
    19c2:	2200      	movs	r2, #0
    19c4:	701a      	strb	r2, [r3, #0]
      dst += size_char;
    19c6:	687b      	ldr	r3, [r7, #4]
    19c8:	69ba      	ldr	r2, [r7, #24]
    19ca:	4413      	add	r3, r2
    19cc:	61bb      	str	r3, [r7, #24]
      len -= size_char;
    19ce:	687b      	ldr	r3, [r7, #4]
    19d0:	69fa      	ldr	r2, [r7, #28]
    19d2:	1ad3      	subs	r3, r2, r3
    19d4:	61fb      	str	r3, [r7, #28]
  {
    return;
  }


  while( len > 0)
    19d6:	69fb      	ldr	r3, [r7, #28]
    19d8:	2b00      	cmp	r3, #0
    19da:	d1c7      	bne.n	196c <zero_fill_bss+0x30>
      *((char *)dst)  = 0;
      dst += size_char;
      len -= size_char;
    }
  }
}
    19dc:	3724      	adds	r7, #36	; 0x24
    19de:	46bd      	mov	sp, r7
    19e0:	f85d 7b04 	ldr.w	r7, [sp], #4
    19e4:	4770      	bx	lr
    19e6:	bf00      	nop
    19e8:	200011b8 	.word	0x200011b8
    19ec:	20000008 	.word	0x20000008

000019f0 <__init_registers>:
#endif

void __attribute__ ((weak)) __init_registers(void)
{
    19f0:	b480      	push	{r7}
    19f2:	af00      	add	r7, sp, #0
  #if defined(SCB_CPACR)
  /* Initialize FPU */
  SCB_CPACR |= SCB_CPACR_CP10(3U) | SCB_CPACR_CP11(3U); 
    19f4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    19f8:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    19fc:	f8d2 2d88 	ldr.w	r2, [r2, #3464]	; 0xd88
    1a00:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    1a04:	f8c3 2d88 	str.w	r2, [r3, #3464]	; 0xd88
  #endif

}
    1a08:	46bd      	mov	sp, r7
    1a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
    1a0e:	4770      	bx	lr

void __attribute__ ((weak)) __init_hardware(void)
{
    1a10:	b480      	push	{r7}
    1a12:	af00      	add	r7, sp, #0

}
    1a14:	46bd      	mov	sp, r7
    1a16:	f85d 7b04 	ldr.w	r7, [sp], #4
    1a1a:	4770      	bx	lr

00001a1c <__init_user>:

void __attribute__ ((weak)) __init_user(void)
{
    1a1c:	b480      	push	{r7}
    1a1e:	af00      	add	r7, sp, #0

}
    1a20:	46bd      	mov	sp, r7
    1a22:	f85d 7b04 	ldr.w	r7, [sp], #4
    1a26:	4770      	bx	lr

00001a28 <__iar_program_start>:

/* To match iar debugger expectation */
void __iar_program_start(void);
void __thumb_startup(void);
void __iar_program_start()
{
    1a28:	b580      	push	{r7, lr}
    1a2a:	af00      	add	r7, sp, #0
	__thumb_startup();
    1a2c:	f000 f802 	bl	1a34 <__thumb_startup>
}
    1a30:	bd80      	pop	{r7, pc}
    1a32:	bf00      	nop

00001a34 <__thumb_startup>:

__attribute__((naked)) void __thumb_startup(void)
{
int addr = (int)__SP_INIT;
    1a34:	4c0d      	ldr	r4, [pc, #52]	; (1a6c <skip_sp+0x1e>)

    /* setup the stack before we attempt anything else
       skip stack setup if __SP_INIT is 0
       assume sp is already setup. */
    __asm (
    1a36:	4620      	mov	r0, r4
    1a38:	2800      	cmp	r0, #0
    1a3a:	f000 8008 	beq.w	1a4e <skip_sp>
    1a3e:	4685      	mov	sp, r0
    1a40:	b081      	sub	sp, #4
    1a42:	f04f 0000 	mov.w	r0, #0
    1a46:	ea6f 0000 	mvn.w	r0, r0
    1a4a:	9000      	str	r0, [sp, #0]
    1a4c:	b001      	add	sp, #4

00001a4e <skip_sp>:
    "add  sp,#4\n\t"
    "skip_sp:\n\t"
    ::"r"(addr));

    /* Setup registers */
    __init_registers();
    1a4e:	f7ff ffcf 	bl	19f0 <__init_registers>
    
    /* setup hardware */
    __init_hardware();
    1a52:	f7ff f9cb 	bl	dec <__init_hardware>
    
    /* SUPPORT_ROM_TO_RAM */
    __copy_rom_sections_to_ram();
    1a56:	f7ff ff23 	bl	18a0 <__copy_rom_sections_to_ram>
    
    /* initializations before main, user specific */
    __init_user();
    1a5a:	f7ff ffdf 	bl	1a1c <__init_user>

#ifndef __ATOLLIC__
    _start();
#else
    /* zero-fill the .bss section */
    zero_fill_bss();
    1a5e:	f7ff ff6d 	bl	193c <zero_fill_bss>
    /* Run static constructors */
    __libc_init_array();
    1a62:	f005 fb9d 	bl	71a0 <__libc_init_array>
    main();
    1a66:	f7ff fe47 	bl	16f8 <main>
#endif

    /*	should never get here */
    while (1);
    1a6a:	e7fe      	b.n	1a6a <skip_sp+0x1c>
    1a6c:	20030000 	.word	0x20030000

00001a70 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1a70:	b580      	push	{r7, lr}
    1a72:	b08a      	sub	sp, #40	; 0x28
    1a74:	af02      	add	r7, sp, #8
    1a76:	60f8      	str	r0, [r7, #12]
    1a78:	60b9      	str	r1, [r7, #8]
    1a7a:	603b      	str	r3, [r7, #0]
    1a7c:	4613      	mov	r3, r2
    1a7e:	80fb      	strh	r3, [r7, #6]
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
    1a80:	68fb      	ldr	r3, [r7, #12]
    1a82:	2b00      	cmp	r3, #0
    1a84:	d104      	bne.n	1a90 <xTaskGenericCreate+0x20>
    1a86:	f04f 0050 	mov.w	r0, #80	; 0x50
    1a8a:	f380 8811 	msr	BASEPRI, r0
    1a8e:	e7fe      	b.n	1a8e <xTaskGenericCreate+0x1e>
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
    1a90:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1a92:	2b05      	cmp	r3, #5
    1a94:	d904      	bls.n	1aa0 <xTaskGenericCreate+0x30>
    1a96:	f04f 0050 	mov.w	r0, #80	; 0x50
    1a9a:	f380 8811 	msr	BASEPRI, r0
    1a9e:	e7fe      	b.n	1a9e <xTaskGenericCreate+0x2e>

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1aa0:	88fb      	ldrh	r3, [r7, #6]
    1aa2:	4618      	mov	r0, r3
    1aa4:	6b39      	ldr	r1, [r7, #48]	; 0x30
    1aa6:	f001 f8e9 	bl	2c7c <prvAllocateTCBAndStack>
    1aaa:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
    1aac:	69bb      	ldr	r3, [r7, #24]
    1aae:	2b00      	cmp	r3, #0
    1ab0:	d074      	beq.n	1b9c <xTaskGenericCreate+0x12c>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1ab2:	69bb      	ldr	r3, [r7, #24]
    1ab4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1ab6:	88fb      	ldrh	r3, [r7, #6]
    1ab8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    1abc:	3b01      	subs	r3, #1
    1abe:	009b      	lsls	r3, r3, #2
    1ac0:	4413      	add	r3, r2
    1ac2:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
    1ac4:	697b      	ldr	r3, [r7, #20]
    1ac6:	f023 0307 	bic.w	r3, r3, #7
    1aca:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    1acc:	697b      	ldr	r3, [r7, #20]
    1ace:	f003 0307 	and.w	r3, r3, #7
    1ad2:	2b00      	cmp	r3, #0
    1ad4:	d004      	beq.n	1ae0 <xTaskGenericCreate+0x70>
    1ad6:	f04f 0050 	mov.w	r0, #80	; 0x50
    1ada:	f380 8811 	msr	BASEPRI, r0
    1ade:	e7fe      	b.n	1ade <xTaskGenericCreate+0x6e>
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1ae0:	88fb      	ldrh	r3, [r7, #6]
    1ae2:	9300      	str	r3, [sp, #0]
    1ae4:	69b8      	ldr	r0, [r7, #24]
    1ae6:	68b9      	ldr	r1, [r7, #8]
    1ae8:	6aba      	ldr	r2, [r7, #40]	; 0x28
    1aea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    1aec:	f000 fffe 	bl	2aec <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1af0:	6978      	ldr	r0, [r7, #20]
    1af2:	68f9      	ldr	r1, [r7, #12]
    1af4:	683a      	ldr	r2, [r7, #0]
    1af6:	f002 fce5 	bl	44c4 <pxPortInitialiseStack>
    1afa:	4602      	mov	r2, r0
    1afc:	69bb      	ldr	r3, [r7, #24]
    1afe:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1b00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1b02:	2b00      	cmp	r3, #0
    1b04:	d002      	beq.n	1b0c <xTaskGenericCreate+0x9c>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1b06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1b08:	69ba      	ldr	r2, [r7, #24]
    1b0a:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1b0c:	f002 fd84 	bl	4618 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
    1b10:	4b2e      	ldr	r3, [pc, #184]	; (1bcc <xTaskGenericCreate+0x15c>)
    1b12:	681b      	ldr	r3, [r3, #0]
    1b14:	1c5a      	adds	r2, r3, #1
    1b16:	4b2d      	ldr	r3, [pc, #180]	; (1bcc <xTaskGenericCreate+0x15c>)
    1b18:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
    1b1a:	4b2d      	ldr	r3, [pc, #180]	; (1bd0 <xTaskGenericCreate+0x160>)
    1b1c:	681b      	ldr	r3, [r3, #0]
    1b1e:	2b00      	cmp	r3, #0
    1b20:	d109      	bne.n	1b36 <xTaskGenericCreate+0xc6>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1b22:	4b2b      	ldr	r3, [pc, #172]	; (1bd0 <xTaskGenericCreate+0x160>)
    1b24:	69ba      	ldr	r2, [r7, #24]
    1b26:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1b28:	4b28      	ldr	r3, [pc, #160]	; (1bcc <xTaskGenericCreate+0x15c>)
    1b2a:	681b      	ldr	r3, [r3, #0]
    1b2c:	2b01      	cmp	r3, #1
    1b2e:	d10f      	bne.n	1b50 <xTaskGenericCreate+0xe0>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1b30:	f001 f82e 	bl	2b90 <prvInitialiseTaskLists>
    1b34:	e00c      	b.n	1b50 <xTaskGenericCreate+0xe0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1b36:	4b27      	ldr	r3, [pc, #156]	; (1bd4 <xTaskGenericCreate+0x164>)
    1b38:	681b      	ldr	r3, [r3, #0]
    1b3a:	2b00      	cmp	r3, #0
    1b3c:	d108      	bne.n	1b50 <xTaskGenericCreate+0xe0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1b3e:	4b24      	ldr	r3, [pc, #144]	; (1bd0 <xTaskGenericCreate+0x160>)
    1b40:	681b      	ldr	r3, [r3, #0]
    1b42:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1b44:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1b46:	429a      	cmp	r2, r3
    1b48:	d802      	bhi.n	1b50 <xTaskGenericCreate+0xe0>
					{
						pxCurrentTCB = pxNewTCB;
    1b4a:	4b21      	ldr	r3, [pc, #132]	; (1bd0 <xTaskGenericCreate+0x160>)
    1b4c:	69ba      	ldr	r2, [r7, #24]
    1b4e:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1b50:	4b21      	ldr	r3, [pc, #132]	; (1bd8 <xTaskGenericCreate+0x168>)
    1b52:	681b      	ldr	r3, [r3, #0]
    1b54:	1c5a      	adds	r2, r3, #1
    1b56:	4b20      	ldr	r3, [pc, #128]	; (1bd8 <xTaskGenericCreate+0x168>)
    1b58:	601a      	str	r2, [r3, #0]

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    1b5a:	4b1f      	ldr	r3, [pc, #124]	; (1bd8 <xTaskGenericCreate+0x168>)
    1b5c:	681a      	ldr	r2, [r3, #0]
    1b5e:	69bb      	ldr	r3, [r7, #24]
    1b60:	641a      	str	r2, [r3, #64]	; 0x40
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1b62:	69bb      	ldr	r3, [r7, #24]
    1b64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1b66:	4b1d      	ldr	r3, [pc, #116]	; (1bdc <xTaskGenericCreate+0x16c>)
    1b68:	681b      	ldr	r3, [r3, #0]
    1b6a:	429a      	cmp	r2, r3
    1b6c:	d903      	bls.n	1b76 <xTaskGenericCreate+0x106>
    1b6e:	69bb      	ldr	r3, [r7, #24]
    1b70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1b72:	4b1a      	ldr	r3, [pc, #104]	; (1bdc <xTaskGenericCreate+0x16c>)
    1b74:	601a      	str	r2, [r3, #0]
    1b76:	69bb      	ldr	r3, [r7, #24]
    1b78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1b7a:	4613      	mov	r3, r2
    1b7c:	009b      	lsls	r3, r3, #2
    1b7e:	4413      	add	r3, r2
    1b80:	009b      	lsls	r3, r3, #2
    1b82:	4a17      	ldr	r2, [pc, #92]	; (1be0 <xTaskGenericCreate+0x170>)
    1b84:	441a      	add	r2, r3
    1b86:	69bb      	ldr	r3, [r7, #24]
    1b88:	3304      	adds	r3, #4
    1b8a:	4610      	mov	r0, r2
    1b8c:	4619      	mov	r1, r3
    1b8e:	f002 fe15 	bl	47bc <vListInsertEnd>

			xReturn = pdPASS;
    1b92:	2301      	movs	r3, #1
    1b94:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1b96:	f002 fd55 	bl	4644 <vPortExitCritical>
    1b9a:	e002      	b.n	1ba2 <xTaskGenericCreate+0x132>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b9c:	f04f 33ff 	mov.w	r3, #4294967295
    1ba0:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1ba2:	69fb      	ldr	r3, [r7, #28]
    1ba4:	2b01      	cmp	r3, #1
    1ba6:	d10b      	bne.n	1bc0 <xTaskGenericCreate+0x150>
	{
		if( xSchedulerRunning != pdFALSE )
    1ba8:	4b0a      	ldr	r3, [pc, #40]	; (1bd4 <xTaskGenericCreate+0x164>)
    1baa:	681b      	ldr	r3, [r3, #0]
    1bac:	2b00      	cmp	r3, #0
    1bae:	d007      	beq.n	1bc0 <xTaskGenericCreate+0x150>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1bb0:	4b07      	ldr	r3, [pc, #28]	; (1bd0 <xTaskGenericCreate+0x160>)
    1bb2:	681b      	ldr	r3, [r3, #0]
    1bb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1bb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1bb8:	429a      	cmp	r2, r3
    1bba:	d201      	bcs.n	1bc0 <xTaskGenericCreate+0x150>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1bbc:	f002 fd58 	bl	4670 <vPortYieldFromISR>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    1bc0:	69fb      	ldr	r3, [r7, #28]
}
    1bc2:	4618      	mov	r0, r3
    1bc4:	3720      	adds	r7, #32
    1bc6:	46bd      	mov	sp, r7
    1bc8:	bd80      	pop	{r7, pc}
    1bca:	bf00      	nop
    1bcc:	20000100 	.word	0x20000100
    1bd0:	20000028 	.word	0x20000028
    1bd4:	2000010c 	.word	0x2000010c
    1bd8:	2000011c 	.word	0x2000011c
    1bdc:	20000108 	.word	0x20000108
    1be0:	2000002c 	.word	0x2000002c

00001be4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1be4:	b580      	push	{r7, lr}
    1be6:	b086      	sub	sp, #24
    1be8:	af00      	add	r7, sp, #0
    1bea:	6078      	str	r0, [r7, #4]
    1bec:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1bee:	2300      	movs	r3, #0
    1bf0:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
    1bf2:	687b      	ldr	r3, [r7, #4]
    1bf4:	2b00      	cmp	r3, #0
    1bf6:	d104      	bne.n	1c02 <vTaskDelayUntil+0x1e>
    1bf8:	f04f 0050 	mov.w	r0, #80	; 0x50
    1bfc:	f380 8811 	msr	BASEPRI, r0
    1c00:	e7fe      	b.n	1c00 <vTaskDelayUntil+0x1c>
		configASSERT( ( xTimeIncrement > 0U ) );
    1c02:	683b      	ldr	r3, [r7, #0]
    1c04:	2b00      	cmp	r3, #0
    1c06:	d104      	bne.n	1c12 <vTaskDelayUntil+0x2e>
    1c08:	f04f 0050 	mov.w	r0, #80	; 0x50
    1c0c:	f380 8811 	msr	BASEPRI, r0
    1c10:	e7fe      	b.n	1c10 <vTaskDelayUntil+0x2c>
		configASSERT( uxSchedulerSuspended == 0 );
    1c12:	4b24      	ldr	r3, [pc, #144]	; (1ca4 <vTaskDelayUntil+0xc0>)
    1c14:	681b      	ldr	r3, [r3, #0]
    1c16:	2b00      	cmp	r3, #0
    1c18:	d004      	beq.n	1c24 <vTaskDelayUntil+0x40>
    1c1a:	f04f 0050 	mov.w	r0, #80	; 0x50
    1c1e:	f380 8811 	msr	BASEPRI, r0
    1c22:	e7fe      	b.n	1c22 <vTaskDelayUntil+0x3e>

		vTaskSuspendAll();
    1c24:	f000 fad8 	bl	21d8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1c28:	4b1f      	ldr	r3, [pc, #124]	; (1ca8 <vTaskDelayUntil+0xc4>)
    1c2a:	681b      	ldr	r3, [r3, #0]
    1c2c:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c2e:	687b      	ldr	r3, [r7, #4]
    1c30:	681a      	ldr	r2, [r3, #0]
    1c32:	683b      	ldr	r3, [r7, #0]
    1c34:	4413      	add	r3, r2
    1c36:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
    1c38:	687b      	ldr	r3, [r7, #4]
    1c3a:	681a      	ldr	r2, [r3, #0]
    1c3c:	693b      	ldr	r3, [r7, #16]
    1c3e:	429a      	cmp	r2, r3
    1c40:	d90b      	bls.n	1c5a <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1c42:	687b      	ldr	r3, [r7, #4]
    1c44:	681a      	ldr	r2, [r3, #0]
    1c46:	68fb      	ldr	r3, [r7, #12]
    1c48:	429a      	cmp	r2, r3
    1c4a:	d911      	bls.n	1c70 <vTaskDelayUntil+0x8c>
    1c4c:	68fa      	ldr	r2, [r7, #12]
    1c4e:	693b      	ldr	r3, [r7, #16]
    1c50:	429a      	cmp	r2, r3
    1c52:	d90d      	bls.n	1c70 <vTaskDelayUntil+0x8c>
				{
					xShouldDelay = pdTRUE;
    1c54:	2301      	movs	r3, #1
    1c56:	617b      	str	r3, [r7, #20]
    1c58:	e00a      	b.n	1c70 <vTaskDelayUntil+0x8c>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1c5a:	687b      	ldr	r3, [r7, #4]
    1c5c:	681a      	ldr	r2, [r3, #0]
    1c5e:	68fb      	ldr	r3, [r7, #12]
    1c60:	429a      	cmp	r2, r3
    1c62:	d803      	bhi.n	1c6c <vTaskDelayUntil+0x88>
    1c64:	68fa      	ldr	r2, [r7, #12]
    1c66:	693b      	ldr	r3, [r7, #16]
    1c68:	429a      	cmp	r2, r3
    1c6a:	d901      	bls.n	1c70 <vTaskDelayUntil+0x8c>
				{
					xShouldDelay = pdTRUE;
    1c6c:	2301      	movs	r3, #1
    1c6e:	617b      	str	r3, [r7, #20]
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c70:	687b      	ldr	r3, [r7, #4]
    1c72:	68fa      	ldr	r2, [r7, #12]
    1c74:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
    1c76:	697b      	ldr	r3, [r7, #20]
    1c78:	2b00      	cmp	r3, #0
    1c7a:	d008      	beq.n	1c8e <vTaskDelayUntil+0xaa>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1c7c:	4b0b      	ldr	r3, [pc, #44]	; (1cac <vTaskDelayUntil+0xc8>)
    1c7e:	681b      	ldr	r3, [r3, #0]
    1c80:	3304      	adds	r3, #4
    1c82:	4618      	mov	r0, r3
    1c84:	f002 fdf6 	bl	4874 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c88:	68f8      	ldr	r0, [r7, #12]
    1c8a:	f000 ffc1 	bl	2c10 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c8e:	f000 fab1 	bl	21f4 <xTaskResumeAll>
    1c92:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c94:	68bb      	ldr	r3, [r7, #8]
    1c96:	2b00      	cmp	r3, #0
    1c98:	d101      	bne.n	1c9e <vTaskDelayUntil+0xba>
		{
			portYIELD_WITHIN_API();
    1c9a:	f002 fce9 	bl	4670 <vPortYieldFromISR>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1c9e:	3718      	adds	r7, #24
    1ca0:	46bd      	mov	sp, r7
    1ca2:	bd80      	pop	{r7, pc}
    1ca4:	20000124 	.word	0x20000124
    1ca8:	20000104 	.word	0x20000104
    1cac:	20000028 	.word	0x20000028

00001cb0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1cb0:	b580      	push	{r7, lr}
    1cb2:	b084      	sub	sp, #16
    1cb4:	af00      	add	r7, sp, #0
    1cb6:	6078      	str	r0, [r7, #4]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    1cb8:	2300      	movs	r3, #0
    1cba:	60fb      	str	r3, [r7, #12]


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1cbc:	687b      	ldr	r3, [r7, #4]
    1cbe:	2b00      	cmp	r3, #0
    1cc0:	d01b      	beq.n	1cfa <vTaskDelay+0x4a>
		{
			configASSERT( uxSchedulerSuspended == 0 );
    1cc2:	4b12      	ldr	r3, [pc, #72]	; (1d0c <vTaskDelay+0x5c>)
    1cc4:	681b      	ldr	r3, [r3, #0]
    1cc6:	2b00      	cmp	r3, #0
    1cc8:	d004      	beq.n	1cd4 <vTaskDelay+0x24>
    1cca:	f04f 0050 	mov.w	r0, #80	; 0x50
    1cce:	f380 8811 	msr	BASEPRI, r0
    1cd2:	e7fe      	b.n	1cd2 <vTaskDelay+0x22>
			vTaskSuspendAll();
    1cd4:	f000 fa80 	bl	21d8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1cd8:	4b0d      	ldr	r3, [pc, #52]	; (1d10 <vTaskDelay+0x60>)
    1cda:	681a      	ldr	r2, [r3, #0]
    1cdc:	687b      	ldr	r3, [r7, #4]
    1cde:	4413      	add	r3, r2
    1ce0:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1ce2:	4b0c      	ldr	r3, [pc, #48]	; (1d14 <vTaskDelay+0x64>)
    1ce4:	681b      	ldr	r3, [r3, #0]
    1ce6:	3304      	adds	r3, #4
    1ce8:	4618      	mov	r0, r3
    1cea:	f002 fdc3 	bl	4874 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1cee:	68b8      	ldr	r0, [r7, #8]
    1cf0:	f000 ff8e 	bl	2c10 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1cf4:	f000 fa7e 	bl	21f4 <xTaskResumeAll>
    1cf8:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1cfa:	68fb      	ldr	r3, [r7, #12]
    1cfc:	2b00      	cmp	r3, #0
    1cfe:	d101      	bne.n	1d04 <vTaskDelay+0x54>
		{
			portYIELD_WITHIN_API();
    1d00:	f002 fcb6 	bl	4670 <vPortYieldFromISR>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d04:	3710      	adds	r7, #16
    1d06:	46bd      	mov	sp, r7
    1d08:	bd80      	pop	{r7, pc}
    1d0a:	bf00      	nop
    1d0c:	20000124 	.word	0x20000124
    1d10:	20000104 	.word	0x20000104
    1d14:	20000028 	.word	0x20000028

00001d18 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
    1d18:	b580      	push	{r7, lr}
    1d1a:	b084      	sub	sp, #16
    1d1c:	af00      	add	r7, sp, #0
    1d1e:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    1d20:	f002 fc7a 	bl	4618 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1d24:	687b      	ldr	r3, [r7, #4]
    1d26:	2b00      	cmp	r3, #0
    1d28:	d102      	bne.n	1d30 <uxTaskPriorityGet+0x18>
    1d2a:	4b07      	ldr	r3, [pc, #28]	; (1d48 <uxTaskPriorityGet+0x30>)
    1d2c:	681b      	ldr	r3, [r3, #0]
    1d2e:	e000      	b.n	1d32 <uxTaskPriorityGet+0x1a>
    1d30:	687b      	ldr	r3, [r7, #4]
    1d32:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxPriority;
    1d34:	68fb      	ldr	r3, [r7, #12]
    1d36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d38:	60bb      	str	r3, [r7, #8]
		}
		taskEXIT_CRITICAL();
    1d3a:	f002 fc83 	bl	4644 <vPortExitCritical>

		return uxReturn;
    1d3e:	68bb      	ldr	r3, [r7, #8]
	}
    1d40:	4618      	mov	r0, r3
    1d42:	3710      	adds	r7, #16
    1d44:	46bd      	mov	sp, r7
    1d46:	bd80      	pop	{r7, pc}
    1d48:	20000028 	.word	0x20000028

00001d4c <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
    1d4c:	b480      	push	{r7}
    1d4e:	b087      	sub	sp, #28
    1d50:	af00      	add	r7, sp, #0
    1d52:	6078      	str	r0, [r7, #4]
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    1d54:	2300      	movs	r3, #0
    1d56:	617b      	str	r3, [r7, #20]
    1d58:	f04f 0050 	mov.w	r0, #80	; 0x50
    1d5c:	f380 8811 	msr	BASEPRI, r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1d60:	687b      	ldr	r3, [r7, #4]
    1d62:	2b00      	cmp	r3, #0
    1d64:	d102      	bne.n	1d6c <uxTaskPriorityGetFromISR+0x20>
    1d66:	4b09      	ldr	r3, [pc, #36]	; (1d8c <uxTaskPriorityGetFromISR+0x40>)
    1d68:	681b      	ldr	r3, [r3, #0]
    1d6a:	e000      	b.n	1d6e <uxTaskPriorityGetFromISR+0x22>
    1d6c:	687b      	ldr	r3, [r7, #4]
    1d6e:	613b      	str	r3, [r7, #16]
			uxReturn = pxTCB->uxPriority;
    1d70:	693b      	ldr	r3, [r7, #16]
    1d72:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1d74:	60fb      	str	r3, [r7, #12]
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
    1d76:	f04f 0000 	mov.w	r0, #0
    1d7a:	f380 8811 	msr	BASEPRI, r0

		return uxReturn;
    1d7e:	68fb      	ldr	r3, [r7, #12]
	}
    1d80:	4618      	mov	r0, r3
    1d82:	371c      	adds	r7, #28
    1d84:	46bd      	mov	sp, r7
    1d86:	f85d 7b04 	ldr.w	r7, [sp], #4
    1d8a:	4770      	bx	lr
    1d8c:	20000028 	.word	0x20000028

00001d90 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    1d90:	b580      	push	{r7, lr}
    1d92:	b086      	sub	sp, #24
    1d94:	af00      	add	r7, sp, #0
    1d96:	6078      	str	r0, [r7, #4]
    1d98:	6039      	str	r1, [r7, #0]
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1d9a:	2300      	movs	r3, #0
    1d9c:	617b      	str	r3, [r7, #20]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    1d9e:	683b      	ldr	r3, [r7, #0]
    1da0:	2b05      	cmp	r3, #5
    1da2:	d904      	bls.n	1dae <vTaskPrioritySet+0x1e>
    1da4:	f04f 0050 	mov.w	r0, #80	; 0x50
    1da8:	f380 8811 	msr	BASEPRI, r0
    1dac:	e7fe      	b.n	1dac <vTaskPrioritySet+0x1c>

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    1dae:	683b      	ldr	r3, [r7, #0]
    1db0:	2b05      	cmp	r3, #5
    1db2:	d901      	bls.n	1db8 <vTaskPrioritySet+0x28>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    1db4:	2305      	movs	r3, #5
    1db6:	603b      	str	r3, [r7, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    1db8:	f002 fc2e 	bl	4618 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1dbc:	687b      	ldr	r3, [r7, #4]
    1dbe:	2b00      	cmp	r3, #0
    1dc0:	d102      	bne.n	1dc8 <vTaskPrioritySet+0x38>
    1dc2:	4b3a      	ldr	r3, [pc, #232]	; (1eac <vTaskPrioritySet+0x11c>)
    1dc4:	681b      	ldr	r3, [r3, #0]
    1dc6:	e000      	b.n	1dca <vTaskPrioritySet+0x3a>
    1dc8:	687b      	ldr	r3, [r7, #4]
    1dca:	613b      	str	r3, [r7, #16]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1dcc:	693b      	ldr	r3, [r7, #16]
    1dce:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1dd0:	60fb      	str	r3, [r7, #12]
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1dd2:	68fa      	ldr	r2, [r7, #12]
    1dd4:	683b      	ldr	r3, [r7, #0]
    1dd6:	429a      	cmp	r2, r3
    1dd8:	d062      	beq.n	1ea0 <vTaskPrioritySet+0x110>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1dda:	683a      	ldr	r2, [r7, #0]
    1ddc:	68fb      	ldr	r3, [r7, #12]
    1dde:	429a      	cmp	r2, r3
    1de0:	d90d      	bls.n	1dfe <vTaskPrioritySet+0x6e>
				{
					if( pxTCB != pxCurrentTCB )
    1de2:	4b32      	ldr	r3, [pc, #200]	; (1eac <vTaskPrioritySet+0x11c>)
    1de4:	681b      	ldr	r3, [r3, #0]
    1de6:	693a      	ldr	r2, [r7, #16]
    1de8:	429a      	cmp	r2, r3
    1dea:	d00f      	beq.n	1e0c <vTaskPrioritySet+0x7c>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    1dec:	4b2f      	ldr	r3, [pc, #188]	; (1eac <vTaskPrioritySet+0x11c>)
    1dee:	681b      	ldr	r3, [r3, #0]
    1df0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1df2:	683b      	ldr	r3, [r7, #0]
    1df4:	429a      	cmp	r2, r3
    1df6:	d809      	bhi.n	1e0c <vTaskPrioritySet+0x7c>
						{
							xYieldRequired = pdTRUE;
    1df8:	2301      	movs	r3, #1
    1dfa:	617b      	str	r3, [r7, #20]
    1dfc:	e006      	b.n	1e0c <vTaskPrioritySet+0x7c>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    1dfe:	4b2b      	ldr	r3, [pc, #172]	; (1eac <vTaskPrioritySet+0x11c>)
    1e00:	681b      	ldr	r3, [r3, #0]
    1e02:	693a      	ldr	r2, [r7, #16]
    1e04:	429a      	cmp	r2, r3
    1e06:	d101      	bne.n	1e0c <vTaskPrioritySet+0x7c>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    1e08:	2301      	movs	r3, #1
    1e0a:	617b      	str	r3, [r7, #20]
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1e0c:	693b      	ldr	r3, [r7, #16]
    1e0e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1e10:	60bb      	str	r3, [r7, #8]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1e12:	693b      	ldr	r3, [r7, #16]
    1e14:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    1e16:	693b      	ldr	r3, [r7, #16]
    1e18:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    1e1a:	429a      	cmp	r2, r3
    1e1c:	d102      	bne.n	1e24 <vTaskPrioritySet+0x94>
					{
						pxTCB->uxPriority = uxNewPriority;
    1e1e:	693b      	ldr	r3, [r7, #16]
    1e20:	683a      	ldr	r2, [r7, #0]
    1e22:	62da      	str	r2, [r3, #44]	; 0x2c
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    1e24:	693b      	ldr	r3, [r7, #16]
    1e26:	683a      	ldr	r2, [r7, #0]
    1e28:	649a      	str	r2, [r3, #72]	; 0x48
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1e2a:	693b      	ldr	r3, [r7, #16]
    1e2c:	699b      	ldr	r3, [r3, #24]
    1e2e:	2b00      	cmp	r3, #0
    1e30:	db04      	blt.n	1e3c <vTaskPrioritySet+0xac>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e32:	683b      	ldr	r3, [r7, #0]
    1e34:	f1c3 0206 	rsb	r2, r3, #6
    1e38:	693b      	ldr	r3, [r7, #16]
    1e3a:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1e3c:	693b      	ldr	r3, [r7, #16]
    1e3e:	6959      	ldr	r1, [r3, #20]
    1e40:	68ba      	ldr	r2, [r7, #8]
    1e42:	4613      	mov	r3, r2
    1e44:	009b      	lsls	r3, r3, #2
    1e46:	4413      	add	r3, r2
    1e48:	009b      	lsls	r3, r3, #2
    1e4a:	4a19      	ldr	r2, [pc, #100]	; (1eb0 <vTaskPrioritySet+0x120>)
    1e4c:	4413      	add	r3, r2
    1e4e:	4299      	cmp	r1, r3
    1e50:	d101      	bne.n	1e56 <vTaskPrioritySet+0xc6>
    1e52:	2301      	movs	r3, #1
    1e54:	e000      	b.n	1e58 <vTaskPrioritySet+0xc8>
    1e56:	2300      	movs	r3, #0
    1e58:	2b00      	cmp	r3, #0
    1e5a:	d01c      	beq.n	1e96 <vTaskPrioritySet+0x106>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1e5c:	693b      	ldr	r3, [r7, #16]
    1e5e:	3304      	adds	r3, #4
    1e60:	4618      	mov	r0, r3
    1e62:	f002 fd07 	bl	4874 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
					prvReAddTaskToReadyList( pxTCB );
#else
					prvAddTaskToReadyList( pxTCB );
    1e66:	693b      	ldr	r3, [r7, #16]
    1e68:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1e6a:	4b12      	ldr	r3, [pc, #72]	; (1eb4 <vTaskPrioritySet+0x124>)
    1e6c:	681b      	ldr	r3, [r3, #0]
    1e6e:	429a      	cmp	r2, r3
    1e70:	d903      	bls.n	1e7a <vTaskPrioritySet+0xea>
    1e72:	693b      	ldr	r3, [r7, #16]
    1e74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1e76:	4b0f      	ldr	r3, [pc, #60]	; (1eb4 <vTaskPrioritySet+0x124>)
    1e78:	601a      	str	r2, [r3, #0]
    1e7a:	693b      	ldr	r3, [r7, #16]
    1e7c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1e7e:	4613      	mov	r3, r2
    1e80:	009b      	lsls	r3, r3, #2
    1e82:	4413      	add	r3, r2
    1e84:	009b      	lsls	r3, r3, #2
    1e86:	4a0a      	ldr	r2, [pc, #40]	; (1eb0 <vTaskPrioritySet+0x120>)
    1e88:	441a      	add	r2, r3
    1e8a:	693b      	ldr	r3, [r7, #16]
    1e8c:	3304      	adds	r3, #4
    1e8e:	4610      	mov	r0, r2
    1e90:	4619      	mov	r1, r3
    1e92:	f002 fc93 	bl	47bc <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired == pdTRUE )
    1e96:	697b      	ldr	r3, [r7, #20]
    1e98:	2b01      	cmp	r3, #1
    1e9a:	d101      	bne.n	1ea0 <vTaskPrioritySet+0x110>
				{
					taskYIELD_IF_USING_PREEMPTION();
    1e9c:	f002 fbe8 	bl	4670 <vPortYieldFromISR>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    1ea0:	f002 fbd0 	bl	4644 <vPortExitCritical>
	}
    1ea4:	3718      	adds	r7, #24
    1ea6:	46bd      	mov	sp, r7
    1ea8:	bd80      	pop	{r7, pc}
    1eaa:	bf00      	nop
    1eac:	20000028 	.word	0x20000028
    1eb0:	2000002c 	.word	0x2000002c
    1eb4:	20000108 	.word	0x20000108

00001eb8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    1eb8:	b580      	push	{r7, lr}
    1eba:	b084      	sub	sp, #16
    1ebc:	af00      	add	r7, sp, #0
    1ebe:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1ec0:	f002 fbaa 	bl	4618 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    1ec4:	687b      	ldr	r3, [r7, #4]
    1ec6:	2b00      	cmp	r3, #0
    1ec8:	d102      	bne.n	1ed0 <vTaskSuspend+0x18>
    1eca:	4b25      	ldr	r3, [pc, #148]	; (1f60 <vTaskSuspend+0xa8>)
    1ecc:	681b      	ldr	r3, [r3, #0]
    1ece:	e000      	b.n	1ed2 <vTaskSuspend+0x1a>
    1ed0:	687b      	ldr	r3, [r7, #4]
    1ed2:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1ed4:	68fb      	ldr	r3, [r7, #12]
    1ed6:	3304      	adds	r3, #4
    1ed8:	4618      	mov	r0, r3
    1eda:	f002 fccb 	bl	4874 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1ede:	68fb      	ldr	r3, [r7, #12]
    1ee0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1ee2:	2b00      	cmp	r3, #0
    1ee4:	d004      	beq.n	1ef0 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1ee6:	68fb      	ldr	r3, [r7, #12]
    1ee8:	3318      	adds	r3, #24
    1eea:	4618      	mov	r0, r3
    1eec:	f002 fcc2 	bl	4874 <uxListRemove>
				mtCOVERAGE_TEST_MARKER();
			}
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
			traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
#endif
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    1ef0:	68fb      	ldr	r3, [r7, #12]
    1ef2:	3304      	adds	r3, #4
    1ef4:	481b      	ldr	r0, [pc, #108]	; (1f64 <vTaskSuspend+0xac>)
    1ef6:	4619      	mov	r1, r3
    1ef8:	f002 fc60 	bl	47bc <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1efc:	f002 fba2 	bl	4644 <vPortExitCritical>

		if( pxTCB == pxCurrentTCB )
    1f00:	4b17      	ldr	r3, [pc, #92]	; (1f60 <vTaskSuspend+0xa8>)
    1f02:	681b      	ldr	r3, [r3, #0]
    1f04:	68fa      	ldr	r2, [r7, #12]
    1f06:	429a      	cmp	r2, r3
    1f08:	d11c      	bne.n	1f44 <vTaskSuspend+0x8c>
		{
			if( xSchedulerRunning != pdFALSE )
    1f0a:	4b17      	ldr	r3, [pc, #92]	; (1f68 <vTaskSuspend+0xb0>)
    1f0c:	681b      	ldr	r3, [r3, #0]
    1f0e:	2b00      	cmp	r3, #0
    1f10:	d00b      	beq.n	1f2a <vTaskSuspend+0x72>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
    1f12:	4b16      	ldr	r3, [pc, #88]	; (1f6c <vTaskSuspend+0xb4>)
    1f14:	681b      	ldr	r3, [r3, #0]
    1f16:	2b00      	cmp	r3, #0
    1f18:	d004      	beq.n	1f24 <vTaskSuspend+0x6c>
    1f1a:	f04f 0050 	mov.w	r0, #80	; 0x50
    1f1e:	f380 8811 	msr	BASEPRI, r0
    1f22:	e7fe      	b.n	1f22 <vTaskSuspend+0x6a>
				portYIELD_WITHIN_API();
    1f24:	f002 fba4 	bl	4670 <vPortYieldFromISR>
    1f28:	e016      	b.n	1f58 <vTaskSuspend+0xa0>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1f2a:	4b0e      	ldr	r3, [pc, #56]	; (1f64 <vTaskSuspend+0xac>)
    1f2c:	681a      	ldr	r2, [r3, #0]
    1f2e:	4b10      	ldr	r3, [pc, #64]	; (1f70 <vTaskSuspend+0xb8>)
    1f30:	681b      	ldr	r3, [r3, #0]
    1f32:	429a      	cmp	r2, r3
    1f34:	d103      	bne.n	1f3e <vTaskSuspend+0x86>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1f36:	4b0a      	ldr	r3, [pc, #40]	; (1f60 <vTaskSuspend+0xa8>)
    1f38:	2200      	movs	r2, #0
    1f3a:	601a      	str	r2, [r3, #0]
    1f3c:	e00c      	b.n	1f58 <vTaskSuspend+0xa0>
				}
				else
				{
					vTaskSwitchContext();
    1f3e:	f000 fb7b 	bl	2638 <vTaskSwitchContext>
    1f42:	e009      	b.n	1f58 <vTaskSuspend+0xa0>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    1f44:	4b08      	ldr	r3, [pc, #32]	; (1f68 <vTaskSuspend+0xb0>)
    1f46:	681b      	ldr	r3, [r3, #0]
    1f48:	2b00      	cmp	r3, #0
    1f4a:	d005      	beq.n	1f58 <vTaskSuspend+0xa0>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    1f4c:	f002 fb64 	bl	4618 <vPortEnterCritical>
				{
					prvResetNextTaskUnblockTime();
    1f50:	f000 ff90 	bl	2e74 <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    1f54:	f002 fb76 	bl	4644 <vPortExitCritical>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1f58:	3710      	adds	r7, #16
    1f5a:	46bd      	mov	sp, r7
    1f5c:	bd80      	pop	{r7, pc}
    1f5e:	bf00      	nop
    1f60:	20000028 	.word	0x20000028
    1f64:	200000e8 	.word	0x200000e8
    1f68:	2000010c 	.word	0x2000010c
    1f6c:	20000124 	.word	0x20000124
    1f70:	20000100 	.word	0x20000100

00001f74 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    1f74:	b480      	push	{r7}
    1f76:	b085      	sub	sp, #20
    1f78:	af00      	add	r7, sp, #0
    1f7a:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn = pdFALSE;
    1f7c:	2300      	movs	r3, #0
    1f7e:	60fb      	str	r3, [r7, #12]
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    1f80:	687b      	ldr	r3, [r7, #4]
    1f82:	60bb      	str	r3, [r7, #8]

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
    1f84:	687b      	ldr	r3, [r7, #4]
    1f86:	2b00      	cmp	r3, #0
    1f88:	d104      	bne.n	1f94 <prvTaskIsTaskSuspended+0x20>
    1f8a:	f04f 0050 	mov.w	r0, #80	; 0x50
    1f8e:	f380 8811 	msr	BASEPRI, r0
    1f92:	e7fe      	b.n	1f92 <prvTaskIsTaskSuspended+0x1e>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1f94:	68bb      	ldr	r3, [r7, #8]
    1f96:	695a      	ldr	r2, [r3, #20]
    1f98:	4b0f      	ldr	r3, [pc, #60]	; (1fd8 <prvTaskIsTaskSuspended+0x64>)
    1f9a:	429a      	cmp	r2, r3
    1f9c:	d101      	bne.n	1fa2 <prvTaskIsTaskSuspended+0x2e>
    1f9e:	2301      	movs	r3, #1
    1fa0:	e000      	b.n	1fa4 <prvTaskIsTaskSuspended+0x30>
    1fa2:	2300      	movs	r3, #0
    1fa4:	2b00      	cmp	r3, #0
    1fa6:	d00f      	beq.n	1fc8 <prvTaskIsTaskSuspended+0x54>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    1fa8:	68bb      	ldr	r3, [r7, #8]
    1faa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1fac:	4b0b      	ldr	r3, [pc, #44]	; (1fdc <prvTaskIsTaskSuspended+0x68>)
    1fae:	429a      	cmp	r2, r3
    1fb0:	d00a      	beq.n	1fc8 <prvTaskIsTaskSuspended+0x54>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    1fb2:	68bb      	ldr	r3, [r7, #8]
    1fb4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1fb6:	2b00      	cmp	r3, #0
    1fb8:	d101      	bne.n	1fbe <prvTaskIsTaskSuspended+0x4a>
    1fba:	2301      	movs	r3, #1
    1fbc:	e000      	b.n	1fc0 <prvTaskIsTaskSuspended+0x4c>
    1fbe:	2300      	movs	r3, #0
    1fc0:	2b00      	cmp	r3, #0
    1fc2:	d001      	beq.n	1fc8 <prvTaskIsTaskSuspended+0x54>
				{
					xReturn = pdTRUE;
    1fc4:	2301      	movs	r3, #1
    1fc6:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    1fc8:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1fca:	4618      	mov	r0, r3
    1fcc:	3714      	adds	r7, #20
    1fce:	46bd      	mov	sp, r7
    1fd0:	f85d 7b04 	ldr.w	r7, [sp], #4
    1fd4:	4770      	bx	lr
    1fd6:	bf00      	nop
    1fd8:	200000e8 	.word	0x200000e8
    1fdc:	200000d4 	.word	0x200000d4

00001fe0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    1fe0:	b580      	push	{r7, lr}
    1fe2:	b084      	sub	sp, #16
    1fe4:	af00      	add	r7, sp, #0
    1fe6:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    1fe8:	687b      	ldr	r3, [r7, #4]
    1fea:	60fb      	str	r3, [r7, #12]

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
    1fec:	687b      	ldr	r3, [r7, #4]
    1fee:	2b00      	cmp	r3, #0
    1ff0:	d104      	bne.n	1ffc <vTaskResume+0x1c>
    1ff2:	f04f 0050 	mov.w	r0, #80	; 0x50
    1ff6:	f380 8811 	msr	BASEPRI, r0
    1ffa:	e7fe      	b.n	1ffa <vTaskResume+0x1a>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1ffc:	68fb      	ldr	r3, [r7, #12]
    1ffe:	2b00      	cmp	r3, #0
    2000:	d034      	beq.n	206c <vTaskResume+0x8c>
    2002:	4b1c      	ldr	r3, [pc, #112]	; (2074 <vTaskResume+0x94>)
    2004:	681b      	ldr	r3, [r3, #0]
    2006:	68fa      	ldr	r2, [r7, #12]
    2008:	429a      	cmp	r2, r3
    200a:	d02f      	beq.n	206c <vTaskResume+0x8c>
		{
			taskENTER_CRITICAL();
    200c:	f002 fb04 	bl	4618 <vPortEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2010:	68f8      	ldr	r0, [r7, #12]
    2012:	f7ff ffaf 	bl	1f74 <prvTaskIsTaskSuspended>
    2016:	4603      	mov	r3, r0
    2018:	2b01      	cmp	r3, #1
    201a:	d125      	bne.n	2068 <vTaskResume+0x88>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    201c:	68fb      	ldr	r3, [r7, #12]
    201e:	3304      	adds	r3, #4
    2020:	4618      	mov	r0, r3
    2022:	f002 fc27 	bl	4874 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2026:	68fb      	ldr	r3, [r7, #12]
    2028:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    202a:	4b13      	ldr	r3, [pc, #76]	; (2078 <vTaskResume+0x98>)
    202c:	681b      	ldr	r3, [r3, #0]
    202e:	429a      	cmp	r2, r3
    2030:	d903      	bls.n	203a <vTaskResume+0x5a>
    2032:	68fb      	ldr	r3, [r7, #12]
    2034:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2036:	4b10      	ldr	r3, [pc, #64]	; (2078 <vTaskResume+0x98>)
    2038:	601a      	str	r2, [r3, #0]
    203a:	68fb      	ldr	r3, [r7, #12]
    203c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    203e:	4613      	mov	r3, r2
    2040:	009b      	lsls	r3, r3, #2
    2042:	4413      	add	r3, r2
    2044:	009b      	lsls	r3, r3, #2
    2046:	4a0d      	ldr	r2, [pc, #52]	; (207c <vTaskResume+0x9c>)
    2048:	441a      	add	r2, r3
    204a:	68fb      	ldr	r3, [r7, #12]
    204c:	3304      	adds	r3, #4
    204e:	4610      	mov	r0, r2
    2050:	4619      	mov	r1, r3
    2052:	f002 fbb3 	bl	47bc <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2056:	68fb      	ldr	r3, [r7, #12]
    2058:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    205a:	4b06      	ldr	r3, [pc, #24]	; (2074 <vTaskResume+0x94>)
    205c:	681b      	ldr	r3, [r3, #0]
    205e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2060:	429a      	cmp	r2, r3
    2062:	d301      	bcc.n	2068 <vTaskResume+0x88>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    2064:	f002 fb04 	bl	4670 <vPortYieldFromISR>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2068:	f002 faec 	bl	4644 <vPortExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    206c:	3710      	adds	r7, #16
    206e:	46bd      	mov	sp, r7
    2070:	bd80      	pop	{r7, pc}
    2072:	bf00      	nop
    2074:	20000028 	.word	0x20000028
    2078:	20000108 	.word	0x20000108
    207c:	2000002c 	.word	0x2000002c

00002080 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    2080:	b580      	push	{r7, lr}
    2082:	b086      	sub	sp, #24
    2084:	af00      	add	r7, sp, #0
    2086:	6078      	str	r0, [r7, #4]
	BaseType_t xYieldRequired = pdFALSE;
    2088:	2300      	movs	r3, #0
    208a:	617b      	str	r3, [r7, #20]
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    208c:	687b      	ldr	r3, [r7, #4]
    208e:	613b      	str	r3, [r7, #16]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
    2090:	687b      	ldr	r3, [r7, #4]
    2092:	2b00      	cmp	r3, #0
    2094:	d104      	bne.n	20a0 <xTaskResumeFromISR+0x20>
    2096:	f04f 0050 	mov.w	r0, #80	; 0x50
    209a:	f380 8811 	msr	BASEPRI, r0
    209e:	e7fe      	b.n	209e <xTaskResumeFromISR+0x1e>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    20a0:	2300      	movs	r3, #0
    20a2:	60fb      	str	r3, [r7, #12]
    20a4:	f04f 0050 	mov.w	r0, #80	; 0x50
    20a8:	f380 8811 	msr	BASEPRI, r0
		{
			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    20ac:	6938      	ldr	r0, [r7, #16]
    20ae:	f7ff ff61 	bl	1f74 <prvTaskIsTaskSuspended>
    20b2:	4603      	mov	r3, r0
    20b4:	2b01      	cmp	r3, #1
    20b6:	d130      	bne.n	211a <xTaskResumeFromISR+0x9a>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    20b8:	4b1c      	ldr	r3, [pc, #112]	; (212c <xTaskResumeFromISR+0xac>)
    20ba:	681b      	ldr	r3, [r3, #0]
    20bc:	2b00      	cmp	r3, #0
    20be:	d126      	bne.n	210e <xTaskResumeFromISR+0x8e>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20c0:	693b      	ldr	r3, [r7, #16]
    20c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    20c4:	4b1a      	ldr	r3, [pc, #104]	; (2130 <xTaskResumeFromISR+0xb0>)
    20c6:	681b      	ldr	r3, [r3, #0]
    20c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    20ca:	429a      	cmp	r2, r3
    20cc:	d301      	bcc.n	20d2 <xTaskResumeFromISR+0x52>
					{
						xYieldRequired = pdTRUE;
    20ce:	2301      	movs	r3, #1
    20d0:	617b      	str	r3, [r7, #20]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    20d2:	693b      	ldr	r3, [r7, #16]
    20d4:	3304      	adds	r3, #4
    20d6:	4618      	mov	r0, r3
    20d8:	f002 fbcc 	bl	4874 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    20dc:	693b      	ldr	r3, [r7, #16]
    20de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    20e0:	4b14      	ldr	r3, [pc, #80]	; (2134 <xTaskResumeFromISR+0xb4>)
    20e2:	681b      	ldr	r3, [r3, #0]
    20e4:	429a      	cmp	r2, r3
    20e6:	d903      	bls.n	20f0 <xTaskResumeFromISR+0x70>
    20e8:	693b      	ldr	r3, [r7, #16]
    20ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    20ec:	4b11      	ldr	r3, [pc, #68]	; (2134 <xTaskResumeFromISR+0xb4>)
    20ee:	601a      	str	r2, [r3, #0]
    20f0:	693b      	ldr	r3, [r7, #16]
    20f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    20f4:	4613      	mov	r3, r2
    20f6:	009b      	lsls	r3, r3, #2
    20f8:	4413      	add	r3, r2
    20fa:	009b      	lsls	r3, r3, #2
    20fc:	4a0e      	ldr	r2, [pc, #56]	; (2138 <xTaskResumeFromISR+0xb8>)
    20fe:	441a      	add	r2, r3
    2100:	693b      	ldr	r3, [r7, #16]
    2102:	3304      	adds	r3, #4
    2104:	4610      	mov	r0, r2
    2106:	4619      	mov	r1, r3
    2108:	f002 fb58 	bl	47bc <vListInsertEnd>
    210c:	e005      	b.n	211a <xTaskResumeFromISR+0x9a>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    210e:	693b      	ldr	r3, [r7, #16]
    2110:	3318      	adds	r3, #24
    2112:	480a      	ldr	r0, [pc, #40]	; (213c <xTaskResumeFromISR+0xbc>)
    2114:	4619      	mov	r1, r3
    2116:	f002 fb51 	bl	47bc <vListInsertEnd>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    211a:	f04f 0000 	mov.w	r0, #0
    211e:	f380 8811 	msr	BASEPRI, r0

		return xYieldRequired;
    2122:	697b      	ldr	r3, [r7, #20]
	}
    2124:	4618      	mov	r0, r3
    2126:	3718      	adds	r7, #24
    2128:	46bd      	mov	sp, r7
    212a:	bd80      	pop	{r7, pc}
    212c:	20000124 	.word	0x20000124
    2130:	20000028 	.word	0x20000028
    2134:	20000108 	.word	0x20000108
    2138:	2000002c 	.word	0x2000002c
    213c:	200000d4 	.word	0x200000d4

00002140 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2140:	b580      	push	{r7, lr}
    2142:	b086      	sub	sp, #24
    2144:	af04      	add	r7, sp, #16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    2146:	2300      	movs	r3, #0
    2148:	9300      	str	r3, [sp, #0]
    214a:	4b16      	ldr	r3, [pc, #88]	; (21a4 <vTaskStartScheduler+0x64>)
    214c:	9301      	str	r3, [sp, #4]
    214e:	2300      	movs	r3, #0
    2150:	9302      	str	r3, [sp, #8]
    2152:	2300      	movs	r3, #0
    2154:	9303      	str	r3, [sp, #12]
    2156:	4814      	ldr	r0, [pc, #80]	; (21a8 <vTaskStartScheduler+0x68>)
    2158:	4914      	ldr	r1, [pc, #80]	; (21ac <vTaskStartScheduler+0x6c>)
    215a:	22c8      	movs	r2, #200	; 0xc8
    215c:	2300      	movs	r3, #0
    215e:	f7ff fc87 	bl	1a70 <xTaskGenericCreate>
    2162:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2164:	687b      	ldr	r3, [r7, #4]
    2166:	2b01      	cmp	r3, #1
    2168:	d110      	bne.n	218c <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    216a:	f04f 0050 	mov.w	r0, #80	; 0x50
    216e:	f380 8811 	msr	BASEPRI, r0
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    2172:	4b0f      	ldr	r3, [pc, #60]	; (21b0 <vTaskStartScheduler+0x70>)
    2174:	f04f 32ff 	mov.w	r2, #4294967295
    2178:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
    217a:	4b0e      	ldr	r3, [pc, #56]	; (21b4 <vTaskStartScheduler+0x74>)
    217c:	2201      	movs	r2, #1
    217e:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
    2180:	4b0d      	ldr	r3, [pc, #52]	; (21b8 <vTaskStartScheduler+0x78>)
    2182:	2200      	movs	r2, #0
    2184:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2186:	f002 fa11 	bl	45ac <xPortStartScheduler>
    218a:	e007      	b.n	219c <vTaskStartScheduler+0x5c>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
    218c:	687b      	ldr	r3, [r7, #4]
    218e:	2b00      	cmp	r3, #0
    2190:	d104      	bne.n	219c <vTaskStartScheduler+0x5c>
    2192:	f04f 0050 	mov.w	r0, #80	; 0x50
    2196:	f380 8811 	msr	BASEPRI, r0
    219a:	e7fe      	b.n	219a <vTaskStartScheduler+0x5a>
	}
}
    219c:	3708      	adds	r7, #8
    219e:	46bd      	mov	sp, r7
    21a0:	bd80      	pop	{r7, pc}
    21a2:	bf00      	nop
    21a4:	200000fc 	.word	0x200000fc
    21a8:	00002ac9 	.word	0x00002ac9
    21ac:	000073f4 	.word	0x000073f4
    21b0:	20000120 	.word	0x20000120
    21b4:	2000010c 	.word	0x2000010c
    21b8:	20000104 	.word	0x20000104

000021bc <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    21bc:	b580      	push	{r7, lr}
    21be:	af00      	add	r7, sp, #0
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    21c0:	f04f 0050 	mov.w	r0, #80	; 0x50
    21c4:	f380 8811 	msr	BASEPRI, r0
	xSchedulerRunning = pdFALSE;
    21c8:	4b02      	ldr	r3, [pc, #8]	; (21d4 <vTaskEndScheduler+0x18>)
    21ca:	2200      	movs	r2, #0
    21cc:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
    21ce:	f002 fa19 	bl	4604 <vPortEndScheduler>
}
    21d2:	bd80      	pop	{r7, pc}
    21d4:	2000010c 	.word	0x2000010c

000021d8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    21d8:	b480      	push	{r7}
    21da:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    21dc:	4b04      	ldr	r3, [pc, #16]	; (21f0 <vTaskSuspendAll+0x18>)
    21de:	681b      	ldr	r3, [r3, #0]
    21e0:	1c5a      	adds	r2, r3, #1
    21e2:	4b03      	ldr	r3, [pc, #12]	; (21f0 <vTaskSuspendAll+0x18>)
    21e4:	601a      	str	r2, [r3, #0]
}
    21e6:	46bd      	mov	sp, r7
    21e8:	f85d 7b04 	ldr.w	r7, [sp], #4
    21ec:	4770      	bx	lr
    21ee:	bf00      	nop
    21f0:	20000124 	.word	0x20000124

000021f4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    21f4:	b580      	push	{r7, lr}
    21f6:	b082      	sub	sp, #8
    21f8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    21fa:	2300      	movs	r3, #0
    21fc:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
    21fe:	4b39      	ldr	r3, [pc, #228]	; (22e4 <xTaskResumeAll+0xf0>)
    2200:	681b      	ldr	r3, [r3, #0]
    2202:	2b00      	cmp	r3, #0
    2204:	d104      	bne.n	2210 <xTaskResumeAll+0x1c>
    2206:	f04f 0050 	mov.w	r0, #80	; 0x50
    220a:	f380 8811 	msr	BASEPRI, r0
    220e:	e7fe      	b.n	220e <xTaskResumeAll+0x1a>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2210:	f002 fa02 	bl	4618 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
    2214:	4b33      	ldr	r3, [pc, #204]	; (22e4 <xTaskResumeAll+0xf0>)
    2216:	681b      	ldr	r3, [r3, #0]
    2218:	1e5a      	subs	r2, r3, #1
    221a:	4b32      	ldr	r3, [pc, #200]	; (22e4 <xTaskResumeAll+0xf0>)
    221c:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    221e:	4b31      	ldr	r3, [pc, #196]	; (22e4 <xTaskResumeAll+0xf0>)
    2220:	681b      	ldr	r3, [r3, #0]
    2222:	2b00      	cmp	r3, #0
    2224:	d156      	bne.n	22d4 <xTaskResumeAll+0xe0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2226:	4b30      	ldr	r3, [pc, #192]	; (22e8 <xTaskResumeAll+0xf4>)
    2228:	681b      	ldr	r3, [r3, #0]
    222a:	2b00      	cmp	r3, #0
    222c:	d052      	beq.n	22d4 <xTaskResumeAll+0xe0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    222e:	e02f      	b.n	2290 <xTaskResumeAll+0x9c>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2230:	4b2e      	ldr	r3, [pc, #184]	; (22ec <xTaskResumeAll+0xf8>)
    2232:	68db      	ldr	r3, [r3, #12]
    2234:	68db      	ldr	r3, [r3, #12]
    2236:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2238:	683b      	ldr	r3, [r7, #0]
    223a:	3318      	adds	r3, #24
    223c:	4618      	mov	r0, r3
    223e:	f002 fb19 	bl	4874 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2242:	683b      	ldr	r3, [r7, #0]
    2244:	3304      	adds	r3, #4
    2246:	4618      	mov	r0, r3
    2248:	f002 fb14 	bl	4874 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    224c:	683b      	ldr	r3, [r7, #0]
    224e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2250:	4b27      	ldr	r3, [pc, #156]	; (22f0 <xTaskResumeAll+0xfc>)
    2252:	681b      	ldr	r3, [r3, #0]
    2254:	429a      	cmp	r2, r3
    2256:	d903      	bls.n	2260 <xTaskResumeAll+0x6c>
    2258:	683b      	ldr	r3, [r7, #0]
    225a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    225c:	4b24      	ldr	r3, [pc, #144]	; (22f0 <xTaskResumeAll+0xfc>)
    225e:	601a      	str	r2, [r3, #0]
    2260:	683b      	ldr	r3, [r7, #0]
    2262:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2264:	4613      	mov	r3, r2
    2266:	009b      	lsls	r3, r3, #2
    2268:	4413      	add	r3, r2
    226a:	009b      	lsls	r3, r3, #2
    226c:	4a21      	ldr	r2, [pc, #132]	; (22f4 <xTaskResumeAll+0x100>)
    226e:	441a      	add	r2, r3
    2270:	683b      	ldr	r3, [r7, #0]
    2272:	3304      	adds	r3, #4
    2274:	4610      	mov	r0, r2
    2276:	4619      	mov	r1, r3
    2278:	f002 faa0 	bl	47bc <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    227c:	683b      	ldr	r3, [r7, #0]
    227e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2280:	4b1d      	ldr	r3, [pc, #116]	; (22f8 <xTaskResumeAll+0x104>)
    2282:	681b      	ldr	r3, [r3, #0]
    2284:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2286:	429a      	cmp	r2, r3
    2288:	d302      	bcc.n	2290 <xTaskResumeAll+0x9c>
					{
						xYieldPending = pdTRUE;
    228a:	4b1c      	ldr	r3, [pc, #112]	; (22fc <xTaskResumeAll+0x108>)
    228c:	2201      	movs	r2, #1
    228e:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2290:	4b16      	ldr	r3, [pc, #88]	; (22ec <xTaskResumeAll+0xf8>)
    2292:	681b      	ldr	r3, [r3, #0]
    2294:	2b00      	cmp	r3, #0
    2296:	d1cb      	bne.n	2230 <xTaskResumeAll+0x3c>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    2298:	4b19      	ldr	r3, [pc, #100]	; (2300 <xTaskResumeAll+0x10c>)
    229a:	681b      	ldr	r3, [r3, #0]
    229c:	2b00      	cmp	r3, #0
    229e:	d011      	beq.n	22c4 <xTaskResumeAll+0xd0>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    22a0:	e00c      	b.n	22bc <xTaskResumeAll+0xc8>
					{
						if( xTaskIncrementTick() != pdFALSE )
    22a2:	f000 f907 	bl	24b4 <xTaskIncrementTick>
    22a6:	4603      	mov	r3, r0
    22a8:	2b00      	cmp	r3, #0
    22aa:	d002      	beq.n	22b2 <xTaskResumeAll+0xbe>
						{
							xYieldPending = pdTRUE;
    22ac:	4b13      	ldr	r3, [pc, #76]	; (22fc <xTaskResumeAll+0x108>)
    22ae:	2201      	movs	r2, #1
    22b0:	601a      	str	r2, [r3, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    22b2:	4b13      	ldr	r3, [pc, #76]	; (2300 <xTaskResumeAll+0x10c>)
    22b4:	681b      	ldr	r3, [r3, #0]
    22b6:	1e5a      	subs	r2, r3, #1
    22b8:	4b11      	ldr	r3, [pc, #68]	; (2300 <xTaskResumeAll+0x10c>)
    22ba:	601a      	str	r2, [r3, #0]
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    22bc:	4b10      	ldr	r3, [pc, #64]	; (2300 <xTaskResumeAll+0x10c>)
    22be:	681b      	ldr	r3, [r3, #0]
    22c0:	2b00      	cmp	r3, #0
    22c2:	d1ee      	bne.n	22a2 <xTaskResumeAll+0xae>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    22c4:	4b0d      	ldr	r3, [pc, #52]	; (22fc <xTaskResumeAll+0x108>)
    22c6:	681b      	ldr	r3, [r3, #0]
    22c8:	2b01      	cmp	r3, #1
    22ca:	d103      	bne.n	22d4 <xTaskResumeAll+0xe0>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    22cc:	2301      	movs	r3, #1
    22ce:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    22d0:	f002 f9ce 	bl	4670 <vPortYieldFromISR>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    22d4:	f002 f9b6 	bl	4644 <vPortExitCritical>

	return xAlreadyYielded;
    22d8:	687b      	ldr	r3, [r7, #4]
}
    22da:	4618      	mov	r0, r3
    22dc:	3708      	adds	r7, #8
    22de:	46bd      	mov	sp, r7
    22e0:	bd80      	pop	{r7, pc}
    22e2:	bf00      	nop
    22e4:	20000124 	.word	0x20000124
    22e8:	20000100 	.word	0x20000100
    22ec:	200000d4 	.word	0x200000d4
    22f0:	20000108 	.word	0x20000108
    22f4:	2000002c 	.word	0x2000002c
    22f8:	20000028 	.word	0x20000028
    22fc:	20000114 	.word	0x20000114
    2300:	20000110 	.word	0x20000110

00002304 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2304:	b580      	push	{r7, lr}
    2306:	b082      	sub	sp, #8
    2308:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    230a:	f002 f985 	bl	4618 <vPortEnterCritical>
	{
		xTicks = xTickCount;
    230e:	4b05      	ldr	r3, [pc, #20]	; (2324 <xTaskGetTickCount+0x20>)
    2310:	681b      	ldr	r3, [r3, #0]
    2312:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2314:	f002 f996 	bl	4644 <vPortExitCritical>

	return xTicks;
    2318:	687b      	ldr	r3, [r7, #4]
}
    231a:	4618      	mov	r0, r3
    231c:	3708      	adds	r7, #8
    231e:	46bd      	mov	sp, r7
    2320:	bd80      	pop	{r7, pc}
    2322:	bf00      	nop
    2324:	20000104 	.word	0x20000104

00002328 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2328:	b480      	push	{r7}
    232a:	b083      	sub	sp, #12
    232c:	af00      	add	r7, sp, #0
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    232e:	2300      	movs	r3, #0
    2330:	607b      	str	r3, [r7, #4]
    2332:	f04f 0050 	mov.w	r0, #80	; 0x50
    2336:	f380 8811 	msr	BASEPRI, r0
	{
		xReturn = xTickCount;
    233a:	4b07      	ldr	r3, [pc, #28]	; (2358 <xTaskGetTickCountFromISR+0x30>)
    233c:	681b      	ldr	r3, [r3, #0]
    233e:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    2340:	f04f 0000 	mov.w	r0, #0
    2344:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    2348:	683b      	ldr	r3, [r7, #0]
}
    234a:	4618      	mov	r0, r3
    234c:	370c      	adds	r7, #12
    234e:	46bd      	mov	sp, r7
    2350:	f85d 7b04 	ldr.w	r7, [sp], #4
    2354:	4770      	bx	lr
    2356:	bf00      	nop
    2358:	20000104 	.word	0x20000104

0000235c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    235c:	b480      	push	{r7}
    235e:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    2360:	4b03      	ldr	r3, [pc, #12]	; (2370 <uxTaskGetNumberOfTasks+0x14>)
    2362:	681b      	ldr	r3, [r3, #0]
}
    2364:	4618      	mov	r0, r3
    2366:	46bd      	mov	sp, r7
    2368:	f85d 7b04 	ldr.w	r7, [sp], #4
    236c:	4770      	bx	lr
    236e:	bf00      	nop
    2370:	20000100 	.word	0x20000100

00002374 <pcTaskGetTaskName>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_pcTaskGetTaskName == 1 )

	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    2374:	b480      	push	{r7}
    2376:	b085      	sub	sp, #20
    2378:	af00      	add	r7, sp, #0
    237a:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    237c:	687b      	ldr	r3, [r7, #4]
    237e:	2b00      	cmp	r3, #0
    2380:	d102      	bne.n	2388 <pcTaskGetTaskName+0x14>
    2382:	4b0a      	ldr	r3, [pc, #40]	; (23ac <pcTaskGetTaskName+0x38>)
    2384:	681b      	ldr	r3, [r3, #0]
    2386:	e000      	b.n	238a <pcTaskGetTaskName+0x16>
    2388:	687b      	ldr	r3, [r7, #4]
    238a:	60fb      	str	r3, [r7, #12]
		configASSERT( pxTCB );
    238c:	68fb      	ldr	r3, [r7, #12]
    238e:	2b00      	cmp	r3, #0
    2390:	d104      	bne.n	239c <pcTaskGetTaskName+0x28>
    2392:	f04f 0050 	mov.w	r0, #80	; 0x50
    2396:	f380 8811 	msr	BASEPRI, r0
    239a:	e7fe      	b.n	239a <pcTaskGetTaskName+0x26>
		return &( pxTCB->pcTaskName[ 0 ] );
    239c:	68fb      	ldr	r3, [r7, #12]
    239e:	3334      	adds	r3, #52	; 0x34
	}
    23a0:	4618      	mov	r0, r3
    23a2:	3714      	adds	r7, #20
    23a4:	46bd      	mov	sp, r7
    23a6:	f85d 7b04 	ldr.w	r7, [sp], #4
    23aa:	4770      	bx	lr
    23ac:	20000028 	.word	0x20000028

000023b0 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
    23b0:	b580      	push	{r7, lr}
    23b2:	b086      	sub	sp, #24
    23b4:	af00      	add	r7, sp, #0
    23b6:	60f8      	str	r0, [r7, #12]
    23b8:	60b9      	str	r1, [r7, #8]
    23ba:	607a      	str	r2, [r7, #4]
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    23bc:	2300      	movs	r3, #0
    23be:	617b      	str	r3, [r7, #20]
    23c0:	2306      	movs	r3, #6
    23c2:	613b      	str	r3, [r7, #16]

		vTaskSuspendAll();
    23c4:	f7ff ff08 	bl	21d8 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
    23c8:	4b2b      	ldr	r3, [pc, #172]	; (2478 <uxTaskGetSystemState+0xc8>)
    23ca:	681b      	ldr	r3, [r3, #0]
    23cc:	68ba      	ldr	r2, [r7, #8]
    23ce:	429a      	cmp	r2, r3
    23d0:	d34a      	bcc.n	2468 <uxTaskGetSystemState+0xb8>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
    23d2:	693b      	ldr	r3, [r7, #16]
    23d4:	3b01      	subs	r3, #1
    23d6:	613b      	str	r3, [r7, #16]
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    23d8:	697b      	ldr	r3, [r7, #20]
    23da:	015b      	lsls	r3, r3, #5
    23dc:	68fa      	ldr	r2, [r7, #12]
    23de:	18d1      	adds	r1, r2, r3
    23e0:	693a      	ldr	r2, [r7, #16]
    23e2:	4613      	mov	r3, r2
    23e4:	009b      	lsls	r3, r3, #2
    23e6:	4413      	add	r3, r2
    23e8:	009b      	lsls	r3, r3, #2
    23ea:	4a24      	ldr	r2, [pc, #144]	; (247c <uxTaskGetSystemState+0xcc>)
    23ec:	4413      	add	r3, r2
    23ee:	4608      	mov	r0, r1
    23f0:	4619      	mov	r1, r3
    23f2:	2201      	movs	r2, #1
    23f4:	f000 fc7a 	bl	2cec <prvListTaskWithinSingleList>
    23f8:	4603      	mov	r3, r0
    23fa:	697a      	ldr	r2, [r7, #20]
    23fc:	4413      	add	r3, r2
    23fe:	617b      	str	r3, [r7, #20]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2400:	693b      	ldr	r3, [r7, #16]
    2402:	2b00      	cmp	r3, #0
    2404:	d1e5      	bne.n	23d2 <uxTaskGetSystemState+0x22>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    2406:	697b      	ldr	r3, [r7, #20]
    2408:	015b      	lsls	r3, r3, #5
    240a:	68fa      	ldr	r2, [r7, #12]
    240c:	441a      	add	r2, r3
    240e:	4b1c      	ldr	r3, [pc, #112]	; (2480 <uxTaskGetSystemState+0xd0>)
    2410:	681b      	ldr	r3, [r3, #0]
    2412:	4610      	mov	r0, r2
    2414:	4619      	mov	r1, r3
    2416:	2202      	movs	r2, #2
    2418:	f000 fc68 	bl	2cec <prvListTaskWithinSingleList>
    241c:	4603      	mov	r3, r0
    241e:	697a      	ldr	r2, [r7, #20]
    2420:	4413      	add	r3, r2
    2422:	617b      	str	r3, [r7, #20]
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    2424:	697b      	ldr	r3, [r7, #20]
    2426:	015b      	lsls	r3, r3, #5
    2428:	68fa      	ldr	r2, [r7, #12]
    242a:	441a      	add	r2, r3
    242c:	4b15      	ldr	r3, [pc, #84]	; (2484 <uxTaskGetSystemState+0xd4>)
    242e:	681b      	ldr	r3, [r3, #0]
    2430:	4610      	mov	r0, r2
    2432:	4619      	mov	r1, r3
    2434:	2202      	movs	r2, #2
    2436:	f000 fc59 	bl	2cec <prvListTaskWithinSingleList>
    243a:	4603      	mov	r3, r0
    243c:	697a      	ldr	r2, [r7, #20]
    243e:	4413      	add	r3, r2
    2440:	617b      	str	r3, [r7, #20]

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
    2442:	697b      	ldr	r3, [r7, #20]
    2444:	015b      	lsls	r3, r3, #5
    2446:	68fa      	ldr	r2, [r7, #12]
    2448:	4413      	add	r3, r2
    244a:	4618      	mov	r0, r3
    244c:	490e      	ldr	r1, [pc, #56]	; (2488 <uxTaskGetSystemState+0xd8>)
    244e:	2203      	movs	r2, #3
    2450:	f000 fc4c 	bl	2cec <prvListTaskWithinSingleList>
    2454:	4603      	mov	r3, r0
    2456:	697a      	ldr	r2, [r7, #20]
    2458:	4413      	add	r3, r2
    245a:	617b      	str	r3, [r7, #20]
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
    245c:	687b      	ldr	r3, [r7, #4]
    245e:	2b00      	cmp	r3, #0
    2460:	d002      	beq.n	2468 <uxTaskGetSystemState+0xb8>
					{
						*pulTotalRunTime = 0;
    2462:	687b      	ldr	r3, [r7, #4]
    2464:	2200      	movs	r2, #0
    2466:	601a      	str	r2, [r3, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
    2468:	f7ff fec4 	bl	21f4 <xTaskResumeAll>

		return uxTask;
    246c:	697b      	ldr	r3, [r7, #20]
	}
    246e:	4618      	mov	r0, r3
    2470:	3718      	adds	r7, #24
    2472:	46bd      	mov	sp, r7
    2474:	bd80      	pop	{r7, pc}
    2476:	bf00      	nop
    2478:	20000100 	.word	0x20000100
    247c:	2000002c 	.word	0x2000002c
    2480:	200000cc 	.word	0x200000cc
    2484:	200000d0 	.word	0x200000d0
    2488:	200000e8 	.word	0x200000e8

0000248c <xTaskGetIdleTaskHandle>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )

	TaskHandle_t xTaskGetIdleTaskHandle( void )
	{
    248c:	b480      	push	{r7}
    248e:	af00      	add	r7, sp, #0
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
    2490:	4b07      	ldr	r3, [pc, #28]	; (24b0 <xTaskGetIdleTaskHandle+0x24>)
    2492:	681b      	ldr	r3, [r3, #0]
    2494:	2b00      	cmp	r3, #0
    2496:	d104      	bne.n	24a2 <xTaskGetIdleTaskHandle+0x16>
    2498:	f04f 0050 	mov.w	r0, #80	; 0x50
    249c:	f380 8811 	msr	BASEPRI, r0
    24a0:	e7fe      	b.n	24a0 <xTaskGetIdleTaskHandle+0x14>
		return xIdleTaskHandle;
    24a2:	4b03      	ldr	r3, [pc, #12]	; (24b0 <xTaskGetIdleTaskHandle+0x24>)
    24a4:	681b      	ldr	r3, [r3, #0]
	}
    24a6:	4618      	mov	r0, r3
    24a8:	46bd      	mov	sp, r7
    24aa:	f85d 7b04 	ldr.w	r7, [sp], #4
    24ae:	4770      	bx	lr
    24b0:	200000fc 	.word	0x200000fc

000024b4 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    24b4:	b580      	push	{r7, lr}
    24b6:	b086      	sub	sp, #24
    24b8:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    24ba:	2300      	movs	r3, #0
    24bc:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    24be:	4b53      	ldr	r3, [pc, #332]	; (260c <xTaskIncrementTick+0x158>)
    24c0:	681b      	ldr	r3, [r3, #0]
    24c2:	2b00      	cmp	r3, #0
    24c4:	f040 808f 	bne.w	25e6 <xTaskIncrementTick+0x132>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    24c8:	4b51      	ldr	r3, [pc, #324]	; (2610 <xTaskIncrementTick+0x15c>)
    24ca:	681b      	ldr	r3, [r3, #0]
    24cc:	1c5a      	adds	r2, r3, #1
    24ce:	4b50      	ldr	r3, [pc, #320]	; (2610 <xTaskIncrementTick+0x15c>)
    24d0:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    24d2:	4b4f      	ldr	r3, [pc, #316]	; (2610 <xTaskIncrementTick+0x15c>)
    24d4:	681b      	ldr	r3, [r3, #0]
    24d6:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( TickType_t ) 0U )
    24d8:	693b      	ldr	r3, [r7, #16]
    24da:	2b00      	cmp	r3, #0
    24dc:	d11a      	bne.n	2514 <xTaskIncrementTick+0x60>
			{
				taskSWITCH_DELAYED_LISTS();
    24de:	4b4d      	ldr	r3, [pc, #308]	; (2614 <xTaskIncrementTick+0x160>)
    24e0:	681b      	ldr	r3, [r3, #0]
    24e2:	681b      	ldr	r3, [r3, #0]
    24e4:	2b00      	cmp	r3, #0
    24e6:	d004      	beq.n	24f2 <xTaskIncrementTick+0x3e>
    24e8:	f04f 0050 	mov.w	r0, #80	; 0x50
    24ec:	f380 8811 	msr	BASEPRI, r0
    24f0:	e7fe      	b.n	24f0 <xTaskIncrementTick+0x3c>
    24f2:	4b48      	ldr	r3, [pc, #288]	; (2614 <xTaskIncrementTick+0x160>)
    24f4:	681b      	ldr	r3, [r3, #0]
    24f6:	60fb      	str	r3, [r7, #12]
    24f8:	4b47      	ldr	r3, [pc, #284]	; (2618 <xTaskIncrementTick+0x164>)
    24fa:	681a      	ldr	r2, [r3, #0]
    24fc:	4b45      	ldr	r3, [pc, #276]	; (2614 <xTaskIncrementTick+0x160>)
    24fe:	601a      	str	r2, [r3, #0]
    2500:	4b45      	ldr	r3, [pc, #276]	; (2618 <xTaskIncrementTick+0x164>)
    2502:	68fa      	ldr	r2, [r7, #12]
    2504:	601a      	str	r2, [r3, #0]
    2506:	4b45      	ldr	r3, [pc, #276]	; (261c <xTaskIncrementTick+0x168>)
    2508:	681b      	ldr	r3, [r3, #0]
    250a:	1c5a      	adds	r2, r3, #1
    250c:	4b43      	ldr	r3, [pc, #268]	; (261c <xTaskIncrementTick+0x168>)
    250e:	601a      	str	r2, [r3, #0]
    2510:	f000 fcb0 	bl	2e74 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2514:	4b42      	ldr	r3, [pc, #264]	; (2620 <xTaskIncrementTick+0x16c>)
    2516:	681b      	ldr	r3, [r3, #0]
    2518:	693a      	ldr	r2, [r7, #16]
    251a:	429a      	cmp	r2, r3
    251c:	d34e      	bcc.n	25bc <xTaskIncrementTick+0x108>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    251e:	4b3d      	ldr	r3, [pc, #244]	; (2614 <xTaskIncrementTick+0x160>)
    2520:	681b      	ldr	r3, [r3, #0]
    2522:	681b      	ldr	r3, [r3, #0]
    2524:	2b00      	cmp	r3, #0
    2526:	d101      	bne.n	252c <xTaskIncrementTick+0x78>
    2528:	2301      	movs	r3, #1
    252a:	e000      	b.n	252e <xTaskIncrementTick+0x7a>
    252c:	2300      	movs	r3, #0
    252e:	2b00      	cmp	r3, #0
    2530:	d004      	beq.n	253c <xTaskIncrementTick+0x88>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    2532:	4b3b      	ldr	r3, [pc, #236]	; (2620 <xTaskIncrementTick+0x16c>)
    2534:	f04f 32ff 	mov.w	r2, #4294967295
    2538:	601a      	str	r2, [r3, #0]
						break;
    253a:	e03f      	b.n	25bc <xTaskIncrementTick+0x108>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    253c:	4b35      	ldr	r3, [pc, #212]	; (2614 <xTaskIncrementTick+0x160>)
    253e:	681b      	ldr	r3, [r3, #0]
    2540:	68db      	ldr	r3, [r3, #12]
    2542:	68db      	ldr	r3, [r3, #12]
    2544:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2546:	68bb      	ldr	r3, [r7, #8]
    2548:	685b      	ldr	r3, [r3, #4]
    254a:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
    254c:	693a      	ldr	r2, [r7, #16]
    254e:	687b      	ldr	r3, [r7, #4]
    2550:	429a      	cmp	r2, r3
    2552:	d203      	bcs.n	255c <xTaskIncrementTick+0xa8>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    2554:	4b32      	ldr	r3, [pc, #200]	; (2620 <xTaskIncrementTick+0x16c>)
    2556:	687a      	ldr	r2, [r7, #4]
    2558:	601a      	str	r2, [r3, #0]
							break;
    255a:	e02f      	b.n	25bc <xTaskIncrementTick+0x108>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    255c:	68bb      	ldr	r3, [r7, #8]
    255e:	3304      	adds	r3, #4
    2560:	4618      	mov	r0, r3
    2562:	f002 f987 	bl	4874 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2566:	68bb      	ldr	r3, [r7, #8]
    2568:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    256a:	2b00      	cmp	r3, #0
    256c:	d004      	beq.n	2578 <xTaskIncrementTick+0xc4>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    256e:	68bb      	ldr	r3, [r7, #8]
    2570:	3318      	adds	r3, #24
    2572:	4618      	mov	r0, r3
    2574:	f002 f97e 	bl	4874 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    2578:	68bb      	ldr	r3, [r7, #8]
    257a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    257c:	4b29      	ldr	r3, [pc, #164]	; (2624 <xTaskIncrementTick+0x170>)
    257e:	681b      	ldr	r3, [r3, #0]
    2580:	429a      	cmp	r2, r3
    2582:	d903      	bls.n	258c <xTaskIncrementTick+0xd8>
    2584:	68bb      	ldr	r3, [r7, #8]
    2586:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2588:	4b26      	ldr	r3, [pc, #152]	; (2624 <xTaskIncrementTick+0x170>)
    258a:	601a      	str	r2, [r3, #0]
    258c:	68bb      	ldr	r3, [r7, #8]
    258e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2590:	4613      	mov	r3, r2
    2592:	009b      	lsls	r3, r3, #2
    2594:	4413      	add	r3, r2
    2596:	009b      	lsls	r3, r3, #2
    2598:	4a23      	ldr	r2, [pc, #140]	; (2628 <xTaskIncrementTick+0x174>)
    259a:	441a      	add	r2, r3
    259c:	68bb      	ldr	r3, [r7, #8]
    259e:	3304      	adds	r3, #4
    25a0:	4610      	mov	r0, r2
    25a2:	4619      	mov	r1, r3
    25a4:	f002 f90a 	bl	47bc <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    25a8:	68bb      	ldr	r3, [r7, #8]
    25aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    25ac:	4b1f      	ldr	r3, [pc, #124]	; (262c <xTaskIncrementTick+0x178>)
    25ae:	681b      	ldr	r3, [r3, #0]
    25b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    25b2:	429a      	cmp	r2, r3
    25b4:	d301      	bcc.n	25ba <xTaskIncrementTick+0x106>
							{
								xSwitchRequired = pdTRUE;
    25b6:	2301      	movs	r3, #1
    25b8:	617b      	str	r3, [r7, #20]
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    25ba:	e7b0      	b.n	251e <xTaskIncrementTick+0x6a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    25bc:	4b1b      	ldr	r3, [pc, #108]	; (262c <xTaskIncrementTick+0x178>)
    25be:	681b      	ldr	r3, [r3, #0]
    25c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    25c2:	4919      	ldr	r1, [pc, #100]	; (2628 <xTaskIncrementTick+0x174>)
    25c4:	4613      	mov	r3, r2
    25c6:	009b      	lsls	r3, r3, #2
    25c8:	4413      	add	r3, r2
    25ca:	009b      	lsls	r3, r3, #2
    25cc:	440b      	add	r3, r1
    25ce:	681b      	ldr	r3, [r3, #0]
    25d0:	2b01      	cmp	r3, #1
    25d2:	d901      	bls.n	25d8 <xTaskIncrementTick+0x124>
			{
				xSwitchRequired = pdTRUE;
    25d4:	2301      	movs	r3, #1
    25d6:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
    25d8:	4b15      	ldr	r3, [pc, #84]	; (2630 <xTaskIncrementTick+0x17c>)
    25da:	681b      	ldr	r3, [r3, #0]
    25dc:	2b00      	cmp	r3, #0
    25de:	d109      	bne.n	25f4 <xTaskIncrementTick+0x140>
			{
      extern void vApplicationTickHook( void );
      FRTOS1_vApplicationTickHook();
    25e0:	f7ff f8d8 	bl	1794 <FRTOS1_vApplicationTickHook>
    25e4:	e006      	b.n	25f4 <xTaskIncrementTick+0x140>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    25e6:	4b12      	ldr	r3, [pc, #72]	; (2630 <xTaskIncrementTick+0x17c>)
    25e8:	681b      	ldr	r3, [r3, #0]
    25ea:	1c5a      	adds	r2, r3, #1
    25ec:	4b10      	ldr	r3, [pc, #64]	; (2630 <xTaskIncrementTick+0x17c>)
    25ee:	601a      	str	r2, [r3, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
      FRTOS1_vApplicationTickHook();
    25f0:	f7ff f8d0 	bl	1794 <FRTOS1_vApplicationTickHook>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    25f4:	4b0f      	ldr	r3, [pc, #60]	; (2634 <xTaskIncrementTick+0x180>)
    25f6:	681b      	ldr	r3, [r3, #0]
    25f8:	2b00      	cmp	r3, #0
    25fa:	d001      	beq.n	2600 <xTaskIncrementTick+0x14c>
		{
			xSwitchRequired = pdTRUE;
    25fc:	2301      	movs	r3, #1
    25fe:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2600:	697b      	ldr	r3, [r7, #20]
}
    2602:	4618      	mov	r0, r3
    2604:	3718      	adds	r7, #24
    2606:	46bd      	mov	sp, r7
    2608:	bd80      	pop	{r7, pc}
    260a:	bf00      	nop
    260c:	20000124 	.word	0x20000124
    2610:	20000104 	.word	0x20000104
    2614:	200000cc 	.word	0x200000cc
    2618:	200000d0 	.word	0x200000d0
    261c:	20000118 	.word	0x20000118
    2620:	20000120 	.word	0x20000120
    2624:	20000108 	.word	0x20000108
    2628:	2000002c 	.word	0x2000002c
    262c:	20000028 	.word	0x20000028
    2630:	20000110 	.word	0x20000110
    2634:	20000114 	.word	0x20000114

00002638 <vTaskSwitchContext>:
/*-----------------------------------------------------------*/
#ifdef __GNUC__ /* << EST */
__attribute__((used)) /* using C++ compiler, vTaskSwitchContext() might be removed even with -O0? */
#endif
void vTaskSwitchContext( void )
{
    2638:	b580      	push	{r7, lr}
    263a:	b082      	sub	sp, #8
    263c:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    263e:	4b2c      	ldr	r3, [pc, #176]	; (26f0 <vTaskSwitchContext+0xb8>)
    2640:	681b      	ldr	r3, [r3, #0]
    2642:	2b00      	cmp	r3, #0
    2644:	d003      	beq.n	264e <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2646:	4b2b      	ldr	r3, [pc, #172]	; (26f4 <vTaskSwitchContext+0xbc>)
    2648:	2201      	movs	r2, #1
    264a:	601a      	str	r2, [r3, #0]
    264c:	e04c      	b.n	26e8 <vTaskSwitchContext+0xb0>
	}
	else
	{
		xYieldPending = pdFALSE;
    264e:	4b29      	ldr	r3, [pc, #164]	; (26f4 <vTaskSwitchContext+0xbc>)
    2650:	2200      	movs	r2, #0
    2652:	601a      	str	r2, [r3, #0]
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
    2654:	4b28      	ldr	r3, [pc, #160]	; (26f8 <vTaskSwitchContext+0xc0>)
    2656:	681b      	ldr	r3, [r3, #0]
    2658:	681a      	ldr	r2, [r3, #0]
    265a:	4b27      	ldr	r3, [pc, #156]	; (26f8 <vTaskSwitchContext+0xc0>)
    265c:	681b      	ldr	r3, [r3, #0]
    265e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2660:	429a      	cmp	r2, r3
    2662:	d809      	bhi.n	2678 <vTaskSwitchContext+0x40>
    2664:	4b24      	ldr	r3, [pc, #144]	; (26f8 <vTaskSwitchContext+0xc0>)
    2666:	681a      	ldr	r2, [r3, #0]
    2668:	4b23      	ldr	r3, [pc, #140]	; (26f8 <vTaskSwitchContext+0xc0>)
    266a:	681b      	ldr	r3, [r3, #0]
    266c:	3334      	adds	r3, #52	; 0x34
    266e:	4610      	mov	r0, r2
    2670:	4619      	mov	r1, r3
    2672:	f7ff f885 	bl	1780 <FRTOS1_vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2676:	e00e      	b.n	2696 <vTaskSwitchContext+0x5e>
    2678:	e00d      	b.n	2696 <vTaskSwitchContext+0x5e>
    267a:	4b20      	ldr	r3, [pc, #128]	; (26fc <vTaskSwitchContext+0xc4>)
    267c:	681b      	ldr	r3, [r3, #0]
    267e:	2b00      	cmp	r3, #0
    2680:	d104      	bne.n	268c <vTaskSwitchContext+0x54>
    2682:	f04f 0050 	mov.w	r0, #80	; 0x50
    2686:	f380 8811 	msr	BASEPRI, r0
    268a:	e7fe      	b.n	268a <vTaskSwitchContext+0x52>
    268c:	4b1b      	ldr	r3, [pc, #108]	; (26fc <vTaskSwitchContext+0xc4>)
    268e:	681b      	ldr	r3, [r3, #0]
    2690:	1e5a      	subs	r2, r3, #1
    2692:	4b1a      	ldr	r3, [pc, #104]	; (26fc <vTaskSwitchContext+0xc4>)
    2694:	601a      	str	r2, [r3, #0]
    2696:	4b19      	ldr	r3, [pc, #100]	; (26fc <vTaskSwitchContext+0xc4>)
    2698:	681a      	ldr	r2, [r3, #0]
    269a:	4919      	ldr	r1, [pc, #100]	; (2700 <vTaskSwitchContext+0xc8>)
    269c:	4613      	mov	r3, r2
    269e:	009b      	lsls	r3, r3, #2
    26a0:	4413      	add	r3, r2
    26a2:	009b      	lsls	r3, r3, #2
    26a4:	440b      	add	r3, r1
    26a6:	681b      	ldr	r3, [r3, #0]
    26a8:	2b00      	cmp	r3, #0
    26aa:	d0e6      	beq.n	267a <vTaskSwitchContext+0x42>
    26ac:	4b13      	ldr	r3, [pc, #76]	; (26fc <vTaskSwitchContext+0xc4>)
    26ae:	681a      	ldr	r2, [r3, #0]
    26b0:	4613      	mov	r3, r2
    26b2:	009b      	lsls	r3, r3, #2
    26b4:	4413      	add	r3, r2
    26b6:	009b      	lsls	r3, r3, #2
    26b8:	4a11      	ldr	r2, [pc, #68]	; (2700 <vTaskSwitchContext+0xc8>)
    26ba:	4413      	add	r3, r2
    26bc:	607b      	str	r3, [r7, #4]
    26be:	687b      	ldr	r3, [r7, #4]
    26c0:	685b      	ldr	r3, [r3, #4]
    26c2:	685a      	ldr	r2, [r3, #4]
    26c4:	687b      	ldr	r3, [r7, #4]
    26c6:	605a      	str	r2, [r3, #4]
    26c8:	687b      	ldr	r3, [r7, #4]
    26ca:	685a      	ldr	r2, [r3, #4]
    26cc:	687b      	ldr	r3, [r7, #4]
    26ce:	3308      	adds	r3, #8
    26d0:	429a      	cmp	r2, r3
    26d2:	d104      	bne.n	26de <vTaskSwitchContext+0xa6>
    26d4:	687b      	ldr	r3, [r7, #4]
    26d6:	685b      	ldr	r3, [r3, #4]
    26d8:	685a      	ldr	r2, [r3, #4]
    26da:	687b      	ldr	r3, [r7, #4]
    26dc:	605a      	str	r2, [r3, #4]
    26de:	687b      	ldr	r3, [r7, #4]
    26e0:	685b      	ldr	r3, [r3, #4]
    26e2:	68da      	ldr	r2, [r3, #12]
    26e4:	4b04      	ldr	r3, [pc, #16]	; (26f8 <vTaskSwitchContext+0xc0>)
    26e6:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    26e8:	3708      	adds	r7, #8
    26ea:	46bd      	mov	sp, r7
    26ec:	bd80      	pop	{r7, pc}
    26ee:	bf00      	nop
    26f0:	20000124 	.word	0x20000124
    26f4:	20000114 	.word	0x20000114
    26f8:	20000028 	.word	0x20000028
    26fc:	20000108 	.word	0x20000108
    2700:	2000002c 	.word	0x2000002c

00002704 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2704:	b580      	push	{r7, lr}
    2706:	b084      	sub	sp, #16
    2708:	af00      	add	r7, sp, #0
    270a:	6078      	str	r0, [r7, #4]
    270c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;

	configASSERT( pxEventList );
    270e:	687b      	ldr	r3, [r7, #4]
    2710:	2b00      	cmp	r3, #0
    2712:	d104      	bne.n	271e <vTaskPlaceOnEventList+0x1a>
    2714:	f04f 0050 	mov.w	r0, #80	; 0x50
    2718:	f380 8811 	msr	BASEPRI, r0
    271c:	e7fe      	b.n	271c <vTaskPlaceOnEventList+0x18>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    271e:	4b12      	ldr	r3, [pc, #72]	; (2768 <vTaskPlaceOnEventList+0x64>)
    2720:	681b      	ldr	r3, [r3, #0]
    2722:	3318      	adds	r3, #24
    2724:	6878      	ldr	r0, [r7, #4]
    2726:	4619      	mov	r1, r3
    2728:	f002 f86c 	bl	4804 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    272c:	4b0e      	ldr	r3, [pc, #56]	; (2768 <vTaskPlaceOnEventList+0x64>)
    272e:	681b      	ldr	r3, [r3, #0]
    2730:	3304      	adds	r3, #4
    2732:	4618      	mov	r0, r3
    2734:	f002 f89e 	bl	4874 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    2738:	683b      	ldr	r3, [r7, #0]
    273a:	f1b3 3fff 	cmp.w	r3, #4294967295
    273e:	d107      	bne.n	2750 <vTaskPlaceOnEventList+0x4c>
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
			traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
#endif
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2740:	4b09      	ldr	r3, [pc, #36]	; (2768 <vTaskPlaceOnEventList+0x64>)
    2742:	681b      	ldr	r3, [r3, #0]
    2744:	3304      	adds	r3, #4
    2746:	4809      	ldr	r0, [pc, #36]	; (276c <vTaskPlaceOnEventList+0x68>)
    2748:	4619      	mov	r1, r3
    274a:	f002 f837 	bl	47bc <vListInsertEnd>
    274e:	e007      	b.n	2760 <vTaskPlaceOnEventList+0x5c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2750:	4b07      	ldr	r3, [pc, #28]	; (2770 <vTaskPlaceOnEventList+0x6c>)
    2752:	681a      	ldr	r2, [r3, #0]
    2754:	683b      	ldr	r3, [r7, #0]
    2756:	4413      	add	r3, r2
    2758:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    275a:	68f8      	ldr	r0, [r7, #12]
    275c:	f000 fa58 	bl	2c10 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2760:	3710      	adds	r7, #16
    2762:	46bd      	mov	sp, r7
    2764:	bd80      	pop	{r7, pc}
    2766:	bf00      	nop
    2768:	20000028 	.word	0x20000028
    276c:	200000e8 	.word	0x200000e8
    2770:	20000104 	.word	0x20000104

00002774 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2774:	b580      	push	{r7, lr}
    2776:	b086      	sub	sp, #24
    2778:	af00      	add	r7, sp, #0
    277a:	60f8      	str	r0, [r7, #12]
    277c:	60b9      	str	r1, [r7, #8]
    277e:	607a      	str	r2, [r7, #4]
TickType_t xTimeToWake;

	configASSERT( pxEventList );
    2780:	68fb      	ldr	r3, [r7, #12]
    2782:	2b00      	cmp	r3, #0
    2784:	d104      	bne.n	2790 <vTaskPlaceOnUnorderedEventList+0x1c>
    2786:	f04f 0050 	mov.w	r0, #80	; 0x50
    278a:	f380 8811 	msr	BASEPRI, r0
    278e:	e7fe      	b.n	278e <vTaskPlaceOnUnorderedEventList+0x1a>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
    2790:	4b19      	ldr	r3, [pc, #100]	; (27f8 <vTaskPlaceOnUnorderedEventList+0x84>)
    2792:	681b      	ldr	r3, [r3, #0]
    2794:	2b00      	cmp	r3, #0
    2796:	d104      	bne.n	27a2 <vTaskPlaceOnUnorderedEventList+0x2e>
    2798:	f04f 0050 	mov.w	r0, #80	; 0x50
    279c:	f380 8811 	msr	BASEPRI, r0
    27a0:	e7fe      	b.n	27a0 <vTaskPlaceOnUnorderedEventList+0x2c>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    27a2:	4b16      	ldr	r3, [pc, #88]	; (27fc <vTaskPlaceOnUnorderedEventList+0x88>)
    27a4:	681b      	ldr	r3, [r3, #0]
    27a6:	68ba      	ldr	r2, [r7, #8]
    27a8:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    27ac:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    27ae:	4b13      	ldr	r3, [pc, #76]	; (27fc <vTaskPlaceOnUnorderedEventList+0x88>)
    27b0:	681b      	ldr	r3, [r3, #0]
    27b2:	3318      	adds	r3, #24
    27b4:	68f8      	ldr	r0, [r7, #12]
    27b6:	4619      	mov	r1, r3
    27b8:	f002 f800 	bl	47bc <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    27bc:	4b0f      	ldr	r3, [pc, #60]	; (27fc <vTaskPlaceOnUnorderedEventList+0x88>)
    27be:	681b      	ldr	r3, [r3, #0]
    27c0:	3304      	adds	r3, #4
    27c2:	4618      	mov	r0, r3
    27c4:	f002 f856 	bl	4874 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    27c8:	687b      	ldr	r3, [r7, #4]
    27ca:	f1b3 3fff 	cmp.w	r3, #4294967295
    27ce:	d107      	bne.n	27e0 <vTaskPlaceOnUnorderedEventList+0x6c>
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
			traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
#endif
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    27d0:	4b0a      	ldr	r3, [pc, #40]	; (27fc <vTaskPlaceOnUnorderedEventList+0x88>)
    27d2:	681b      	ldr	r3, [r3, #0]
    27d4:	3304      	adds	r3, #4
    27d6:	480a      	ldr	r0, [pc, #40]	; (2800 <vTaskPlaceOnUnorderedEventList+0x8c>)
    27d8:	4619      	mov	r1, r3
    27da:	f001 ffef 	bl	47bc <vListInsertEnd>
    27de:	e007      	b.n	27f0 <vTaskPlaceOnUnorderedEventList+0x7c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    27e0:	4b08      	ldr	r3, [pc, #32]	; (2804 <vTaskPlaceOnUnorderedEventList+0x90>)
    27e2:	681a      	ldr	r2, [r3, #0]
    27e4:	687b      	ldr	r3, [r7, #4]
    27e6:	4413      	add	r3, r2
    27e8:	617b      	str	r3, [r7, #20]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    27ea:	6978      	ldr	r0, [r7, #20]
    27ec:	f000 fa10 	bl	2c10 <prvAddCurrentTaskToDelayedList>
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    27f0:	3718      	adds	r7, #24
    27f2:	46bd      	mov	sp, r7
    27f4:	bd80      	pop	{r7, pc}
    27f6:	bf00      	nop
    27f8:	20000124 	.word	0x20000124
    27fc:	20000028 	.word	0x20000028
    2800:	200000e8 	.word	0x200000e8
    2804:	20000104 	.word	0x20000104

00002808 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2808:	b580      	push	{r7, lr}
    280a:	b084      	sub	sp, #16
    280c:	af00      	add	r7, sp, #0
    280e:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2810:	687b      	ldr	r3, [r7, #4]
    2812:	68db      	ldr	r3, [r3, #12]
    2814:	68db      	ldr	r3, [r3, #12]
    2816:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
    2818:	68bb      	ldr	r3, [r7, #8]
    281a:	2b00      	cmp	r3, #0
    281c:	d104      	bne.n	2828 <xTaskRemoveFromEventList+0x20>
    281e:	f04f 0050 	mov.w	r0, #80	; 0x50
    2822:	f380 8811 	msr	BASEPRI, r0
    2826:	e7fe      	b.n	2826 <xTaskRemoveFromEventList+0x1e>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2828:	68bb      	ldr	r3, [r7, #8]
    282a:	3318      	adds	r3, #24
    282c:	4618      	mov	r0, r3
    282e:	f002 f821 	bl	4874 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2832:	4b1e      	ldr	r3, [pc, #120]	; (28ac <xTaskRemoveFromEventList+0xa4>)
    2834:	681b      	ldr	r3, [r3, #0]
    2836:	2b00      	cmp	r3, #0
    2838:	d11d      	bne.n	2876 <xTaskRemoveFromEventList+0x6e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    283a:	68bb      	ldr	r3, [r7, #8]
    283c:	3304      	adds	r3, #4
    283e:	4618      	mov	r0, r3
    2840:	f002 f818 	bl	4874 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2844:	68bb      	ldr	r3, [r7, #8]
    2846:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2848:	4b19      	ldr	r3, [pc, #100]	; (28b0 <xTaskRemoveFromEventList+0xa8>)
    284a:	681b      	ldr	r3, [r3, #0]
    284c:	429a      	cmp	r2, r3
    284e:	d903      	bls.n	2858 <xTaskRemoveFromEventList+0x50>
    2850:	68bb      	ldr	r3, [r7, #8]
    2852:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2854:	4b16      	ldr	r3, [pc, #88]	; (28b0 <xTaskRemoveFromEventList+0xa8>)
    2856:	601a      	str	r2, [r3, #0]
    2858:	68bb      	ldr	r3, [r7, #8]
    285a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    285c:	4613      	mov	r3, r2
    285e:	009b      	lsls	r3, r3, #2
    2860:	4413      	add	r3, r2
    2862:	009b      	lsls	r3, r3, #2
    2864:	4a13      	ldr	r2, [pc, #76]	; (28b4 <xTaskRemoveFromEventList+0xac>)
    2866:	441a      	add	r2, r3
    2868:	68bb      	ldr	r3, [r7, #8]
    286a:	3304      	adds	r3, #4
    286c:	4610      	mov	r0, r2
    286e:	4619      	mov	r1, r3
    2870:	f001 ffa4 	bl	47bc <vListInsertEnd>
    2874:	e005      	b.n	2882 <xTaskRemoveFromEventList+0x7a>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2876:	68bb      	ldr	r3, [r7, #8]
    2878:	3318      	adds	r3, #24
    287a:	480f      	ldr	r0, [pc, #60]	; (28b8 <xTaskRemoveFromEventList+0xb0>)
    287c:	4619      	mov	r1, r3
    287e:	f001 ff9d 	bl	47bc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2882:	68bb      	ldr	r3, [r7, #8]
    2884:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2886:	4b0d      	ldr	r3, [pc, #52]	; (28bc <xTaskRemoveFromEventList+0xb4>)
    2888:	681b      	ldr	r3, [r3, #0]
    288a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    288c:	429a      	cmp	r2, r3
    288e:	d905      	bls.n	289c <xTaskRemoveFromEventList+0x94>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    2890:	2301      	movs	r3, #1
    2892:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2894:	4b0a      	ldr	r3, [pc, #40]	; (28c0 <xTaskRemoveFromEventList+0xb8>)
    2896:	2201      	movs	r2, #1
    2898:	601a      	str	r2, [r3, #0]
    289a:	e001      	b.n	28a0 <xTaskRemoveFromEventList+0x98>
	}
	else
	{
		xReturn = pdFALSE;
    289c:	2300      	movs	r3, #0
    289e:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    28a0:	68fb      	ldr	r3, [r7, #12]
}
    28a2:	4618      	mov	r0, r3
    28a4:	3710      	adds	r7, #16
    28a6:	46bd      	mov	sp, r7
    28a8:	bd80      	pop	{r7, pc}
    28aa:	bf00      	nop
    28ac:	20000124 	.word	0x20000124
    28b0:	20000108 	.word	0x20000108
    28b4:	2000002c 	.word	0x2000002c
    28b8:	200000d4 	.word	0x200000d4
    28bc:	20000028 	.word	0x20000028
    28c0:	20000114 	.word	0x20000114

000028c4 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    28c4:	b580      	push	{r7, lr}
    28c6:	b084      	sub	sp, #16
    28c8:	af00      	add	r7, sp, #0
    28ca:	6078      	str	r0, [r7, #4]
    28cc:	6039      	str	r1, [r7, #0]
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
    28ce:	4b26      	ldr	r3, [pc, #152]	; (2968 <xTaskRemoveFromUnorderedEventList+0xa4>)
    28d0:	681b      	ldr	r3, [r3, #0]
    28d2:	2b00      	cmp	r3, #0
    28d4:	d104      	bne.n	28e0 <xTaskRemoveFromUnorderedEventList+0x1c>
    28d6:	f04f 0050 	mov.w	r0, #80	; 0x50
    28da:	f380 8811 	msr	BASEPRI, r0
    28de:	e7fe      	b.n	28de <xTaskRemoveFromUnorderedEventList+0x1a>

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    28e0:	683b      	ldr	r3, [r7, #0]
    28e2:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    28e6:	687b      	ldr	r3, [r7, #4]
    28e8:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    28ea:	687b      	ldr	r3, [r7, #4]
    28ec:	68db      	ldr	r3, [r3, #12]
    28ee:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
    28f0:	68bb      	ldr	r3, [r7, #8]
    28f2:	2b00      	cmp	r3, #0
    28f4:	d104      	bne.n	2900 <xTaskRemoveFromUnorderedEventList+0x3c>
    28f6:	f04f 0050 	mov.w	r0, #80	; 0x50
    28fa:	f380 8811 	msr	BASEPRI, r0
    28fe:	e7fe      	b.n	28fe <xTaskRemoveFromUnorderedEventList+0x3a>
	( void ) uxListRemove( pxEventListItem );
    2900:	6878      	ldr	r0, [r7, #4]
    2902:	f001 ffb7 	bl	4874 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2906:	68bb      	ldr	r3, [r7, #8]
    2908:	3304      	adds	r3, #4
    290a:	4618      	mov	r0, r3
    290c:	f001 ffb2 	bl	4874 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2910:	68bb      	ldr	r3, [r7, #8]
    2912:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2914:	4b15      	ldr	r3, [pc, #84]	; (296c <xTaskRemoveFromUnorderedEventList+0xa8>)
    2916:	681b      	ldr	r3, [r3, #0]
    2918:	429a      	cmp	r2, r3
    291a:	d903      	bls.n	2924 <xTaskRemoveFromUnorderedEventList+0x60>
    291c:	68bb      	ldr	r3, [r7, #8]
    291e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2920:	4b12      	ldr	r3, [pc, #72]	; (296c <xTaskRemoveFromUnorderedEventList+0xa8>)
    2922:	601a      	str	r2, [r3, #0]
    2924:	68bb      	ldr	r3, [r7, #8]
    2926:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2928:	4613      	mov	r3, r2
    292a:	009b      	lsls	r3, r3, #2
    292c:	4413      	add	r3, r2
    292e:	009b      	lsls	r3, r3, #2
    2930:	4a0f      	ldr	r2, [pc, #60]	; (2970 <xTaskRemoveFromUnorderedEventList+0xac>)
    2932:	441a      	add	r2, r3
    2934:	68bb      	ldr	r3, [r7, #8]
    2936:	3304      	adds	r3, #4
    2938:	4610      	mov	r0, r2
    293a:	4619      	mov	r1, r3
    293c:	f001 ff3e 	bl	47bc <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2940:	68bb      	ldr	r3, [r7, #8]
    2942:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2944:	4b0b      	ldr	r3, [pc, #44]	; (2974 <xTaskRemoveFromUnorderedEventList+0xb0>)
    2946:	681b      	ldr	r3, [r3, #0]
    2948:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    294a:	429a      	cmp	r2, r3
    294c:	d905      	bls.n	295a <xTaskRemoveFromUnorderedEventList+0x96>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    294e:	2301      	movs	r3, #1
    2950:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2952:	4b09      	ldr	r3, [pc, #36]	; (2978 <xTaskRemoveFromUnorderedEventList+0xb4>)
    2954:	2201      	movs	r2, #1
    2956:	601a      	str	r2, [r3, #0]
    2958:	e001      	b.n	295e <xTaskRemoveFromUnorderedEventList+0x9a>
	}
	else
	{
		xReturn = pdFALSE;
    295a:	2300      	movs	r3, #0
    295c:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
    295e:	68fb      	ldr	r3, [r7, #12]
}
    2960:	4618      	mov	r0, r3
    2962:	3710      	adds	r7, #16
    2964:	46bd      	mov	sp, r7
    2966:	bd80      	pop	{r7, pc}
    2968:	20000124 	.word	0x20000124
    296c:	20000108 	.word	0x20000108
    2970:	2000002c 	.word	0x2000002c
    2974:	20000028 	.word	0x20000028
    2978:	20000114 	.word	0x20000114

0000297c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    297c:	b480      	push	{r7}
    297e:	b083      	sub	sp, #12
    2980:	af00      	add	r7, sp, #0
    2982:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
    2984:	687b      	ldr	r3, [r7, #4]
    2986:	2b00      	cmp	r3, #0
    2988:	d104      	bne.n	2994 <vTaskSetTimeOutState+0x18>
    298a:	f04f 0050 	mov.w	r0, #80	; 0x50
    298e:	f380 8811 	msr	BASEPRI, r0
    2992:	e7fe      	b.n	2992 <vTaskSetTimeOutState+0x16>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2994:	4b06      	ldr	r3, [pc, #24]	; (29b0 <vTaskSetTimeOutState+0x34>)
    2996:	681a      	ldr	r2, [r3, #0]
    2998:	687b      	ldr	r3, [r7, #4]
    299a:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
    299c:	4b05      	ldr	r3, [pc, #20]	; (29b4 <vTaskSetTimeOutState+0x38>)
    299e:	681a      	ldr	r2, [r3, #0]
    29a0:	687b      	ldr	r3, [r7, #4]
    29a2:	605a      	str	r2, [r3, #4]
}
    29a4:	370c      	adds	r7, #12
    29a6:	46bd      	mov	sp, r7
    29a8:	f85d 7b04 	ldr.w	r7, [sp], #4
    29ac:	4770      	bx	lr
    29ae:	bf00      	nop
    29b0:	20000118 	.word	0x20000118
    29b4:	20000104 	.word	0x20000104

000029b8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    29b8:	b580      	push	{r7, lr}
    29ba:	b084      	sub	sp, #16
    29bc:	af00      	add	r7, sp, #0
    29be:	6078      	str	r0, [r7, #4]
    29c0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
    29c2:	687b      	ldr	r3, [r7, #4]
    29c4:	2b00      	cmp	r3, #0
    29c6:	d104      	bne.n	29d2 <xTaskCheckForTimeOut+0x1a>
    29c8:	f04f 0050 	mov.w	r0, #80	; 0x50
    29cc:	f380 8811 	msr	BASEPRI, r0
    29d0:	e7fe      	b.n	29d0 <xTaskCheckForTimeOut+0x18>
	configASSERT( pxTicksToWait );
    29d2:	683b      	ldr	r3, [r7, #0]
    29d4:	2b00      	cmp	r3, #0
    29d6:	d104      	bne.n	29e2 <xTaskCheckForTimeOut+0x2a>
    29d8:	f04f 0050 	mov.w	r0, #80	; 0x50
    29dc:	f380 8811 	msr	BASEPRI, r0
    29e0:	e7fe      	b.n	29e0 <xTaskCheckForTimeOut+0x28>

	taskENTER_CRITICAL();
    29e2:	f001 fe19 	bl	4618 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    29e6:	4b1c      	ldr	r3, [pc, #112]	; (2a58 <xTaskCheckForTimeOut+0xa0>)
    29e8:	681b      	ldr	r3, [r3, #0]
    29ea:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    29ec:	683b      	ldr	r3, [r7, #0]
    29ee:	681b      	ldr	r3, [r3, #0]
    29f0:	f1b3 3fff 	cmp.w	r3, #4294967295
    29f4:	d102      	bne.n	29fc <xTaskCheckForTimeOut+0x44>
			{
				xReturn = pdFALSE;
    29f6:	2300      	movs	r3, #0
    29f8:	60fb      	str	r3, [r7, #12]
    29fa:	e026      	b.n	2a4a <xTaskCheckForTimeOut+0x92>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    29fc:	687b      	ldr	r3, [r7, #4]
    29fe:	681a      	ldr	r2, [r3, #0]
    2a00:	4b16      	ldr	r3, [pc, #88]	; (2a5c <xTaskCheckForTimeOut+0xa4>)
    2a02:	681b      	ldr	r3, [r3, #0]
    2a04:	429a      	cmp	r2, r3
    2a06:	d007      	beq.n	2a18 <xTaskCheckForTimeOut+0x60>
    2a08:	687b      	ldr	r3, [r7, #4]
    2a0a:	685a      	ldr	r2, [r3, #4]
    2a0c:	68bb      	ldr	r3, [r7, #8]
    2a0e:	429a      	cmp	r2, r3
    2a10:	d802      	bhi.n	2a18 <xTaskCheckForTimeOut+0x60>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2a12:	2301      	movs	r3, #1
    2a14:	60fb      	str	r3, [r7, #12]
    2a16:	e018      	b.n	2a4a <xTaskCheckForTimeOut+0x92>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2a18:	687b      	ldr	r3, [r7, #4]
    2a1a:	685b      	ldr	r3, [r3, #4]
    2a1c:	68ba      	ldr	r2, [r7, #8]
    2a1e:	1ad2      	subs	r2, r2, r3
    2a20:	683b      	ldr	r3, [r7, #0]
    2a22:	681b      	ldr	r3, [r3, #0]
    2a24:	429a      	cmp	r2, r3
    2a26:	d20e      	bcs.n	2a46 <xTaskCheckForTimeOut+0x8e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2a28:	683b      	ldr	r3, [r7, #0]
    2a2a:	681a      	ldr	r2, [r3, #0]
    2a2c:	687b      	ldr	r3, [r7, #4]
    2a2e:	6859      	ldr	r1, [r3, #4]
    2a30:	68bb      	ldr	r3, [r7, #8]
    2a32:	1acb      	subs	r3, r1, r3
    2a34:	441a      	add	r2, r3
    2a36:	683b      	ldr	r3, [r7, #0]
    2a38:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
    2a3a:	6878      	ldr	r0, [r7, #4]
    2a3c:	f7ff ff9e 	bl	297c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2a40:	2300      	movs	r3, #0
    2a42:	60fb      	str	r3, [r7, #12]
    2a44:	e001      	b.n	2a4a <xTaskCheckForTimeOut+0x92>
		}
		else
		{
			xReturn = pdTRUE;
    2a46:	2301      	movs	r3, #1
    2a48:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    2a4a:	f001 fdfb 	bl	4644 <vPortExitCritical>

	return xReturn;
    2a4e:	68fb      	ldr	r3, [r7, #12]
}
    2a50:	4618      	mov	r0, r3
    2a52:	3710      	adds	r7, #16
    2a54:	46bd      	mov	sp, r7
    2a56:	bd80      	pop	{r7, pc}
    2a58:	20000104 	.word	0x20000104
    2a5c:	20000118 	.word	0x20000118

00002a60 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2a60:	b480      	push	{r7}
    2a62:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
    2a64:	4b03      	ldr	r3, [pc, #12]	; (2a74 <vTaskMissedYield+0x14>)
    2a66:	2201      	movs	r2, #1
    2a68:	601a      	str	r2, [r3, #0]
}
    2a6a:	46bd      	mov	sp, r7
    2a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
    2a70:	4770      	bx	lr
    2a72:	bf00      	nop
    2a74:	20000114 	.word	0x20000114

00002a78 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
    2a78:	b480      	push	{r7}
    2a7a:	b085      	sub	sp, #20
    2a7c:	af00      	add	r7, sp, #0
    2a7e:	6078      	str	r0, [r7, #4]
	UBaseType_t uxReturn;
	TCB_t *pxTCB;

		if( xTask != NULL )
    2a80:	687b      	ldr	r3, [r7, #4]
    2a82:	2b00      	cmp	r3, #0
    2a84:	d005      	beq.n	2a92 <uxTaskGetTaskNumber+0x1a>
		{
			pxTCB = ( TCB_t * ) xTask;
    2a86:	687b      	ldr	r3, [r7, #4]
    2a88:	60bb      	str	r3, [r7, #8]
			uxReturn = pxTCB->uxTaskNumber;
    2a8a:	68bb      	ldr	r3, [r7, #8]
    2a8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    2a8e:	60fb      	str	r3, [r7, #12]
    2a90:	e001      	b.n	2a96 <uxTaskGetTaskNumber+0x1e>
		}
		else
		{
			uxReturn = 0U;
    2a92:	2300      	movs	r3, #0
    2a94:	60fb      	str	r3, [r7, #12]
		}

		return uxReturn;
    2a96:	68fb      	ldr	r3, [r7, #12]
	}
    2a98:	4618      	mov	r0, r3
    2a9a:	3714      	adds	r7, #20
    2a9c:	46bd      	mov	sp, r7
    2a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
    2aa2:	4770      	bx	lr

00002aa4 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
    2aa4:	b480      	push	{r7}
    2aa6:	b085      	sub	sp, #20
    2aa8:	af00      	add	r7, sp, #0
    2aaa:	6078      	str	r0, [r7, #4]
    2aac:	6039      	str	r1, [r7, #0]
	TCB_t *pxTCB;

		if( xTask != NULL )
    2aae:	687b      	ldr	r3, [r7, #4]
    2ab0:	2b00      	cmp	r3, #0
    2ab2:	d004      	beq.n	2abe <vTaskSetTaskNumber+0x1a>
		{
			pxTCB = ( TCB_t * ) xTask;
    2ab4:	687b      	ldr	r3, [r7, #4]
    2ab6:	60fb      	str	r3, [r7, #12]
			pxTCB->uxTaskNumber = uxHandle;
    2ab8:	68fb      	ldr	r3, [r7, #12]
    2aba:	683a      	ldr	r2, [r7, #0]
    2abc:	645a      	str	r2, [r3, #68]	; 0x44
		}
	}
    2abe:	3714      	adds	r7, #20
    2ac0:	46bd      	mov	sp, r7
    2ac2:	f85d 7b04 	ldr.w	r7, [sp], #4
    2ac6:	4770      	bx	lr

00002ac8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2ac8:	b580      	push	{r7, lr}
    2aca:	b082      	sub	sp, #8
    2acc:	af00      	add	r7, sp, #0
    2ace:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    2ad0:	f000 f898 	bl	2c04 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    2ad4:	4b04      	ldr	r3, [pc, #16]	; (2ae8 <prvIdleTask+0x20>)
    2ad6:	681b      	ldr	r3, [r3, #0]
    2ad8:	2b01      	cmp	r3, #1
    2ada:	d901      	bls.n	2ae0 <prvIdleTask+0x18>
			{
				taskYIELD();
    2adc:	f001 fdc8 	bl	4670 <vPortYieldFromISR>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
		        FRTOS1_vApplicationIdleHook();
    2ae0:	f7fe fe5e 	bl	17a0 <FRTOS1_vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    2ae4:	e7f4      	b.n	2ad0 <prvIdleTask+0x8>
    2ae6:	bf00      	nop
    2ae8:	2000002c 	.word	0x2000002c

00002aec <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2aec:	b580      	push	{r7, lr}
    2aee:	b086      	sub	sp, #24
    2af0:	af00      	add	r7, sp, #0
    2af2:	60f8      	str	r0, [r7, #12]
    2af4:	60b9      	str	r1, [r7, #8]
    2af6:	607a      	str	r2, [r7, #4]
    2af8:	603b      	str	r3, [r7, #0]
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2afa:	2300      	movs	r3, #0
    2afc:	617b      	str	r3, [r7, #20]
    2afe:	e012      	b.n	2b26 <prvInitialiseTCBVariables+0x3a>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    2b00:	68ba      	ldr	r2, [r7, #8]
    2b02:	697b      	ldr	r3, [r7, #20]
    2b04:	4413      	add	r3, r2
    2b06:	781a      	ldrb	r2, [r3, #0]
    2b08:	68f9      	ldr	r1, [r7, #12]
    2b0a:	697b      	ldr	r3, [r7, #20]
    2b0c:	440b      	add	r3, r1
    2b0e:	3330      	adds	r3, #48	; 0x30
    2b10:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2b12:	68ba      	ldr	r2, [r7, #8]
    2b14:	697b      	ldr	r3, [r7, #20]
    2b16:	4413      	add	r3, r2
    2b18:	781b      	ldrb	r3, [r3, #0]
    2b1a:	2b00      	cmp	r3, #0
    2b1c:	d100      	bne.n	2b20 <prvInitialiseTCBVariables+0x34>
		{
			break;
    2b1e:	e005      	b.n	2b2c <prvInitialiseTCBVariables+0x40>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2b20:	697b      	ldr	r3, [r7, #20]
    2b22:	3301      	adds	r3, #1
    2b24:	617b      	str	r3, [r7, #20]
    2b26:	697b      	ldr	r3, [r7, #20]
    2b28:	2b0b      	cmp	r3, #11
    2b2a:	d9e9      	bls.n	2b00 <prvInitialiseTCBVariables+0x14>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2b2c:	68fb      	ldr	r3, [r7, #12]
    2b2e:	2200      	movs	r2, #0
    2b30:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2b34:	687b      	ldr	r3, [r7, #4]
    2b36:	2b05      	cmp	r3, #5
    2b38:	d901      	bls.n	2b3e <prvInitialiseTCBVariables+0x52>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2b3a:	2305      	movs	r3, #5
    2b3c:	607b      	str	r3, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    2b3e:	68fb      	ldr	r3, [r7, #12]
    2b40:	687a      	ldr	r2, [r7, #4]
    2b42:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    2b44:	68fb      	ldr	r3, [r7, #12]
    2b46:	687a      	ldr	r2, [r7, #4]
    2b48:	649a      	str	r2, [r3, #72]	; 0x48
		pxTCB->uxMutexesHeld = 0;
    2b4a:	68fb      	ldr	r3, [r7, #12]
    2b4c:	2200      	movs	r2, #0
    2b4e:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2b50:	68fb      	ldr	r3, [r7, #12]
    2b52:	3304      	adds	r3, #4
    2b54:	4618      	mov	r0, r3
    2b56:	f001 fe25 	bl	47a4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2b5a:	68fb      	ldr	r3, [r7, #12]
    2b5c:	3318      	adds	r3, #24
    2b5e:	4618      	mov	r0, r3
    2b60:	f001 fe20 	bl	47a4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2b64:	68fb      	ldr	r3, [r7, #12]
    2b66:	68fa      	ldr	r2, [r7, #12]
    2b68:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2b6a:	687b      	ldr	r3, [r7, #4]
    2b6c:	f1c3 0206 	rsb	r2, r3, #6
    2b70:	68fb      	ldr	r3, [r7, #12]
    2b72:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2b74:	68fb      	ldr	r3, [r7, #12]
    2b76:	68fa      	ldr	r2, [r7, #12]
    2b78:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    2b7a:	68fb      	ldr	r3, [r7, #12]
    2b7c:	2200      	movs	r2, #0
    2b7e:	651a      	str	r2, [r3, #80]	; 0x50
		pxTCB->eNotifyState = eNotWaitingNotification;
    2b80:	68fb      	ldr	r3, [r7, #12]
    2b82:	2200      	movs	r2, #0
    2b84:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    2b88:	3718      	adds	r7, #24
    2b8a:	46bd      	mov	sp, r7
    2b8c:	bd80      	pop	{r7, pc}
    2b8e:	bf00      	nop

00002b90 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2b90:	b580      	push	{r7, lr}
    2b92:	b082      	sub	sp, #8
    2b94:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2b96:	2300      	movs	r3, #0
    2b98:	607b      	str	r3, [r7, #4]
    2b9a:	e00c      	b.n	2bb6 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2b9c:	687a      	ldr	r2, [r7, #4]
    2b9e:	4613      	mov	r3, r2
    2ba0:	009b      	lsls	r3, r3, #2
    2ba2:	4413      	add	r3, r2
    2ba4:	009b      	lsls	r3, r3, #2
    2ba6:	4a10      	ldr	r2, [pc, #64]	; (2be8 <prvInitialiseTaskLists+0x58>)
    2ba8:	4413      	add	r3, r2
    2baa:	4618      	mov	r0, r3
    2bac:	f001 fdda 	bl	4764 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2bb0:	687b      	ldr	r3, [r7, #4]
    2bb2:	3301      	adds	r3, #1
    2bb4:	607b      	str	r3, [r7, #4]
    2bb6:	687b      	ldr	r3, [r7, #4]
    2bb8:	2b05      	cmp	r3, #5
    2bba:	d9ef      	bls.n	2b9c <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2bbc:	480b      	ldr	r0, [pc, #44]	; (2bec <prvInitialiseTaskLists+0x5c>)
    2bbe:	f001 fdd1 	bl	4764 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2bc2:	480b      	ldr	r0, [pc, #44]	; (2bf0 <prvInitialiseTaskLists+0x60>)
    2bc4:	f001 fdce 	bl	4764 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2bc8:	480a      	ldr	r0, [pc, #40]	; (2bf4 <prvInitialiseTaskLists+0x64>)
    2bca:	f001 fdcb 	bl	4764 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    2bce:	480a      	ldr	r0, [pc, #40]	; (2bf8 <prvInitialiseTaskLists+0x68>)
    2bd0:	f001 fdc8 	bl	4764 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2bd4:	4b09      	ldr	r3, [pc, #36]	; (2bfc <prvInitialiseTaskLists+0x6c>)
    2bd6:	4a05      	ldr	r2, [pc, #20]	; (2bec <prvInitialiseTaskLists+0x5c>)
    2bd8:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2bda:	4b09      	ldr	r3, [pc, #36]	; (2c00 <prvInitialiseTaskLists+0x70>)
    2bdc:	4a04      	ldr	r2, [pc, #16]	; (2bf0 <prvInitialiseTaskLists+0x60>)
    2bde:	601a      	str	r2, [r3, #0]
}
    2be0:	3708      	adds	r7, #8
    2be2:	46bd      	mov	sp, r7
    2be4:	bd80      	pop	{r7, pc}
    2be6:	bf00      	nop
    2be8:	2000002c 	.word	0x2000002c
    2bec:	200000a4 	.word	0x200000a4
    2bf0:	200000b8 	.word	0x200000b8
    2bf4:	200000d4 	.word	0x200000d4
    2bf8:	200000e8 	.word	0x200000e8
    2bfc:	200000cc 	.word	0x200000cc
    2c00:	200000d0 	.word	0x200000d0

00002c04 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2c04:	b480      	push	{r7}
    2c06:	af00      	add	r7, sp, #0
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    2c08:	46bd      	mov	sp, r7
    2c0a:	f85d 7b04 	ldr.w	r7, [sp], #4
    2c0e:	4770      	bx	lr

00002c10 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    2c10:	b580      	push	{r7, lr}
    2c12:	b082      	sub	sp, #8
    2c14:	af00      	add	r7, sp, #0
    2c16:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2c18:	4b13      	ldr	r3, [pc, #76]	; (2c68 <prvAddCurrentTaskToDelayedList+0x58>)
    2c1a:	681b      	ldr	r3, [r3, #0]
    2c1c:	687a      	ldr	r2, [r7, #4]
    2c1e:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
    2c20:	4b12      	ldr	r3, [pc, #72]	; (2c6c <prvAddCurrentTaskToDelayedList+0x5c>)
    2c22:	681b      	ldr	r3, [r3, #0]
    2c24:	687a      	ldr	r2, [r7, #4]
    2c26:	429a      	cmp	r2, r3
    2c28:	d209      	bcs.n	2c3e <prvAddCurrentTaskToDelayedList+0x2e>
	{
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
		traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
#endif
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2c2a:	4b11      	ldr	r3, [pc, #68]	; (2c70 <prvAddCurrentTaskToDelayedList+0x60>)
    2c2c:	681a      	ldr	r2, [r3, #0]
    2c2e:	4b0e      	ldr	r3, [pc, #56]	; (2c68 <prvAddCurrentTaskToDelayedList+0x58>)
    2c30:	681b      	ldr	r3, [r3, #0]
    2c32:	3304      	adds	r3, #4
    2c34:	4610      	mov	r0, r2
    2c36:	4619      	mov	r1, r3
    2c38:	f001 fde4 	bl	4804 <vListInsert>
    2c3c:	e010      	b.n	2c60 <prvAddCurrentTaskToDelayedList+0x50>
	{
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
		traceMOVED_TASK_TO_DELAYED_LIST();
#endif
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2c3e:	4b0d      	ldr	r3, [pc, #52]	; (2c74 <prvAddCurrentTaskToDelayedList+0x64>)
    2c40:	681a      	ldr	r2, [r3, #0]
    2c42:	4b09      	ldr	r3, [pc, #36]	; (2c68 <prvAddCurrentTaskToDelayedList+0x58>)
    2c44:	681b      	ldr	r3, [r3, #0]
    2c46:	3304      	adds	r3, #4
    2c48:	4610      	mov	r0, r2
    2c4a:	4619      	mov	r1, r3
    2c4c:	f001 fdda 	bl	4804 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2c50:	4b09      	ldr	r3, [pc, #36]	; (2c78 <prvAddCurrentTaskToDelayedList+0x68>)
    2c52:	681b      	ldr	r3, [r3, #0]
    2c54:	687a      	ldr	r2, [r7, #4]
    2c56:	429a      	cmp	r2, r3
    2c58:	d202      	bcs.n	2c60 <prvAddCurrentTaskToDelayedList+0x50>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2c5a:	4b07      	ldr	r3, [pc, #28]	; (2c78 <prvAddCurrentTaskToDelayedList+0x68>)
    2c5c:	687a      	ldr	r2, [r7, #4]
    2c5e:	601a      	str	r2, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    2c60:	3708      	adds	r7, #8
    2c62:	46bd      	mov	sp, r7
    2c64:	bd80      	pop	{r7, pc}
    2c66:	bf00      	nop
    2c68:	20000028 	.word	0x20000028
    2c6c:	20000104 	.word	0x20000104
    2c70:	200000d0 	.word	0x200000d0
    2c74:	200000cc 	.word	0x200000cc
    2c78:	20000120 	.word	0x20000120

00002c7c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    2c7c:	b580      	push	{r7, lr}
    2c7e:	b084      	sub	sp, #16
    2c80:	af00      	add	r7, sp, #0
    2c82:	4603      	mov	r3, r0
    2c84:	6039      	str	r1, [r7, #0]
    2c86:	80fb      	strh	r3, [r7, #6]
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c88:	683b      	ldr	r3, [r7, #0]
    2c8a:	2b00      	cmp	r3, #0
    2c8c:	d106      	bne.n	2c9c <prvAllocateTCBAndStack+0x20>
    2c8e:	88fb      	ldrh	r3, [r7, #6]
    2c90:	009b      	lsls	r3, r3, #2
    2c92:	4618      	mov	r0, r3
    2c94:	f001 fe18 	bl	48c8 <pvPortMalloc>
    2c98:	4603      	mov	r3, r0
    2c9a:	e000      	b.n	2c9e <prvAllocateTCBAndStack+0x22>
    2c9c:	683b      	ldr	r3, [r7, #0]
    2c9e:	60bb      	str	r3, [r7, #8]

		if( pxStack != NULL )
    2ca0:	68bb      	ldr	r3, [r7, #8]
    2ca2:	2b00      	cmp	r3, #0
    2ca4:	d00e      	beq.n	2cc4 <prvAllocateTCBAndStack+0x48>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    2ca6:	2058      	movs	r0, #88	; 0x58
    2ca8:	f001 fe0e 	bl	48c8 <pvPortMalloc>
    2cac:	60f8      	str	r0, [r7, #12]

			if( pxNewTCB != NULL )
    2cae:	68fb      	ldr	r3, [r7, #12]
    2cb0:	2b00      	cmp	r3, #0
    2cb2:	d003      	beq.n	2cbc <prvAllocateTCBAndStack+0x40>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    2cb4:	68fb      	ldr	r3, [r7, #12]
    2cb6:	68ba      	ldr	r2, [r7, #8]
    2cb8:	631a      	str	r2, [r3, #48]	; 0x30
    2cba:	e005      	b.n	2cc8 <prvAllocateTCBAndStack+0x4c>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    2cbc:	68b8      	ldr	r0, [r7, #8]
    2cbe:	f001 febb 	bl	4a38 <vPortFree>
    2cc2:	e001      	b.n	2cc8 <prvAllocateTCBAndStack+0x4c>
			}
		}
		else
		{
			pxNewTCB = NULL;
    2cc4:	2300      	movs	r3, #0
    2cc6:	60fb      	str	r3, [r7, #12]
		}
	}
	#endif /* portSTACK_GROWTH */

	if( pxNewTCB != NULL )
    2cc8:	68fb      	ldr	r3, [r7, #12]
    2cca:	2b00      	cmp	r3, #0
    2ccc:	d008      	beq.n	2ce0 <prvAllocateTCBAndStack+0x64>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
    2cce:	68fb      	ldr	r3, [r7, #12]
    2cd0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    2cd2:	88fb      	ldrh	r3, [r7, #6]
    2cd4:	009b      	lsls	r3, r3, #2
    2cd6:	4610      	mov	r0, r2
    2cd8:	21a5      	movs	r1, #165	; 0xa5
    2cda:	461a      	mov	r2, r3
    2cdc:	f004 fa8f 	bl	71fe <memset>
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    2ce0:	68fb      	ldr	r3, [r7, #12]
}
    2ce2:	4618      	mov	r0, r3
    2ce4:	3710      	adds	r7, #16
    2ce6:	46bd      	mov	sp, r7
    2ce8:	bd80      	pop	{r7, pc}
    2cea:	bf00      	nop

00002cec <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
    2cec:	b590      	push	{r4, r7, lr}
    2cee:	b08b      	sub	sp, #44	; 0x2c
    2cf0:	af00      	add	r7, sp, #0
    2cf2:	60f8      	str	r0, [r7, #12]
    2cf4:	60b9      	str	r1, [r7, #8]
    2cf6:	4613      	mov	r3, r2
    2cf8:	71fb      	strb	r3, [r7, #7]
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
    2cfa:	2300      	movs	r3, #0
    2cfc:	627b      	str	r3, [r7, #36]	; 0x24

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    2cfe:	68bb      	ldr	r3, [r7, #8]
    2d00:	681b      	ldr	r3, [r3, #0]
    2d02:	2b00      	cmp	r3, #0
    2d04:	d078      	beq.n	2df8 <prvListTaskWithinSingleList+0x10c>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
    2d06:	68bb      	ldr	r3, [r7, #8]
    2d08:	623b      	str	r3, [r7, #32]
    2d0a:	6a3b      	ldr	r3, [r7, #32]
    2d0c:	685b      	ldr	r3, [r3, #4]
    2d0e:	685a      	ldr	r2, [r3, #4]
    2d10:	6a3b      	ldr	r3, [r7, #32]
    2d12:	605a      	str	r2, [r3, #4]
    2d14:	6a3b      	ldr	r3, [r7, #32]
    2d16:	685a      	ldr	r2, [r3, #4]
    2d18:	6a3b      	ldr	r3, [r7, #32]
    2d1a:	3308      	adds	r3, #8
    2d1c:	429a      	cmp	r2, r3
    2d1e:	d104      	bne.n	2d2a <prvListTaskWithinSingleList+0x3e>
    2d20:	6a3b      	ldr	r3, [r7, #32]
    2d22:	685b      	ldr	r3, [r3, #4]
    2d24:	685a      	ldr	r2, [r3, #4]
    2d26:	6a3b      	ldr	r3, [r7, #32]
    2d28:	605a      	str	r2, [r3, #4]
    2d2a:	6a3b      	ldr	r3, [r7, #32]
    2d2c:	685b      	ldr	r3, [r3, #4]
    2d2e:	68db      	ldr	r3, [r3, #12]
    2d30:	61fb      	str	r3, [r7, #28]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
    2d32:	68bb      	ldr	r3, [r7, #8]
    2d34:	61bb      	str	r3, [r7, #24]
    2d36:	69bb      	ldr	r3, [r7, #24]
    2d38:	685b      	ldr	r3, [r3, #4]
    2d3a:	685a      	ldr	r2, [r3, #4]
    2d3c:	69bb      	ldr	r3, [r7, #24]
    2d3e:	605a      	str	r2, [r3, #4]
    2d40:	69bb      	ldr	r3, [r7, #24]
    2d42:	685a      	ldr	r2, [r3, #4]
    2d44:	69bb      	ldr	r3, [r7, #24]
    2d46:	3308      	adds	r3, #8
    2d48:	429a      	cmp	r2, r3
    2d4a:	d104      	bne.n	2d56 <prvListTaskWithinSingleList+0x6a>
    2d4c:	69bb      	ldr	r3, [r7, #24]
    2d4e:	685b      	ldr	r3, [r3, #4]
    2d50:	685a      	ldr	r2, [r3, #4]
    2d52:	69bb      	ldr	r3, [r7, #24]
    2d54:	605a      	str	r2, [r3, #4]
    2d56:	69bb      	ldr	r3, [r7, #24]
    2d58:	685b      	ldr	r3, [r3, #4]
    2d5a:	68db      	ldr	r3, [r3, #12]
    2d5c:	617b      	str	r3, [r7, #20]

				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
    2d5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2d60:	015b      	lsls	r3, r3, #5
    2d62:	68fa      	ldr	r2, [r7, #12]
    2d64:	4413      	add	r3, r2
    2d66:	697a      	ldr	r2, [r7, #20]
    2d68:	601a      	str	r2, [r3, #0]
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
    2d6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2d6c:	015b      	lsls	r3, r3, #5
    2d6e:	68fa      	ldr	r2, [r7, #12]
    2d70:	4413      	add	r3, r2
    2d72:	697a      	ldr	r2, [r7, #20]
    2d74:	3234      	adds	r2, #52	; 0x34
    2d76:	605a      	str	r2, [r3, #4]
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
    2d78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2d7a:	015b      	lsls	r3, r3, #5
    2d7c:	68fa      	ldr	r2, [r7, #12]
    2d7e:	4413      	add	r3, r2
    2d80:	697a      	ldr	r2, [r7, #20]
    2d82:	6c12      	ldr	r2, [r2, #64]	; 0x40
    2d84:	609a      	str	r2, [r3, #8]
				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
    2d86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2d88:	015b      	lsls	r3, r3, #5
    2d8a:	68fa      	ldr	r2, [r7, #12]
    2d8c:	4413      	add	r3, r2
    2d8e:	79fa      	ldrb	r2, [r7, #7]
    2d90:	731a      	strb	r2, [r3, #12]
				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
    2d92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2d94:	015b      	lsls	r3, r3, #5
    2d96:	68fa      	ldr	r2, [r7, #12]
    2d98:	4413      	add	r3, r2
    2d9a:	697a      	ldr	r2, [r7, #20]
    2d9c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    2d9e:	611a      	str	r2, [r3, #16]
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a chance
					it is actually just blocked indefinitely - so really it should
					be reported as being in the Blocked state. */
					if( eState == eSuspended )
    2da0:	79fb      	ldrb	r3, [r7, #7]
    2da2:	2b03      	cmp	r3, #3
    2da4:	d109      	bne.n	2dba <prvListTaskWithinSingleList+0xce>
					{
						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
    2da6:	697b      	ldr	r3, [r7, #20]
    2da8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2daa:	2b00      	cmp	r3, #0
    2dac:	d005      	beq.n	2dba <prvListTaskWithinSingleList+0xce>
						{
							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
    2dae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2db0:	015b      	lsls	r3, r3, #5
    2db2:	68fa      	ldr	r2, [r7, #12]
    2db4:	4413      	add	r3, r2
    2db6:	2202      	movs	r2, #2
    2db8:	731a      	strb	r2, [r3, #12]
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
    2dba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2dbc:	015b      	lsls	r3, r3, #5
    2dbe:	68fa      	ldr	r2, [r7, #12]
    2dc0:	4413      	add	r3, r2
    2dc2:	697a      	ldr	r2, [r7, #20]
    2dc4:	6c92      	ldr	r2, [r2, #72]	; 0x48
    2dc6:	615a      	str	r2, [r3, #20]
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
    2dc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2dca:	015b      	lsls	r3, r3, #5
    2dcc:	68fa      	ldr	r2, [r7, #12]
    2dce:	4413      	add	r3, r2
    2dd0:	2200      	movs	r2, #0
    2dd2:	619a      	str	r2, [r3, #24]
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
    2dd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2dd6:	015b      	lsls	r3, r3, #5
    2dd8:	68fa      	ldr	r2, [r7, #12]
    2dda:	18d4      	adds	r4, r2, r3
    2ddc:	697b      	ldr	r3, [r7, #20]
    2dde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2de0:	4618      	mov	r0, r3
    2de2:	f000 f80f 	bl	2e04 <prvTaskCheckFreeStackSpace>
    2de6:	4603      	mov	r3, r0
    2de8:	83a3      	strh	r3, [r4, #28]
				}
				#endif

				uxTask++;
    2dea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2dec:	3301      	adds	r3, #1
    2dee:	627b      	str	r3, [r7, #36]	; 0x24

			} while( pxNextTCB != pxFirstTCB );
    2df0:	697a      	ldr	r2, [r7, #20]
    2df2:	69fb      	ldr	r3, [r7, #28]
    2df4:	429a      	cmp	r2, r3
    2df6:	d19c      	bne.n	2d32 <prvListTaskWithinSingleList+0x46>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
    2df8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
    2dfa:	4618      	mov	r0, r3
    2dfc:	372c      	adds	r7, #44	; 0x2c
    2dfe:	46bd      	mov	sp, r7
    2e00:	bd90      	pop	{r4, r7, pc}
    2e02:	bf00      	nop

00002e04 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
    2e04:	b480      	push	{r7}
    2e06:	b085      	sub	sp, #20
    2e08:	af00      	add	r7, sp, #0
    2e0a:	6078      	str	r0, [r7, #4]
	uint32_t ulCount = 0U;
    2e0c:	2300      	movs	r3, #0
    2e0e:	60fb      	str	r3, [r7, #12]

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    2e10:	e005      	b.n	2e1e <prvTaskCheckFreeStackSpace+0x1a>
		{
			pucStackByte -= portSTACK_GROWTH;
    2e12:	687b      	ldr	r3, [r7, #4]
    2e14:	3301      	adds	r3, #1
    2e16:	607b      	str	r3, [r7, #4]
			ulCount++;
    2e18:	68fb      	ldr	r3, [r7, #12]
    2e1a:	3301      	adds	r3, #1
    2e1c:	60fb      	str	r3, [r7, #12]

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    2e1e:	687b      	ldr	r3, [r7, #4]
    2e20:	781b      	ldrb	r3, [r3, #0]
    2e22:	2ba5      	cmp	r3, #165	; 0xa5
    2e24:	d0f5      	beq.n	2e12 <prvTaskCheckFreeStackSpace+0xe>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
    2e26:	68fb      	ldr	r3, [r7, #12]
    2e28:	089b      	lsrs	r3, r3, #2
    2e2a:	60fb      	str	r3, [r7, #12]

		return ( uint16_t ) ulCount;
    2e2c:	68fb      	ldr	r3, [r7, #12]
    2e2e:	b29b      	uxth	r3, r3
	}
    2e30:	4618      	mov	r0, r3
    2e32:	3714      	adds	r7, #20
    2e34:	46bd      	mov	sp, r7
    2e36:	f85d 7b04 	ldr.w	r7, [sp], #4
    2e3a:	4770      	bx	lr

00002e3c <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
    2e3c:	b580      	push	{r7, lr}
    2e3e:	b086      	sub	sp, #24
    2e40:	af00      	add	r7, sp, #0
    2e42:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2e44:	687b      	ldr	r3, [r7, #4]
    2e46:	2b00      	cmp	r3, #0
    2e48:	d102      	bne.n	2e50 <uxTaskGetStackHighWaterMark+0x14>
    2e4a:	4b09      	ldr	r3, [pc, #36]	; (2e70 <uxTaskGetStackHighWaterMark+0x34>)
    2e4c:	681b      	ldr	r3, [r3, #0]
    2e4e:	e000      	b.n	2e52 <uxTaskGetStackHighWaterMark+0x16>
    2e50:	687b      	ldr	r3, [r7, #4]
    2e52:	617b      	str	r3, [r7, #20]

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
    2e54:	697b      	ldr	r3, [r7, #20]
    2e56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    2e58:	613b      	str	r3, [r7, #16]
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
    2e5a:	6938      	ldr	r0, [r7, #16]
    2e5c:	f7ff ffd2 	bl	2e04 <prvTaskCheckFreeStackSpace>
    2e60:	4603      	mov	r3, r0
    2e62:	60fb      	str	r3, [r7, #12]

		return uxReturn;
    2e64:	68fb      	ldr	r3, [r7, #12]
	}
    2e66:	4618      	mov	r0, r3
    2e68:	3718      	adds	r7, #24
    2e6a:	46bd      	mov	sp, r7
    2e6c:	bd80      	pop	{r7, pc}
    2e6e:	bf00      	nop
    2e70:	20000028 	.word	0x20000028

00002e74 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2e74:	b480      	push	{r7}
    2e76:	b083      	sub	sp, #12
    2e78:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2e7a:	4b0e      	ldr	r3, [pc, #56]	; (2eb4 <prvResetNextTaskUnblockTime+0x40>)
    2e7c:	681b      	ldr	r3, [r3, #0]
    2e7e:	681b      	ldr	r3, [r3, #0]
    2e80:	2b00      	cmp	r3, #0
    2e82:	d101      	bne.n	2e88 <prvResetNextTaskUnblockTime+0x14>
    2e84:	2301      	movs	r3, #1
    2e86:	e000      	b.n	2e8a <prvResetNextTaskUnblockTime+0x16>
    2e88:	2300      	movs	r3, #0
    2e8a:	2b00      	cmp	r3, #0
    2e8c:	d004      	beq.n	2e98 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2e8e:	4b0a      	ldr	r3, [pc, #40]	; (2eb8 <prvResetNextTaskUnblockTime+0x44>)
    2e90:	f04f 32ff 	mov.w	r2, #4294967295
    2e94:	601a      	str	r2, [r3, #0]
    2e96:	e008      	b.n	2eaa <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2e98:	4b06      	ldr	r3, [pc, #24]	; (2eb4 <prvResetNextTaskUnblockTime+0x40>)
    2e9a:	681b      	ldr	r3, [r3, #0]
    2e9c:	68db      	ldr	r3, [r3, #12]
    2e9e:	68db      	ldr	r3, [r3, #12]
    2ea0:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    2ea2:	687b      	ldr	r3, [r7, #4]
    2ea4:	685a      	ldr	r2, [r3, #4]
    2ea6:	4b04      	ldr	r3, [pc, #16]	; (2eb8 <prvResetNextTaskUnblockTime+0x44>)
    2ea8:	601a      	str	r2, [r3, #0]
	}
}
    2eaa:	370c      	adds	r7, #12
    2eac:	46bd      	mov	sp, r7
    2eae:	f85d 7b04 	ldr.w	r7, [sp], #4
    2eb2:	4770      	bx	lr
    2eb4:	200000cc 	.word	0x200000cc
    2eb8:	20000120 	.word	0x20000120

00002ebc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    2ebc:	b480      	push	{r7}
    2ebe:	b083      	sub	sp, #12
    2ec0:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2ec2:	4b05      	ldr	r3, [pc, #20]	; (2ed8 <xTaskGetCurrentTaskHandle+0x1c>)
    2ec4:	681b      	ldr	r3, [r3, #0]
    2ec6:	607b      	str	r3, [r7, #4]

		return xReturn;
    2ec8:	687b      	ldr	r3, [r7, #4]
	}
    2eca:	4618      	mov	r0, r3
    2ecc:	370c      	adds	r7, #12
    2ece:	46bd      	mov	sp, r7
    2ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
    2ed4:	4770      	bx	lr
    2ed6:	bf00      	nop
    2ed8:	20000028 	.word	0x20000028

00002edc <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
    2edc:	b480      	push	{r7}
    2ede:	b083      	sub	sp, #12
    2ee0:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2ee2:	4b0b      	ldr	r3, [pc, #44]	; (2f10 <xTaskGetSchedulerState+0x34>)
    2ee4:	681b      	ldr	r3, [r3, #0]
    2ee6:	2b00      	cmp	r3, #0
    2ee8:	d102      	bne.n	2ef0 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2eea:	2301      	movs	r3, #1
    2eec:	607b      	str	r3, [r7, #4]
    2eee:	e008      	b.n	2f02 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2ef0:	4b08      	ldr	r3, [pc, #32]	; (2f14 <xTaskGetSchedulerState+0x38>)
    2ef2:	681b      	ldr	r3, [r3, #0]
    2ef4:	2b00      	cmp	r3, #0
    2ef6:	d102      	bne.n	2efe <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
    2ef8:	2302      	movs	r3, #2
    2efa:	607b      	str	r3, [r7, #4]
    2efc:	e001      	b.n	2f02 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2efe:	2300      	movs	r3, #0
    2f00:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
    2f02:	687b      	ldr	r3, [r7, #4]
	}
    2f04:	4618      	mov	r0, r3
    2f06:	370c      	adds	r7, #12
    2f08:	46bd      	mov	sp, r7
    2f0a:	f85d 7b04 	ldr.w	r7, [sp], #4
    2f0e:	4770      	bx	lr
    2f10:	2000010c 	.word	0x2000010c
    2f14:	20000124 	.word	0x20000124

00002f18 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    2f18:	b580      	push	{r7, lr}
    2f1a:	b084      	sub	sp, #16
    2f1c:	af00      	add	r7, sp, #0
    2f1e:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    2f20:	687b      	ldr	r3, [r7, #4]
    2f22:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    2f24:	687b      	ldr	r3, [r7, #4]
    2f26:	2b00      	cmp	r3, #0
    2f28:	d04a      	beq.n	2fc0 <vTaskPriorityInherit+0xa8>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2f2a:	68fb      	ldr	r3, [r7, #12]
    2f2c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2f2e:	4b26      	ldr	r3, [pc, #152]	; (2fc8 <vTaskPriorityInherit+0xb0>)
    2f30:	681b      	ldr	r3, [r3, #0]
    2f32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2f34:	429a      	cmp	r2, r3
    2f36:	d243      	bcs.n	2fc0 <vTaskPriorityInherit+0xa8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2f38:	68fb      	ldr	r3, [r7, #12]
    2f3a:	699b      	ldr	r3, [r3, #24]
    2f3c:	2b00      	cmp	r3, #0
    2f3e:	db06      	blt.n	2f4e <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f40:	4b21      	ldr	r3, [pc, #132]	; (2fc8 <vTaskPriorityInherit+0xb0>)
    2f42:	681b      	ldr	r3, [r3, #0]
    2f44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2f46:	f1c3 0206 	rsb	r2, r3, #6
    2f4a:	68fb      	ldr	r3, [r7, #12]
    2f4c:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2f4e:	68fb      	ldr	r3, [r7, #12]
    2f50:	6959      	ldr	r1, [r3, #20]
    2f52:	68fb      	ldr	r3, [r7, #12]
    2f54:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2f56:	4613      	mov	r3, r2
    2f58:	009b      	lsls	r3, r3, #2
    2f5a:	4413      	add	r3, r2
    2f5c:	009b      	lsls	r3, r3, #2
    2f5e:	4a1b      	ldr	r2, [pc, #108]	; (2fcc <vTaskPriorityInherit+0xb4>)
    2f60:	4413      	add	r3, r2
    2f62:	4299      	cmp	r1, r3
    2f64:	d101      	bne.n	2f6a <vTaskPriorityInherit+0x52>
    2f66:	2301      	movs	r3, #1
    2f68:	e000      	b.n	2f6c <vTaskPriorityInherit+0x54>
    2f6a:	2300      	movs	r3, #0
    2f6c:	2b00      	cmp	r3, #0
    2f6e:	d022      	beq.n	2fb6 <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2f70:	68fb      	ldr	r3, [r7, #12]
    2f72:	3304      	adds	r3, #4
    2f74:	4618      	mov	r0, r3
    2f76:	f001 fc7d 	bl	4874 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2f7a:	4b13      	ldr	r3, [pc, #76]	; (2fc8 <vTaskPriorityInherit+0xb0>)
    2f7c:	681b      	ldr	r3, [r3, #0]
    2f7e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2f80:	68fb      	ldr	r3, [r7, #12]
    2f82:	62da      	str	r2, [r3, #44]	; 0x2c
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
					prvReAddTaskToReadyList( pxTCB );
#else
					prvAddTaskToReadyList( pxTCB );
    2f84:	68fb      	ldr	r3, [r7, #12]
    2f86:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2f88:	4b11      	ldr	r3, [pc, #68]	; (2fd0 <vTaskPriorityInherit+0xb8>)
    2f8a:	681b      	ldr	r3, [r3, #0]
    2f8c:	429a      	cmp	r2, r3
    2f8e:	d903      	bls.n	2f98 <vTaskPriorityInherit+0x80>
    2f90:	68fb      	ldr	r3, [r7, #12]
    2f92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2f94:	4b0e      	ldr	r3, [pc, #56]	; (2fd0 <vTaskPriorityInherit+0xb8>)
    2f96:	601a      	str	r2, [r3, #0]
    2f98:	68fb      	ldr	r3, [r7, #12]
    2f9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2f9c:	4613      	mov	r3, r2
    2f9e:	009b      	lsls	r3, r3, #2
    2fa0:	4413      	add	r3, r2
    2fa2:	009b      	lsls	r3, r3, #2
    2fa4:	4a09      	ldr	r2, [pc, #36]	; (2fcc <vTaskPriorityInherit+0xb4>)
    2fa6:	441a      	add	r2, r3
    2fa8:	68fb      	ldr	r3, [r7, #12]
    2faa:	3304      	adds	r3, #4
    2fac:	4610      	mov	r0, r2
    2fae:	4619      	mov	r1, r3
    2fb0:	f001 fc04 	bl	47bc <vListInsertEnd>
    2fb4:	e004      	b.n	2fc0 <vTaskPriorityInherit+0xa8>
#endif
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2fb6:	4b04      	ldr	r3, [pc, #16]	; (2fc8 <vTaskPriorityInherit+0xb0>)
    2fb8:	681b      	ldr	r3, [r3, #0]
    2fba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    2fbc:	68fb      	ldr	r3, [r7, #12]
    2fbe:	62da      	str	r2, [r3, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2fc0:	3710      	adds	r7, #16
    2fc2:	46bd      	mov	sp, r7
    2fc4:	bd80      	pop	{r7, pc}
    2fc6:	bf00      	nop
    2fc8:	20000028 	.word	0x20000028
    2fcc:	2000002c 	.word	0x2000002c
    2fd0:	20000108 	.word	0x20000108

00002fd4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2fd4:	b580      	push	{r7, lr}
    2fd6:	b084      	sub	sp, #16
    2fd8:	af00      	add	r7, sp, #0
    2fda:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
    2fdc:	687b      	ldr	r3, [r7, #4]
    2fde:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
    2fe0:	2300      	movs	r3, #0
    2fe2:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
    2fe4:	687b      	ldr	r3, [r7, #4]
    2fe6:	2b00      	cmp	r3, #0
    2fe8:	d04a      	beq.n	3080 <xTaskPriorityDisinherit+0xac>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
    2fea:	4b28      	ldr	r3, [pc, #160]	; (308c <xTaskPriorityDisinherit+0xb8>)
    2fec:	681b      	ldr	r3, [r3, #0]
    2fee:	68ba      	ldr	r2, [r7, #8]
    2ff0:	429a      	cmp	r2, r3
    2ff2:	d004      	beq.n	2ffe <xTaskPriorityDisinherit+0x2a>
    2ff4:	f04f 0050 	mov.w	r0, #80	; 0x50
    2ff8:	f380 8811 	msr	BASEPRI, r0
    2ffc:	e7fe      	b.n	2ffc <xTaskPriorityDisinherit+0x28>

			configASSERT( pxTCB->uxMutexesHeld );
    2ffe:	68bb      	ldr	r3, [r7, #8]
    3000:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    3002:	2b00      	cmp	r3, #0
    3004:	d104      	bne.n	3010 <xTaskPriorityDisinherit+0x3c>
    3006:	f04f 0050 	mov.w	r0, #80	; 0x50
    300a:	f380 8811 	msr	BASEPRI, r0
    300e:	e7fe      	b.n	300e <xTaskPriorityDisinherit+0x3a>
			( pxTCB->uxMutexesHeld )--;
    3010:	68bb      	ldr	r3, [r7, #8]
    3012:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    3014:	1e5a      	subs	r2, r3, #1
    3016:	68bb      	ldr	r3, [r7, #8]
    3018:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    301a:	68bb      	ldr	r3, [r7, #8]
    301c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    301e:	68bb      	ldr	r3, [r7, #8]
    3020:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3022:	429a      	cmp	r2, r3
    3024:	d02c      	beq.n	3080 <xTaskPriorityDisinherit+0xac>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3026:	68bb      	ldr	r3, [r7, #8]
    3028:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    302a:	2b00      	cmp	r3, #0
    302c:	d128      	bne.n	3080 <xTaskPriorityDisinherit+0xac>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    302e:	68bb      	ldr	r3, [r7, #8]
    3030:	3304      	adds	r3, #4
    3032:	4618      	mov	r0, r3
    3034:	f001 fc1e 	bl	4874 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    3038:	68bb      	ldr	r3, [r7, #8]
    303a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    303c:	68bb      	ldr	r3, [r7, #8]
    303e:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3040:	68bb      	ldr	r3, [r7, #8]
    3042:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3044:	f1c3 0206 	rsb	r2, r3, #6
    3048:	68bb      	ldr	r3, [r7, #8]
    304a:	619a      	str	r2, [r3, #24]
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
					prvReAddTaskToReadyList( pxTCB );
#else
					prvAddTaskToReadyList( pxTCB );
    304c:	68bb      	ldr	r3, [r7, #8]
    304e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3050:	4b0f      	ldr	r3, [pc, #60]	; (3090 <xTaskPriorityDisinherit+0xbc>)
    3052:	681b      	ldr	r3, [r3, #0]
    3054:	429a      	cmp	r2, r3
    3056:	d903      	bls.n	3060 <xTaskPriorityDisinherit+0x8c>
    3058:	68bb      	ldr	r3, [r7, #8]
    305a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    305c:	4b0c      	ldr	r3, [pc, #48]	; (3090 <xTaskPriorityDisinherit+0xbc>)
    305e:	601a      	str	r2, [r3, #0]
    3060:	68bb      	ldr	r3, [r7, #8]
    3062:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3064:	4613      	mov	r3, r2
    3066:	009b      	lsls	r3, r3, #2
    3068:	4413      	add	r3, r2
    306a:	009b      	lsls	r3, r3, #2
    306c:	4a09      	ldr	r2, [pc, #36]	; (3094 <xTaskPriorityDisinherit+0xc0>)
    306e:	441a      	add	r2, r3
    3070:	68bb      	ldr	r3, [r7, #8]
    3072:	3304      	adds	r3, #4
    3074:	4610      	mov	r0, r2
    3076:	4619      	mov	r1, r3
    3078:	f001 fba0 	bl	47bc <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    307c:	2301      	movs	r3, #1
    307e:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3080:	68fb      	ldr	r3, [r7, #12]
	}
    3082:	4618      	mov	r0, r3
    3084:	3710      	adds	r7, #16
    3086:	46bd      	mov	sp, r7
    3088:	bd80      	pop	{r7, pc}
    308a:	bf00      	nop
    308c:	20000028 	.word	0x20000028
    3090:	20000108 	.word	0x20000108
    3094:	2000002c 	.word	0x2000002c

00003098 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	void vTaskList( char * pcWriteBuffer, size_t bufSize)
	{
    3098:	b580      	push	{r7, lr}
    309a:	b088      	sub	sp, #32
    309c:	af02      	add	r7, sp, #8
    309e:	6078      	str	r0, [r7, #4]
    30a0:	6039      	str	r1, [r7, #0]
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = 0x00;
    30a2:	687b      	ldr	r3, [r7, #4]
    30a4:	2200      	movs	r2, #0
    30a6:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
    30a8:	4b48      	ldr	r3, [pc, #288]	; (31cc <vTaskList+0x134>)
    30aa:	681b      	ldr	r3, [r3, #0]
    30ac:	60fb      	str	r3, [r7, #12]

		/* Allocate an array index for each task. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
    30ae:	4b47      	ldr	r3, [pc, #284]	; (31cc <vTaskList+0x134>)
    30b0:	681b      	ldr	r3, [r3, #0]
    30b2:	015b      	lsls	r3, r3, #5
    30b4:	4618      	mov	r0, r3
    30b6:	f001 fc07 	bl	48c8 <pvPortMalloc>
    30ba:	6138      	str	r0, [r7, #16]

		if( pxTaskStatusArray != NULL )
    30bc:	693b      	ldr	r3, [r7, #16]
    30be:	2b00      	cmp	r3, #0
    30c0:	f000 8081 	beq.w	31c6 <vTaskList+0x12e>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
    30c4:	68fb      	ldr	r3, [r7, #12]
    30c6:	6938      	ldr	r0, [r7, #16]
    30c8:	4619      	mov	r1, r3
    30ca:	2200      	movs	r2, #0
    30cc:	f7ff f970 	bl	23b0 <uxTaskGetSystemState>
    30d0:	4603      	mov	r3, r0
    30d2:	60fb      	str	r3, [r7, #12]

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
    30d4:	2300      	movs	r3, #0
    30d6:	60bb      	str	r3, [r7, #8]
    30d8:	e06e      	b.n	31b8 <vTaskList+0x120>
			{
				switch( pxTaskStatusArray[ x ].eCurrentState )
    30da:	68bb      	ldr	r3, [r7, #8]
    30dc:	015b      	lsls	r3, r3, #5
    30de:	693a      	ldr	r2, [r7, #16]
    30e0:	4413      	add	r3, r2
    30e2:	7b1b      	ldrb	r3, [r3, #12]
    30e4:	3b01      	subs	r3, #1
    30e6:	2b03      	cmp	r3, #3
    30e8:	d816      	bhi.n	3118 <vTaskList+0x80>
    30ea:	a201      	add	r2, pc, #4	; (adr r2, 30f0 <vTaskList+0x58>)
    30ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    30f0:	00003101 	.word	0x00003101
    30f4:	00003107 	.word	0x00003107
    30f8:	0000310d 	.word	0x0000310d
    30fc:	00003113 	.word	0x00003113
				{
					case eReady:		cStatus = tskREADY_CHAR;
    3100:	2352      	movs	r3, #82	; 0x52
    3102:	75fb      	strb	r3, [r7, #23]
										break;
    3104:	e00b      	b.n	311e <vTaskList+0x86>

					case eBlocked:		cStatus = tskBLOCKED_CHAR;
    3106:	2342      	movs	r3, #66	; 0x42
    3108:	75fb      	strb	r3, [r7, #23]
										break;
    310a:	e008      	b.n	311e <vTaskList+0x86>

					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
    310c:	2353      	movs	r3, #83	; 0x53
    310e:	75fb      	strb	r3, [r7, #23]
										break;
    3110:	e005      	b.n	311e <vTaskList+0x86>

					case eDeleted:		cStatus = tskDELETED_CHAR;
    3112:	2344      	movs	r3, #68	; 0x44
    3114:	75fb      	strb	r3, [r7, #23]
										break;
    3116:	e002      	b.n	311e <vTaskList+0x86>

					default:			/* Should not get here, but it is included
										to prevent static checking errors. */
										cStatus = 0x00;
    3118:	2300      	movs	r3, #0
    311a:	75fb      	strb	r3, [r7, #23]
										break;
    311c:	bf00      	nop

				/* Write the rest of the string. */
				sprintf( ( char * ) pcWriteBuffer, ( char * ) "\t\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
				pcWriteBuffer += strlen( pcWriteBuffer );
#else /* << EST */
        UTIL1_strcatPad((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)pxTaskStatusArray[ x ].pcTaskName, ' ', configMAX_TASK_NAME_LEN);
    311e:	68bb      	ldr	r3, [r7, #8]
    3120:	015b      	lsls	r3, r3, #5
    3122:	693a      	ldr	r2, [r7, #16]
    3124:	4413      	add	r3, r2
    3126:	685b      	ldr	r3, [r3, #4]
    3128:	220c      	movs	r2, #12
    312a:	9200      	str	r2, [sp, #0]
    312c:	6878      	ldr	r0, [r7, #4]
    312e:	6839      	ldr	r1, [r7, #0]
    3130:	461a      	mov	r2, r3
    3132:	2320      	movs	r3, #32
    3134:	f003 fd64 	bl	6c00 <UTIL1_strcatPad>
	      UTIL1_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\t");
    3138:	6878      	ldr	r0, [r7, #4]
    313a:	6839      	ldr	r1, [r7, #0]
    313c:	4a24      	ldr	r2, [pc, #144]	; (31d0 <vTaskList+0x138>)
    313e:	f002 f85f 	bl	5200 <UTIL1_strcat>
	      UTIL1_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)cStatus);
    3142:	7dfb      	ldrb	r3, [r7, #23]
    3144:	6878      	ldr	r0, [r7, #4]
    3146:	6839      	ldr	r1, [r7, #0]
    3148:	461a      	mov	r2, r3
    314a:	f002 f88b 	bl	5264 <UTIL1_chcat>
	      UTIL1_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
    314e:	6878      	ldr	r0, [r7, #4]
    3150:	6839      	ldr	r1, [r7, #0]
    3152:	2209      	movs	r2, #9
    3154:	f002 f886 	bl	5264 <UTIL1_chcat>
	      UTIL1_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].uxCurrentPriority);
    3158:	68bb      	ldr	r3, [r7, #8]
    315a:	015b      	lsls	r3, r3, #5
    315c:	693a      	ldr	r2, [r7, #16]
    315e:	4413      	add	r3, r2
    3160:	691b      	ldr	r3, [r3, #16]
    3162:	6878      	ldr	r0, [r7, #4]
    3164:	6839      	ldr	r1, [r7, #0]
    3166:	461a      	mov	r2, r3
    3168:	f002 fc44 	bl	59f4 <UTIL1_strcatNum32u>
	      UTIL1_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
    316c:	6878      	ldr	r0, [r7, #4]
    316e:	6839      	ldr	r1, [r7, #0]
    3170:	2209      	movs	r2, #9
    3172:	f002 f877 	bl	5264 <UTIL1_chcat>
	      UTIL1_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].usStackHighWaterMark);
    3176:	68bb      	ldr	r3, [r7, #8]
    3178:	015b      	lsls	r3, r3, #5
    317a:	693a      	ldr	r2, [r7, #16]
    317c:	4413      	add	r3, r2
    317e:	8b9b      	ldrh	r3, [r3, #28]
    3180:	6878      	ldr	r0, [r7, #4]
    3182:	6839      	ldr	r1, [r7, #0]
    3184:	461a      	mov	r2, r3
    3186:	f002 fc35 	bl	59f4 <UTIL1_strcatNum32u>
	      UTIL1_chcat((uint8_t*)pcWriteBuffer, bufSize, (unsigned char)'\t');
    318a:	6878      	ldr	r0, [r7, #4]
    318c:	6839      	ldr	r1, [r7, #0]
    318e:	2209      	movs	r2, #9
    3190:	f002 f868 	bl	5264 <UTIL1_chcat>
	      UTIL1_strcatNum32u((uint8_t*)pcWriteBuffer, bufSize, pxTaskStatusArray[ x ].xTaskNumber);
    3194:	68bb      	ldr	r3, [r7, #8]
    3196:	015b      	lsls	r3, r3, #5
    3198:	693a      	ldr	r2, [r7, #16]
    319a:	4413      	add	r3, r2
    319c:	689b      	ldr	r3, [r3, #8]
    319e:	6878      	ldr	r0, [r7, #4]
    31a0:	6839      	ldr	r1, [r7, #0]
    31a2:	461a      	mov	r2, r3
    31a4:	f002 fc26 	bl	59f4 <UTIL1_strcatNum32u>
	      UTIL1_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
    31a8:	6878      	ldr	r0, [r7, #4]
    31aa:	6839      	ldr	r1, [r7, #0]
    31ac:	4a09      	ldr	r2, [pc, #36]	; (31d4 <vTaskList+0x13c>)
    31ae:	f002 f827 	bl	5200 <UTIL1_strcat>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
    31b2:	68bb      	ldr	r3, [r7, #8]
    31b4:	3301      	adds	r3, #1
    31b6:	60bb      	str	r3, [r7, #8]
    31b8:	68ba      	ldr	r2, [r7, #8]
    31ba:	68fb      	ldr	r3, [r7, #12]
    31bc:	429a      	cmp	r2, r3
    31be:	d38c      	bcc.n	30da <vTaskList+0x42>
	      UTIL1_strcat((uint8_t*)pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
#endif
			}

			/* Free the array again. */
			vPortFree( pxTaskStatusArray );
    31c0:	6938      	ldr	r0, [r7, #16]
    31c2:	f001 fc39 	bl	4a38 <vPortFree>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    31c6:	3718      	adds	r7, #24
    31c8:	46bd      	mov	sp, r7
    31ca:	bd80      	pop	{r7, pc}
    31cc:	20000100 	.word	0x20000100
    31d0:	000073fc 	.word	0x000073fc
    31d4:	00007400 	.word	0x00007400

000031d8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    31d8:	b480      	push	{r7}
    31da:	b083      	sub	sp, #12
    31dc:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    31de:	4b09      	ldr	r3, [pc, #36]	; (3204 <uxTaskResetEventItemValue+0x2c>)
    31e0:	681b      	ldr	r3, [r3, #0]
    31e2:	699b      	ldr	r3, [r3, #24]
    31e4:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    31e6:	4b07      	ldr	r3, [pc, #28]	; (3204 <uxTaskResetEventItemValue+0x2c>)
    31e8:	681b      	ldr	r3, [r3, #0]
    31ea:	4a06      	ldr	r2, [pc, #24]	; (3204 <uxTaskResetEventItemValue+0x2c>)
    31ec:	6812      	ldr	r2, [r2, #0]
    31ee:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    31f0:	f1c2 0206 	rsb	r2, r2, #6
    31f4:	619a      	str	r2, [r3, #24]

	return uxReturn;
    31f6:	687b      	ldr	r3, [r7, #4]
}
    31f8:	4618      	mov	r0, r3
    31fa:	370c      	adds	r7, #12
    31fc:	46bd      	mov	sp, r7
    31fe:	f85d 7b04 	ldr.w	r7, [sp], #4
    3202:	4770      	bx	lr
    3204:	20000028 	.word	0x20000028

00003208 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
    3208:	b480      	push	{r7}
    320a:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    320c:	4b07      	ldr	r3, [pc, #28]	; (322c <pvTaskIncrementMutexHeldCount+0x24>)
    320e:	681b      	ldr	r3, [r3, #0]
    3210:	2b00      	cmp	r3, #0
    3212:	d004      	beq.n	321e <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3214:	4b05      	ldr	r3, [pc, #20]	; (322c <pvTaskIncrementMutexHeldCount+0x24>)
    3216:	681b      	ldr	r3, [r3, #0]
    3218:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    321a:	3201      	adds	r2, #1
    321c:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
    321e:	4b03      	ldr	r3, [pc, #12]	; (322c <pvTaskIncrementMutexHeldCount+0x24>)
    3220:	681b      	ldr	r3, [r3, #0]
	}
    3222:	4618      	mov	r0, r3
    3224:	46bd      	mov	sp, r7
    3226:	f85d 7b04 	ldr.w	r7, [sp], #4
    322a:	4770      	bx	lr
    322c:	20000028 	.word	0x20000028

00003230 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3230:	b580      	push	{r7, lr}
    3232:	b084      	sub	sp, #16
    3234:	af00      	add	r7, sp, #0
    3236:	6078      	str	r0, [r7, #4]
    3238:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    323a:	f001 f9ed 	bl	4618 <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    323e:	4b26      	ldr	r3, [pc, #152]	; (32d8 <ulTaskNotifyTake+0xa8>)
    3240:	681b      	ldr	r3, [r3, #0]
    3242:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    3244:	2b00      	cmp	r3, #0
    3246:	d123      	bne.n	3290 <ulTaskNotifyTake+0x60>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    3248:	4b23      	ldr	r3, [pc, #140]	; (32d8 <ulTaskNotifyTake+0xa8>)
    324a:	681b      	ldr	r3, [r3, #0]
    324c:	2201      	movs	r2, #1
    324e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

				if( xTicksToWait > ( TickType_t ) 0 )
    3252:	683b      	ldr	r3, [r7, #0]
    3254:	2b00      	cmp	r3, #0
    3256:	d01b      	beq.n	3290 <ulTaskNotifyTake+0x60>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3258:	4b1f      	ldr	r3, [pc, #124]	; (32d8 <ulTaskNotifyTake+0xa8>)
    325a:	681b      	ldr	r3, [r3, #0]
    325c:	3304      	adds	r3, #4
    325e:	4618      	mov	r0, r3
    3260:	f001 fb08 	bl	4874 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    3264:	683b      	ldr	r3, [r7, #0]
    3266:	f1b3 3fff 	cmp.w	r3, #4294967295
    326a:	d107      	bne.n	327c <ulTaskNotifyTake+0x4c>
							woken by a timing event.  It will block
							indefinitely. */
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
							traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
#endif
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    326c:	4b1a      	ldr	r3, [pc, #104]	; (32d8 <ulTaskNotifyTake+0xa8>)
    326e:	681b      	ldr	r3, [r3, #0]
    3270:	3304      	adds	r3, #4
    3272:	481a      	ldr	r0, [pc, #104]	; (32dc <ulTaskNotifyTake+0xac>)
    3274:	4619      	mov	r1, r3
    3276:	f001 faa1 	bl	47bc <vListInsertEnd>
    327a:	e007      	b.n	328c <ulTaskNotifyTake+0x5c>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    327c:	4b18      	ldr	r3, [pc, #96]	; (32e0 <ulTaskNotifyTake+0xb0>)
    327e:	681a      	ldr	r2, [r3, #0]
    3280:	683b      	ldr	r3, [r7, #0]
    3282:	4413      	add	r3, r2
    3284:	60fb      	str	r3, [r7, #12]
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    3286:	68f8      	ldr	r0, [r7, #12]
    3288:	f7ff fcc2 	bl	2c10 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    328c:	f001 f9f0 	bl	4670 <vPortYieldFromISR>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3290:	f001 f9d8 	bl	4644 <vPortExitCritical>

		taskENTER_CRITICAL();
    3294:	f001 f9c0 	bl	4618 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3298:	4b0f      	ldr	r3, [pc, #60]	; (32d8 <ulTaskNotifyTake+0xa8>)
    329a:	681b      	ldr	r3, [r3, #0]
    329c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    329e:	60bb      	str	r3, [r7, #8]

			if( ulReturn != 0UL )
    32a0:	68bb      	ldr	r3, [r7, #8]
    32a2:	2b00      	cmp	r3, #0
    32a4:	d00c      	beq.n	32c0 <ulTaskNotifyTake+0x90>
			{
				if( xClearCountOnExit != pdFALSE )
    32a6:	687b      	ldr	r3, [r7, #4]
    32a8:	2b00      	cmp	r3, #0
    32aa:	d004      	beq.n	32b6 <ulTaskNotifyTake+0x86>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    32ac:	4b0a      	ldr	r3, [pc, #40]	; (32d8 <ulTaskNotifyTake+0xa8>)
    32ae:	681b      	ldr	r3, [r3, #0]
    32b0:	2200      	movs	r2, #0
    32b2:	651a      	str	r2, [r3, #80]	; 0x50
    32b4:	e004      	b.n	32c0 <ulTaskNotifyTake+0x90>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    32b6:	4b08      	ldr	r3, [pc, #32]	; (32d8 <ulTaskNotifyTake+0xa8>)
    32b8:	681b      	ldr	r3, [r3, #0]
    32ba:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    32bc:	3a01      	subs	r2, #1
    32be:	651a      	str	r2, [r3, #80]	; 0x50
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    32c0:	4b05      	ldr	r3, [pc, #20]	; (32d8 <ulTaskNotifyTake+0xa8>)
    32c2:	681b      	ldr	r3, [r3, #0]
    32c4:	2200      	movs	r2, #0
    32c6:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
		}
		taskEXIT_CRITICAL();
    32ca:	f001 f9bb 	bl	4644 <vPortExitCritical>

		return ulReturn;
    32ce:	68bb      	ldr	r3, [r7, #8]
	}
    32d0:	4618      	mov	r0, r3
    32d2:	3710      	adds	r7, #16
    32d4:	46bd      	mov	sp, r7
    32d6:	bd80      	pop	{r7, pc}
    32d8:	20000028 	.word	0x20000028
    32dc:	200000e8 	.word	0x200000e8
    32e0:	20000104 	.word	0x20000104

000032e4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    32e4:	b580      	push	{r7, lr}
    32e6:	b086      	sub	sp, #24
    32e8:	af00      	add	r7, sp, #0
    32ea:	60f8      	str	r0, [r7, #12]
    32ec:	60b9      	str	r1, [r7, #8]
    32ee:	607a      	str	r2, [r7, #4]
    32f0:	603b      	str	r3, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    32f2:	f001 f991 	bl	4618 <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    32f6:	4b2e      	ldr	r3, [pc, #184]	; (33b0 <xTaskNotifyWait+0xcc>)
    32f8:	681b      	ldr	r3, [r3, #0]
    32fa:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    32fe:	b2db      	uxtb	r3, r3
    3300:	2b02      	cmp	r3, #2
    3302:	d02a      	beq.n	335a <xTaskNotifyWait+0x76>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3304:	4b2a      	ldr	r3, [pc, #168]	; (33b0 <xTaskNotifyWait+0xcc>)
    3306:	681b      	ldr	r3, [r3, #0]
    3308:	6d19      	ldr	r1, [r3, #80]	; 0x50
    330a:	68fa      	ldr	r2, [r7, #12]
    330c:	43d2      	mvns	r2, r2
    330e:	400a      	ands	r2, r1
    3310:	651a      	str	r2, [r3, #80]	; 0x50

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    3312:	4b27      	ldr	r3, [pc, #156]	; (33b0 <xTaskNotifyWait+0xcc>)
    3314:	681b      	ldr	r3, [r3, #0]
    3316:	2201      	movs	r2, #1
    3318:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

				if( xTicksToWait > ( TickType_t ) 0 )
    331c:	683b      	ldr	r3, [r7, #0]
    331e:	2b00      	cmp	r3, #0
    3320:	d01b      	beq.n	335a <xTaskNotifyWait+0x76>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3322:	4b23      	ldr	r3, [pc, #140]	; (33b0 <xTaskNotifyWait+0xcc>)
    3324:	681b      	ldr	r3, [r3, #0]
    3326:	3304      	adds	r3, #4
    3328:	4618      	mov	r0, r3
    332a:	f001 faa3 	bl	4874 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    332e:	683b      	ldr	r3, [r7, #0]
    3330:	f1b3 3fff 	cmp.w	r3, #4294967295
    3334:	d107      	bne.n	3346 <xTaskNotifyWait+0x62>
							woken by a timing event.  It will block
							indefinitely. */
#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
							traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
#endif
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3336:	4b1e      	ldr	r3, [pc, #120]	; (33b0 <xTaskNotifyWait+0xcc>)
    3338:	681b      	ldr	r3, [r3, #0]
    333a:	3304      	adds	r3, #4
    333c:	481d      	ldr	r0, [pc, #116]	; (33b4 <xTaskNotifyWait+0xd0>)
    333e:	4619      	mov	r1, r3
    3340:	f001 fa3c 	bl	47bc <vListInsertEnd>
    3344:	e007      	b.n	3356 <xTaskNotifyWait+0x72>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    3346:	4b1c      	ldr	r3, [pc, #112]	; (33b8 <xTaskNotifyWait+0xd4>)
    3348:	681a      	ldr	r2, [r3, #0]
    334a:	683b      	ldr	r3, [r7, #0]
    334c:	4413      	add	r3, r2
    334e:	613b      	str	r3, [r7, #16]
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    3350:	6938      	ldr	r0, [r7, #16]
    3352:	f7ff fc5d 	bl	2c10 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3356:	f001 f98b 	bl	4670 <vPortYieldFromISR>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    335a:	f001 f973 	bl	4644 <vPortExitCritical>

		taskENTER_CRITICAL();
    335e:	f001 f95b 	bl	4618 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3362:	687b      	ldr	r3, [r7, #4]
    3364:	2b00      	cmp	r3, #0
    3366:	d004      	beq.n	3372 <xTaskNotifyWait+0x8e>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3368:	4b11      	ldr	r3, [pc, #68]	; (33b0 <xTaskNotifyWait+0xcc>)
    336a:	681b      	ldr	r3, [r3, #0]
    336c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    336e:	687b      	ldr	r3, [r7, #4]
    3370:	601a      	str	r2, [r3, #0]

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    3372:	4b0f      	ldr	r3, [pc, #60]	; (33b0 <xTaskNotifyWait+0xcc>)
    3374:	681b      	ldr	r3, [r3, #0]
    3376:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    337a:	b2db      	uxtb	r3, r3
    337c:	2b01      	cmp	r3, #1
    337e:	d102      	bne.n	3386 <xTaskNotifyWait+0xa2>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3380:	2300      	movs	r3, #0
    3382:	617b      	str	r3, [r7, #20]
    3384:	e008      	b.n	3398 <xTaskNotifyWait+0xb4>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3386:	4b0a      	ldr	r3, [pc, #40]	; (33b0 <xTaskNotifyWait+0xcc>)
    3388:	681b      	ldr	r3, [r3, #0]
    338a:	6d19      	ldr	r1, [r3, #80]	; 0x50
    338c:	68ba      	ldr	r2, [r7, #8]
    338e:	43d2      	mvns	r2, r2
    3390:	400a      	ands	r2, r1
    3392:	651a      	str	r2, [r3, #80]	; 0x50
				xReturn = pdTRUE;
    3394:	2301      	movs	r3, #1
    3396:	617b      	str	r3, [r7, #20]
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    3398:	4b05      	ldr	r3, [pc, #20]	; (33b0 <xTaskNotifyWait+0xcc>)
    339a:	681b      	ldr	r3, [r3, #0]
    339c:	2200      	movs	r2, #0
    339e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
		}
		taskEXIT_CRITICAL();
    33a2:	f001 f94f 	bl	4644 <vPortExitCritical>

		return xReturn;
    33a6:	697b      	ldr	r3, [r7, #20]
	}
    33a8:	4618      	mov	r0, r3
    33aa:	3718      	adds	r7, #24
    33ac:	46bd      	mov	sp, r7
    33ae:	bd80      	pop	{r7, pc}
    33b0:	20000028 	.word	0x20000028
    33b4:	200000e8 	.word	0x200000e8
    33b8:	20000104 	.word	0x20000104

000033bc <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    33bc:	b580      	push	{r7, lr}
    33be:	b088      	sub	sp, #32
    33c0:	af00      	add	r7, sp, #0
    33c2:	60f8      	str	r0, [r7, #12]
    33c4:	60b9      	str	r1, [r7, #8]
    33c6:	603b      	str	r3, [r7, #0]
    33c8:	4613      	mov	r3, r2
    33ca:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    33cc:	2301      	movs	r3, #1
    33ce:	61fb      	str	r3, [r7, #28]

		configASSERT( xTaskToNotify );
    33d0:	68fb      	ldr	r3, [r7, #12]
    33d2:	2b00      	cmp	r3, #0
    33d4:	d104      	bne.n	33e0 <xTaskGenericNotify+0x24>
    33d6:	f04f 0050 	mov.w	r0, #80	; 0x50
    33da:	f380 8811 	msr	BASEPRI, r0
    33de:	e7fe      	b.n	33de <xTaskGenericNotify+0x22>
		pxTCB = ( TCB_t * ) xTaskToNotify;
    33e0:	68fb      	ldr	r3, [r7, #12]
    33e2:	61bb      	str	r3, [r7, #24]

		taskENTER_CRITICAL();
    33e4:	f001 f918 	bl	4618 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
    33e8:	683b      	ldr	r3, [r7, #0]
    33ea:	2b00      	cmp	r3, #0
    33ec:	d003      	beq.n	33f6 <xTaskGenericNotify+0x3a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    33ee:	69bb      	ldr	r3, [r7, #24]
    33f0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    33f2:	683b      	ldr	r3, [r7, #0]
    33f4:	601a      	str	r2, [r3, #0]
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    33f6:	69bb      	ldr	r3, [r7, #24]
    33f8:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    33fc:	75fb      	strb	r3, [r7, #23]

			pxTCB->eNotifyState = eNotified;
    33fe:	69bb      	ldr	r3, [r7, #24]
    3400:	2202      	movs	r2, #2
    3402:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

			switch( eAction )
    3406:	79fb      	ldrb	r3, [r7, #7]
    3408:	2b04      	cmp	r3, #4
    340a:	d828      	bhi.n	345e <xTaskGenericNotify+0xa2>
    340c:	a201      	add	r2, pc, #4	; (adr r2, 3414 <xTaskGenericNotify+0x58>)
    340e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    3412:	bf00      	nop
    3414:	0000345f 	.word	0x0000345f
    3418:	00003429 	.word	0x00003429
    341c:	00003437 	.word	0x00003437
    3420:	00003443 	.word	0x00003443
    3424:	0000344b 	.word	0x0000344b
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3428:	69bb      	ldr	r3, [r7, #24]
    342a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    342c:	68bb      	ldr	r3, [r7, #8]
    342e:	431a      	orrs	r2, r3
    3430:	69bb      	ldr	r3, [r7, #24]
    3432:	651a      	str	r2, [r3, #80]	; 0x50
					break;
    3434:	e013      	b.n	345e <xTaskGenericNotify+0xa2>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3436:	69bb      	ldr	r3, [r7, #24]
    3438:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    343a:	1c5a      	adds	r2, r3, #1
    343c:	69bb      	ldr	r3, [r7, #24]
    343e:	651a      	str	r2, [r3, #80]	; 0x50
					break;
    3440:	e00d      	b.n	345e <xTaskGenericNotify+0xa2>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3442:	69bb      	ldr	r3, [r7, #24]
    3444:	68ba      	ldr	r2, [r7, #8]
    3446:	651a      	str	r2, [r3, #80]	; 0x50
					break;
    3448:	e009      	b.n	345e <xTaskGenericNotify+0xa2>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    344a:	7dfb      	ldrb	r3, [r7, #23]
    344c:	2b02      	cmp	r3, #2
    344e:	d003      	beq.n	3458 <xTaskGenericNotify+0x9c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3450:	69bb      	ldr	r3, [r7, #24]
    3452:	68ba      	ldr	r2, [r7, #8]
    3454:	651a      	str	r2, [r3, #80]	; 0x50
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    3456:	e001      	b.n	345c <xTaskGenericNotify+0xa0>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3458:	2300      	movs	r3, #0
    345a:	61fb      	str	r3, [r7, #28]
					}
					break;
    345c:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    345e:	7dfb      	ldrb	r3, [r7, #23]
    3460:	2b01      	cmp	r3, #1
    3462:	d12e      	bne.n	34c2 <xTaskGenericNotify+0x106>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3464:	69bb      	ldr	r3, [r7, #24]
    3466:	3304      	adds	r3, #4
    3468:	4618      	mov	r0, r3
    346a:	f001 fa03 	bl	4874 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    346e:	69bb      	ldr	r3, [r7, #24]
    3470:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3472:	4b17      	ldr	r3, [pc, #92]	; (34d0 <xTaskGenericNotify+0x114>)
    3474:	681b      	ldr	r3, [r3, #0]
    3476:	429a      	cmp	r2, r3
    3478:	d903      	bls.n	3482 <xTaskGenericNotify+0xc6>
    347a:	69bb      	ldr	r3, [r7, #24]
    347c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    347e:	4b14      	ldr	r3, [pc, #80]	; (34d0 <xTaskGenericNotify+0x114>)
    3480:	601a      	str	r2, [r3, #0]
    3482:	69bb      	ldr	r3, [r7, #24]
    3484:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    3486:	4613      	mov	r3, r2
    3488:	009b      	lsls	r3, r3, #2
    348a:	4413      	add	r3, r2
    348c:	009b      	lsls	r3, r3, #2
    348e:	4a11      	ldr	r2, [pc, #68]	; (34d4 <xTaskGenericNotify+0x118>)
    3490:	441a      	add	r2, r3
    3492:	69bb      	ldr	r3, [r7, #24]
    3494:	3304      	adds	r3, #4
    3496:	4610      	mov	r0, r2
    3498:	4619      	mov	r1, r3
    349a:	f001 f98f 	bl	47bc <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    349e:	69bb      	ldr	r3, [r7, #24]
    34a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    34a2:	2b00      	cmp	r3, #0
    34a4:	d004      	beq.n	34b0 <xTaskGenericNotify+0xf4>
    34a6:	f04f 0050 	mov.w	r0, #80	; 0x50
    34aa:	f380 8811 	msr	BASEPRI, r0
    34ae:	e7fe      	b.n	34ae <xTaskGenericNotify+0xf2>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    34b0:	69bb      	ldr	r3, [r7, #24]
    34b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    34b4:	4b08      	ldr	r3, [pc, #32]	; (34d8 <xTaskGenericNotify+0x11c>)
    34b6:	681b      	ldr	r3, [r3, #0]
    34b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    34ba:	429a      	cmp	r2, r3
    34bc:	d901      	bls.n	34c2 <xTaskGenericNotify+0x106>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    34be:	f001 f8d7 	bl	4670 <vPortYieldFromISR>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    34c2:	f001 f8bf 	bl	4644 <vPortExitCritical>

		return xReturn;
    34c6:	69fb      	ldr	r3, [r7, #28]
	}
    34c8:	4618      	mov	r0, r3
    34ca:	3720      	adds	r7, #32
    34cc:	46bd      	mov	sp, r7
    34ce:	bd80      	pop	{r7, pc}
    34d0:	20000108 	.word	0x20000108
    34d4:	2000002c 	.word	0x2000002c
    34d8:	20000028 	.word	0x20000028

000034dc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    34dc:	b580      	push	{r7, lr}
    34de:	b088      	sub	sp, #32
    34e0:	af00      	add	r7, sp, #0
    34e2:	60f8      	str	r0, [r7, #12]
    34e4:	60b9      	str	r1, [r7, #8]
    34e6:	603b      	str	r3, [r7, #0]
    34e8:	4613      	mov	r3, r2
    34ea:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    34ec:	2301      	movs	r3, #1
    34ee:	61fb      	str	r3, [r7, #28]
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
    34f0:	68fb      	ldr	r3, [r7, #12]
    34f2:	2b00      	cmp	r3, #0
    34f4:	d104      	bne.n	3500 <xTaskGenericNotifyFromISR+0x24>
    34f6:	f04f 0050 	mov.w	r0, #80	; 0x50
    34fa:	f380 8811 	msr	BASEPRI, r0
    34fe:	e7fe      	b.n	34fe <xTaskGenericNotifyFromISR+0x22>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    3500:	68fb      	ldr	r3, [r7, #12]
    3502:	61bb      	str	r3, [r7, #24]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3504:	2300      	movs	r3, #0
    3506:	617b      	str	r3, [r7, #20]
    3508:	f04f 0050 	mov.w	r0, #80	; 0x50
    350c:	f380 8811 	msr	BASEPRI, r0
		{
			if( pulPreviousNotificationValue != NULL )
    3510:	683b      	ldr	r3, [r7, #0]
    3512:	2b00      	cmp	r3, #0
    3514:	d003      	beq.n	351e <xTaskGenericNotifyFromISR+0x42>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3516:	69bb      	ldr	r3, [r7, #24]
    3518:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    351a:	683b      	ldr	r3, [r7, #0]
    351c:	601a      	str	r2, [r3, #0]
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    351e:	69bb      	ldr	r3, [r7, #24]
    3520:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    3524:	74fb      	strb	r3, [r7, #19]
			pxTCB->eNotifyState = eNotified;
    3526:	69bb      	ldr	r3, [r7, #24]
    3528:	2202      	movs	r2, #2
    352a:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

			switch( eAction )
    352e:	79fb      	ldrb	r3, [r7, #7]
    3530:	2b04      	cmp	r3, #4
    3532:	d828      	bhi.n	3586 <xTaskGenericNotifyFromISR+0xaa>
    3534:	a201      	add	r2, pc, #4	; (adr r2, 353c <xTaskGenericNotifyFromISR+0x60>)
    3536:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    353a:	bf00      	nop
    353c:	00003587 	.word	0x00003587
    3540:	00003551 	.word	0x00003551
    3544:	0000355f 	.word	0x0000355f
    3548:	0000356b 	.word	0x0000356b
    354c:	00003573 	.word	0x00003573
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3550:	69bb      	ldr	r3, [r7, #24]
    3552:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    3554:	68bb      	ldr	r3, [r7, #8]
    3556:	431a      	orrs	r2, r3
    3558:	69bb      	ldr	r3, [r7, #24]
    355a:	651a      	str	r2, [r3, #80]	; 0x50
					break;
    355c:	e013      	b.n	3586 <xTaskGenericNotifyFromISR+0xaa>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    355e:	69bb      	ldr	r3, [r7, #24]
    3560:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    3562:	1c5a      	adds	r2, r3, #1
    3564:	69bb      	ldr	r3, [r7, #24]
    3566:	651a      	str	r2, [r3, #80]	; 0x50
					break;
    3568:	e00d      	b.n	3586 <xTaskGenericNotifyFromISR+0xaa>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    356a:	69bb      	ldr	r3, [r7, #24]
    356c:	68ba      	ldr	r2, [r7, #8]
    356e:	651a      	str	r2, [r3, #80]	; 0x50
					break;
    3570:	e009      	b.n	3586 <xTaskGenericNotifyFromISR+0xaa>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    3572:	7cfb      	ldrb	r3, [r7, #19]
    3574:	2b02      	cmp	r3, #2
    3576:	d003      	beq.n	3580 <xTaskGenericNotifyFromISR+0xa4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3578:	69bb      	ldr	r3, [r7, #24]
    357a:	68ba      	ldr	r2, [r7, #8]
    357c:	651a      	str	r2, [r3, #80]	; 0x50
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
    357e:	e001      	b.n	3584 <xTaskGenericNotifyFromISR+0xa8>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3580:	2300      	movs	r3, #0
    3582:	61fb      	str	r3, [r7, #28]
					}
					break;
    3584:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    3586:	7cfb      	ldrb	r3, [r7, #19]
    3588:	2b01      	cmp	r3, #1
    358a:	d13d      	bne.n	3608 <xTaskGenericNotifyFromISR+0x12c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    358c:	69bb      	ldr	r3, [r7, #24]
    358e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    3590:	2b00      	cmp	r3, #0
    3592:	d004      	beq.n	359e <xTaskGenericNotifyFromISR+0xc2>
    3594:	f04f 0050 	mov.w	r0, #80	; 0x50
    3598:	f380 8811 	msr	BASEPRI, r0
    359c:	e7fe      	b.n	359c <xTaskGenericNotifyFromISR+0xc0>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    359e:	4b1f      	ldr	r3, [pc, #124]	; (361c <xTaskGenericNotifyFromISR+0x140>)
    35a0:	681b      	ldr	r3, [r3, #0]
    35a2:	2b00      	cmp	r3, #0
    35a4:	d11d      	bne.n	35e2 <xTaskGenericNotifyFromISR+0x106>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    35a6:	69bb      	ldr	r3, [r7, #24]
    35a8:	3304      	adds	r3, #4
    35aa:	4618      	mov	r0, r3
    35ac:	f001 f962 	bl	4874 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    35b0:	69bb      	ldr	r3, [r7, #24]
    35b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    35b4:	4b1a      	ldr	r3, [pc, #104]	; (3620 <xTaskGenericNotifyFromISR+0x144>)
    35b6:	681b      	ldr	r3, [r3, #0]
    35b8:	429a      	cmp	r2, r3
    35ba:	d903      	bls.n	35c4 <xTaskGenericNotifyFromISR+0xe8>
    35bc:	69bb      	ldr	r3, [r7, #24]
    35be:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    35c0:	4b17      	ldr	r3, [pc, #92]	; (3620 <xTaskGenericNotifyFromISR+0x144>)
    35c2:	601a      	str	r2, [r3, #0]
    35c4:	69bb      	ldr	r3, [r7, #24]
    35c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    35c8:	4613      	mov	r3, r2
    35ca:	009b      	lsls	r3, r3, #2
    35cc:	4413      	add	r3, r2
    35ce:	009b      	lsls	r3, r3, #2
    35d0:	4a14      	ldr	r2, [pc, #80]	; (3624 <xTaskGenericNotifyFromISR+0x148>)
    35d2:	441a      	add	r2, r3
    35d4:	69bb      	ldr	r3, [r7, #24]
    35d6:	3304      	adds	r3, #4
    35d8:	4610      	mov	r0, r2
    35da:	4619      	mov	r1, r3
    35dc:	f001 f8ee 	bl	47bc <vListInsertEnd>
    35e0:	e005      	b.n	35ee <xTaskGenericNotifyFromISR+0x112>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    35e2:	69bb      	ldr	r3, [r7, #24]
    35e4:	3318      	adds	r3, #24
    35e6:	4810      	ldr	r0, [pc, #64]	; (3628 <xTaskGenericNotifyFromISR+0x14c>)
    35e8:	4619      	mov	r1, r3
    35ea:	f001 f8e7 	bl	47bc <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    35ee:	69bb      	ldr	r3, [r7, #24]
    35f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    35f2:	4b0e      	ldr	r3, [pc, #56]	; (362c <xTaskGenericNotifyFromISR+0x150>)
    35f4:	681b      	ldr	r3, [r3, #0]
    35f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    35f8:	429a      	cmp	r2, r3
    35fa:	d905      	bls.n	3608 <xTaskGenericNotifyFromISR+0x12c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    35fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    35fe:	2b00      	cmp	r3, #0
    3600:	d002      	beq.n	3608 <xTaskGenericNotifyFromISR+0x12c>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3602:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3604:	2201      	movs	r2, #1
    3606:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    3608:	f04f 0000 	mov.w	r0, #0
    360c:	f380 8811 	msr	BASEPRI, r0

		return xReturn;
    3610:	69fb      	ldr	r3, [r7, #28]
	}
    3612:	4618      	mov	r0, r3
    3614:	3720      	adds	r7, #32
    3616:	46bd      	mov	sp, r7
    3618:	bd80      	pop	{r7, pc}
    361a:	bf00      	nop
    361c:	20000124 	.word	0x20000124
    3620:	20000108 	.word	0x20000108
    3624:	2000002c 	.word	0x2000002c
    3628:	200000d4 	.word	0x200000d4
    362c:	20000028 	.word	0x20000028

00003630 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3630:	b580      	push	{r7, lr}
    3632:	b086      	sub	sp, #24
    3634:	af00      	add	r7, sp, #0
    3636:	6078      	str	r0, [r7, #4]
    3638:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
    363a:	687b      	ldr	r3, [r7, #4]
    363c:	2b00      	cmp	r3, #0
    363e:	d104      	bne.n	364a <vTaskNotifyGiveFromISR+0x1a>
    3640:	f04f 0050 	mov.w	r0, #80	; 0x50
    3644:	f380 8811 	msr	BASEPRI, r0
    3648:	e7fe      	b.n	3648 <vTaskNotifyGiveFromISR+0x18>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    364a:	687b      	ldr	r3, [r7, #4]
    364c:	617b      	str	r3, [r7, #20]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    364e:	2300      	movs	r3, #0
    3650:	613b      	str	r3, [r7, #16]
    3652:	f04f 0050 	mov.w	r0, #80	; 0x50
    3656:	f380 8811 	msr	BASEPRI, r0
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    365a:	697b      	ldr	r3, [r7, #20]
    365c:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    3660:	73fb      	strb	r3, [r7, #15]
			pxTCB->eNotifyState = eNotified;
    3662:	697b      	ldr	r3, [r7, #20]
    3664:	2202      	movs	r2, #2
    3666:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    366a:	697b      	ldr	r3, [r7, #20]
    366c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    366e:	1c5a      	adds	r2, r3, #1
    3670:	697b      	ldr	r3, [r7, #20]
    3672:	651a      	str	r2, [r3, #80]	; 0x50

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    3674:	7bfb      	ldrb	r3, [r7, #15]
    3676:	2b01      	cmp	r3, #1
    3678:	d13d      	bne.n	36f6 <vTaskNotifyGiveFromISR+0xc6>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    367a:	697b      	ldr	r3, [r7, #20]
    367c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    367e:	2b00      	cmp	r3, #0
    3680:	d004      	beq.n	368c <vTaskNotifyGiveFromISR+0x5c>
    3682:	f04f 0050 	mov.w	r0, #80	; 0x50
    3686:	f380 8811 	msr	BASEPRI, r0
    368a:	e7fe      	b.n	368a <vTaskNotifyGiveFromISR+0x5a>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    368c:	4b1d      	ldr	r3, [pc, #116]	; (3704 <vTaskNotifyGiveFromISR+0xd4>)
    368e:	681b      	ldr	r3, [r3, #0]
    3690:	2b00      	cmp	r3, #0
    3692:	d11d      	bne.n	36d0 <vTaskNotifyGiveFromISR+0xa0>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3694:	697b      	ldr	r3, [r7, #20]
    3696:	3304      	adds	r3, #4
    3698:	4618      	mov	r0, r3
    369a:	f001 f8eb 	bl	4874 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    369e:	697b      	ldr	r3, [r7, #20]
    36a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    36a2:	4b19      	ldr	r3, [pc, #100]	; (3708 <vTaskNotifyGiveFromISR+0xd8>)
    36a4:	681b      	ldr	r3, [r3, #0]
    36a6:	429a      	cmp	r2, r3
    36a8:	d903      	bls.n	36b2 <vTaskNotifyGiveFromISR+0x82>
    36aa:	697b      	ldr	r3, [r7, #20]
    36ac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    36ae:	4b16      	ldr	r3, [pc, #88]	; (3708 <vTaskNotifyGiveFromISR+0xd8>)
    36b0:	601a      	str	r2, [r3, #0]
    36b2:	697b      	ldr	r3, [r7, #20]
    36b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    36b6:	4613      	mov	r3, r2
    36b8:	009b      	lsls	r3, r3, #2
    36ba:	4413      	add	r3, r2
    36bc:	009b      	lsls	r3, r3, #2
    36be:	4a13      	ldr	r2, [pc, #76]	; (370c <vTaskNotifyGiveFromISR+0xdc>)
    36c0:	441a      	add	r2, r3
    36c2:	697b      	ldr	r3, [r7, #20]
    36c4:	3304      	adds	r3, #4
    36c6:	4610      	mov	r0, r2
    36c8:	4619      	mov	r1, r3
    36ca:	f001 f877 	bl	47bc <vListInsertEnd>
    36ce:	e005      	b.n	36dc <vTaskNotifyGiveFromISR+0xac>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    36d0:	697b      	ldr	r3, [r7, #20]
    36d2:	3318      	adds	r3, #24
    36d4:	480e      	ldr	r0, [pc, #56]	; (3710 <vTaskNotifyGiveFromISR+0xe0>)
    36d6:	4619      	mov	r1, r3
    36d8:	f001 f870 	bl	47bc <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    36dc:	697b      	ldr	r3, [r7, #20]
    36de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    36e0:	4b0c      	ldr	r3, [pc, #48]	; (3714 <vTaskNotifyGiveFromISR+0xe4>)
    36e2:	681b      	ldr	r3, [r3, #0]
    36e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    36e6:	429a      	cmp	r2, r3
    36e8:	d905      	bls.n	36f6 <vTaskNotifyGiveFromISR+0xc6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    36ea:	683b      	ldr	r3, [r7, #0]
    36ec:	2b00      	cmp	r3, #0
    36ee:	d002      	beq.n	36f6 <vTaskNotifyGiveFromISR+0xc6>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    36f0:	683b      	ldr	r3, [r7, #0]
    36f2:	2201      	movs	r2, #1
    36f4:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    36f6:	f04f 0000 	mov.w	r0, #0
    36fa:	f380 8811 	msr	BASEPRI, r0
	}
    36fe:	3718      	adds	r7, #24
    3700:	46bd      	mov	sp, r7
    3702:	bd80      	pop	{r7, pc}
    3704:	20000124 	.word	0x20000124
    3708:	20000108 	.word	0x20000108
    370c:	2000002c 	.word	0x2000002c
    3710:	200000d4 	.word	0x200000d4
    3714:	20000028 	.word	0x20000028

00003718 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3718:	b580      	push	{r7, lr}
    371a:	b084      	sub	sp, #16
    371c:	af00      	add	r7, sp, #0
    371e:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    3720:	687b      	ldr	r3, [r7, #4]
    3722:	60bb      	str	r3, [r7, #8]

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    3724:	68bb      	ldr	r3, [r7, #8]
    3726:	2b00      	cmp	r3, #0
    3728:	d102      	bne.n	3730 <xTaskNotifyStateClear+0x18>
    372a:	4b0e      	ldr	r3, [pc, #56]	; (3764 <xTaskNotifyStateClear+0x4c>)
    372c:	681b      	ldr	r3, [r3, #0]
    372e:	e000      	b.n	3732 <xTaskNotifyStateClear+0x1a>
    3730:	68bb      	ldr	r3, [r7, #8]
    3732:	60bb      	str	r3, [r7, #8]

		taskENTER_CRITICAL();
    3734:	f000 ff70 	bl	4618 <vPortEnterCritical>
		{
			if( pxTCB->eNotifyState == eNotified )
    3738:	68bb      	ldr	r3, [r7, #8]
    373a:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
    373e:	b2db      	uxtb	r3, r3
    3740:	2b02      	cmp	r3, #2
    3742:	d106      	bne.n	3752 <xTaskNotifyStateClear+0x3a>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    3744:	68bb      	ldr	r3, [r7, #8]
    3746:	2200      	movs	r2, #0
    3748:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
				xReturn = pdPASS;
    374c:	2301      	movs	r3, #1
    374e:	60fb      	str	r3, [r7, #12]
    3750:	e001      	b.n	3756 <xTaskNotifyStateClear+0x3e>
			}
			else
			{
				xReturn = pdFAIL;
    3752:	2300      	movs	r3, #0
    3754:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
    3756:	f000 ff75 	bl	4644 <vPortExitCritical>

		return xReturn;
    375a:	68fb      	ldr	r3, [r7, #12]
	}
    375c:	4618      	mov	r0, r3
    375e:	3710      	adds	r7, #16
    3760:	46bd      	mov	sp, r7
    3762:	bd80      	pop	{r7, pc}
    3764:	20000028 	.word	0x20000028

00003768 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3768:	b580      	push	{r7, lr}
    376a:	b084      	sub	sp, #16
    376c:	af00      	add	r7, sp, #0
    376e:	6078      	str	r0, [r7, #4]
    3770:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3772:	687b      	ldr	r3, [r7, #4]
    3774:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
    3776:	68fb      	ldr	r3, [r7, #12]
    3778:	2b00      	cmp	r3, #0
    377a:	d104      	bne.n	3786 <xQueueGenericReset+0x1e>
    377c:	f04f 0050 	mov.w	r0, #80	; 0x50
    3780:	f380 8811 	msr	BASEPRI, r0
    3784:	e7fe      	b.n	3784 <xQueueGenericReset+0x1c>

	taskENTER_CRITICAL();
    3786:	f000 ff47 	bl	4618 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    378a:	68fb      	ldr	r3, [r7, #12]
    378c:	681a      	ldr	r2, [r3, #0]
    378e:	68fb      	ldr	r3, [r7, #12]
    3790:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3792:	68f9      	ldr	r1, [r7, #12]
    3794:	6c09      	ldr	r1, [r1, #64]	; 0x40
    3796:	fb01 f303 	mul.w	r3, r1, r3
    379a:	441a      	add	r2, r3
    379c:	68fb      	ldr	r3, [r7, #12]
    379e:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    37a0:	68fb      	ldr	r3, [r7, #12]
    37a2:	2200      	movs	r2, #0
    37a4:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
    37a6:	68fb      	ldr	r3, [r7, #12]
    37a8:	681a      	ldr	r2, [r3, #0]
    37aa:	68fb      	ldr	r3, [r7, #12]
    37ac:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    37ae:	68fb      	ldr	r3, [r7, #12]
    37b0:	681a      	ldr	r2, [r3, #0]
    37b2:	68fb      	ldr	r3, [r7, #12]
    37b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    37b6:	3b01      	subs	r3, #1
    37b8:	68f9      	ldr	r1, [r7, #12]
    37ba:	6c09      	ldr	r1, [r1, #64]	; 0x40
    37bc:	fb01 f303 	mul.w	r3, r1, r3
    37c0:	441a      	add	r2, r3
    37c2:	68fb      	ldr	r3, [r7, #12]
    37c4:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
    37c6:	68fb      	ldr	r3, [r7, #12]
    37c8:	f04f 32ff 	mov.w	r2, #4294967295
    37cc:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
    37ce:	68fb      	ldr	r3, [r7, #12]
    37d0:	f04f 32ff 	mov.w	r2, #4294967295
    37d4:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
    37d6:	683b      	ldr	r3, [r7, #0]
    37d8:	2b00      	cmp	r3, #0
    37da:	d10e      	bne.n	37fa <xQueueGenericReset+0x92>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    37dc:	68fb      	ldr	r3, [r7, #12]
    37de:	691b      	ldr	r3, [r3, #16]
    37e0:	2b00      	cmp	r3, #0
    37e2:	d014      	beq.n	380e <xQueueGenericReset+0xa6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    37e4:	68fb      	ldr	r3, [r7, #12]
    37e6:	3310      	adds	r3, #16
    37e8:	4618      	mov	r0, r3
    37ea:	f7ff f80d 	bl	2808 <xTaskRemoveFromEventList>
    37ee:	4603      	mov	r3, r0
    37f0:	2b01      	cmp	r3, #1
    37f2:	d10c      	bne.n	380e <xQueueGenericReset+0xa6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    37f4:	f000 ff3c 	bl	4670 <vPortYieldFromISR>
    37f8:	e009      	b.n	380e <xQueueGenericReset+0xa6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    37fa:	68fb      	ldr	r3, [r7, #12]
    37fc:	3310      	adds	r3, #16
    37fe:	4618      	mov	r0, r3
    3800:	f000 ffb0 	bl	4764 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3804:	68fb      	ldr	r3, [r7, #12]
    3806:	3324      	adds	r3, #36	; 0x24
    3808:	4618      	mov	r0, r3
    380a:	f000 ffab 	bl	4764 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    380e:	f000 ff19 	bl	4644 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3812:	2301      	movs	r3, #1
}
    3814:	4618      	mov	r0, r3
    3816:	3710      	adds	r7, #16
    3818:	46bd      	mov	sp, r7
    381a:	bd80      	pop	{r7, pc}

0000381c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    381c:	b580      	push	{r7, lr}
    381e:	b088      	sub	sp, #32
    3820:	af00      	add	r7, sp, #0
    3822:	60f8      	str	r0, [r7, #12]
    3824:	60b9      	str	r1, [r7, #8]
    3826:	4613      	mov	r3, r2
    3828:	71fb      	strb	r3, [r7, #7]
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    382a:	2300      	movs	r3, #0
    382c:	61bb      	str	r3, [r7, #24]

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
    382e:	68fb      	ldr	r3, [r7, #12]
    3830:	2b00      	cmp	r3, #0
    3832:	d104      	bne.n	383e <xQueueGenericCreate+0x22>
    3834:	f04f 0050 	mov.w	r0, #80	; 0x50
    3838:	f380 8811 	msr	BASEPRI, r0
    383c:	e7fe      	b.n	383c <xQueueGenericCreate+0x20>

	if( uxItemSize == ( UBaseType_t ) 0 )
    383e:	68bb      	ldr	r3, [r7, #8]
    3840:	2b00      	cmp	r3, #0
    3842:	d102      	bne.n	384a <xQueueGenericCreate+0x2e>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    3844:	2300      	movs	r3, #0
    3846:	61fb      	str	r3, [r7, #28]
    3848:	e005      	b.n	3856 <xQueueGenericCreate+0x3a>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    384a:	68fb      	ldr	r3, [r7, #12]
    384c:	68ba      	ldr	r2, [r7, #8]
    384e:	fb02 f303 	mul.w	r3, r2, r3
    3852:	3301      	adds	r3, #1
    3854:	61fb      	str	r3, [r7, #28]
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    3856:	69fb      	ldr	r3, [r7, #28]
    3858:	3354      	adds	r3, #84	; 0x54
    385a:	4618      	mov	r0, r3
    385c:	f001 f834 	bl	48c8 <pvPortMalloc>
    3860:	6178      	str	r0, [r7, #20]

	if( pxNewQueue != NULL )
    3862:	697b      	ldr	r3, [r7, #20]
    3864:	2b00      	cmp	r3, #0
    3866:	d01b      	beq.n	38a0 <xQueueGenericCreate+0x84>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    3868:	68bb      	ldr	r3, [r7, #8]
    386a:	2b00      	cmp	r3, #0
    386c:	d103      	bne.n	3876 <xQueueGenericCreate+0x5a>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    386e:	697b      	ldr	r3, [r7, #20]
    3870:	697a      	ldr	r2, [r7, #20]
    3872:	601a      	str	r2, [r3, #0]
    3874:	e004      	b.n	3880 <xQueueGenericCreate+0x64>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    3876:	697b      	ldr	r3, [r7, #20]
    3878:	f103 0254 	add.w	r2, r3, #84	; 0x54
    387c:	697b      	ldr	r3, [r7, #20]
    387e:	601a      	str	r2, [r3, #0]
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    3880:	697b      	ldr	r3, [r7, #20]
    3882:	68fa      	ldr	r2, [r7, #12]
    3884:	63da      	str	r2, [r3, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
    3886:	697b      	ldr	r3, [r7, #20]
    3888:	68ba      	ldr	r2, [r7, #8]
    388a:	641a      	str	r2, [r3, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    388c:	6978      	ldr	r0, [r7, #20]
    388e:	2101      	movs	r1, #1
    3890:	f7ff ff6a 	bl	3768 <xQueueGenericReset>

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			pxNewQueue->ucQueueType = ucQueueType;
    3894:	697b      	ldr	r3, [r7, #20]
    3896:	79fa      	ldrb	r2, [r7, #7]
    3898:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    389c:	697b      	ldr	r3, [r7, #20]
    389e:	61bb      	str	r3, [r7, #24]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
    38a0:	69bb      	ldr	r3, [r7, #24]
    38a2:	2b00      	cmp	r3, #0
    38a4:	d104      	bne.n	38b0 <xQueueGenericCreate+0x94>
    38a6:	f04f 0050 	mov.w	r0, #80	; 0x50
    38aa:	f380 8811 	msr	BASEPRI, r0
    38ae:	e7fe      	b.n	38ae <xQueueGenericCreate+0x92>

	return xReturn;
    38b0:	69bb      	ldr	r3, [r7, #24]
}
    38b2:	4618      	mov	r0, r3
    38b4:	3720      	adds	r7, #32
    38b6:	46bd      	mov	sp, r7
    38b8:	bd80      	pop	{r7, pc}
    38ba:	bf00      	nop

000038bc <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    38bc:	b580      	push	{r7, lr}
    38be:	b084      	sub	sp, #16
    38c0:	af00      	add	r7, sp, #0
    38c2:	4603      	mov	r3, r0
    38c4:	71fb      	strb	r3, [r7, #7]
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    38c6:	2054      	movs	r0, #84	; 0x54
    38c8:	f000 fffe 	bl	48c8 <pvPortMalloc>
    38cc:	60f8      	str	r0, [r7, #12]
		if( pxNewQueue != NULL )
    38ce:	68fb      	ldr	r3, [r7, #12]
    38d0:	2b00      	cmp	r3, #0
    38d2:	d030      	beq.n	3936 <xQueueCreateMutex+0x7a>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    38d4:	68fb      	ldr	r3, [r7, #12]
    38d6:	2200      	movs	r2, #0
    38d8:	605a      	str	r2, [r3, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    38da:	68fb      	ldr	r3, [r7, #12]
    38dc:	2200      	movs	r2, #0
    38de:	601a      	str	r2, [r3, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    38e0:	68fb      	ldr	r3, [r7, #12]
    38e2:	2200      	movs	r2, #0
    38e4:	609a      	str	r2, [r3, #8]
			pxNewQueue->u.pcReadFrom = NULL;
    38e6:	68fb      	ldr	r3, [r7, #12]
    38e8:	2200      	movs	r2, #0
    38ea:	60da      	str	r2, [r3, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    38ec:	68fb      	ldr	r3, [r7, #12]
    38ee:	2200      	movs	r2, #0
    38f0:	639a      	str	r2, [r3, #56]	; 0x38
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    38f2:	68fb      	ldr	r3, [r7, #12]
    38f4:	2201      	movs	r2, #1
    38f6:	63da      	str	r2, [r3, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    38f8:	68fb      	ldr	r3, [r7, #12]
    38fa:	2200      	movs	r2, #0
    38fc:	641a      	str	r2, [r3, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
    38fe:	68fb      	ldr	r3, [r7, #12]
    3900:	f04f 32ff 	mov.w	r2, #4294967295
    3904:	645a      	str	r2, [r3, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
    3906:	68fb      	ldr	r3, [r7, #12]
    3908:	f04f 32ff 	mov.w	r2, #4294967295
    390c:	649a      	str	r2, [r3, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
    390e:	68fb      	ldr	r3, [r7, #12]
    3910:	79fa      	ldrb	r2, [r7, #7]
    3912:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3916:	68fb      	ldr	r3, [r7, #12]
    3918:	3310      	adds	r3, #16
    391a:	4618      	mov	r0, r3
    391c:	f000 ff22 	bl	4764 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3920:	68fb      	ldr	r3, [r7, #12]
    3922:	3324      	adds	r3, #36	; 0x24
    3924:	4618      	mov	r0, r3
    3926:	f000 ff1d 	bl	4764 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    392a:	68f8      	ldr	r0, [r7, #12]
    392c:	2100      	movs	r1, #0
    392e:	2200      	movs	r2, #0
    3930:	2300      	movs	r3, #0
    3932:	f000 f8ad 	bl	3a90 <xQueueGenericSend>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		return pxNewQueue;
    3936:	68fb      	ldr	r3, [r7, #12]
	}
    3938:	4618      	mov	r0, r3
    393a:	3710      	adds	r7, #16
    393c:	46bd      	mov	sp, r7
    393e:	bd80      	pop	{r7, pc}

00003940 <xQueueGetMutexHolder>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )

	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
	{
    3940:	b580      	push	{r7, lr}
    3942:	b084      	sub	sp, #16
    3944:	af00      	add	r7, sp, #0
    3946:	6078      	str	r0, [r7, #4]
		/* This function is called by xSemaphoreGetMutexHolder(), and should not
		be called directly.  Note:  This is a good way of determining if the
		calling task is the mutex holder, but not a good way of determining the
		identity of the mutex holder, as the holder may change between the
		following critical section exiting and the function returning. */
		taskENTER_CRITICAL();
    3948:	f000 fe66 	bl	4618 <vPortEnterCritical>
		{
			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
    394c:	687b      	ldr	r3, [r7, #4]
    394e:	681b      	ldr	r3, [r3, #0]
    3950:	2b00      	cmp	r3, #0
    3952:	d103      	bne.n	395c <xQueueGetMutexHolder+0x1c>
			{
				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
    3954:	687b      	ldr	r3, [r7, #4]
    3956:	685b      	ldr	r3, [r3, #4]
    3958:	60fb      	str	r3, [r7, #12]
    395a:	e001      	b.n	3960 <xQueueGetMutexHolder+0x20>
			}
			else
			{
				pxReturn = NULL;
    395c:	2300      	movs	r3, #0
    395e:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
    3960:	f000 fe70 	bl	4644 <vPortExitCritical>

		return pxReturn;
    3964:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    3966:	4618      	mov	r0, r3
    3968:	3710      	adds	r7, #16
    396a:	46bd      	mov	sp, r7
    396c:	bd80      	pop	{r7, pc}
    396e:	bf00      	nop

00003970 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
    3970:	b590      	push	{r4, r7, lr}
    3972:	b085      	sub	sp, #20
    3974:	af00      	add	r7, sp, #0
    3976:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    3978:	687b      	ldr	r3, [r7, #4]
    397a:	60bb      	str	r3, [r7, #8]

		configASSERT( pxMutex );
    397c:	68bb      	ldr	r3, [r7, #8]
    397e:	2b00      	cmp	r3, #0
    3980:	d104      	bne.n	398c <xQueueGiveMutexRecursive+0x1c>
    3982:	f04f 0050 	mov.w	r0, #80	; 0x50
    3986:	f380 8811 	msr	BASEPRI, r0
    398a:	e7fe      	b.n	398a <xQueueGiveMutexRecursive+0x1a>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
    398c:	68bb      	ldr	r3, [r7, #8]
    398e:	685c      	ldr	r4, [r3, #4]
    3990:	f7ff fa94 	bl	2ebc <xTaskGetCurrentTaskHandle>
    3994:	4603      	mov	r3, r0
    3996:	429c      	cmp	r4, r3
    3998:	d111      	bne.n	39be <xQueueGiveMutexRecursive+0x4e>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
    399a:	68bb      	ldr	r3, [r7, #8]
    399c:	68db      	ldr	r3, [r3, #12]
    399e:	1e5a      	subs	r2, r3, #1
    39a0:	68bb      	ldr	r3, [r7, #8]
    39a2:	60da      	str	r2, [r3, #12]

			/* Have we unwound the call count? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    39a4:	68bb      	ldr	r3, [r7, #8]
    39a6:	68db      	ldr	r3, [r3, #12]
    39a8:	2b00      	cmp	r3, #0
    39aa:	d105      	bne.n	39b8 <xQueueGiveMutexRecursive+0x48>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    39ac:	68b8      	ldr	r0, [r7, #8]
    39ae:	2100      	movs	r1, #0
    39b0:	2200      	movs	r2, #0
    39b2:	2300      	movs	r3, #0
    39b4:	f000 f86c 	bl	3a90 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    39b8:	2301      	movs	r3, #1
    39ba:	60fb      	str	r3, [r7, #12]
    39bc:	e001      	b.n	39c2 <xQueueGiveMutexRecursive+0x52>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
    39be:	2300      	movs	r3, #0
    39c0:	60fb      	str	r3, [r7, #12]

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    39c2:	68fb      	ldr	r3, [r7, #12]
	}
    39c4:	4618      	mov	r0, r3
    39c6:	3714      	adds	r7, #20
    39c8:	46bd      	mov	sp, r7
    39ca:	bd90      	pop	{r4, r7, pc}

000039cc <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
    39cc:	b590      	push	{r4, r7, lr}
    39ce:	b085      	sub	sp, #20
    39d0:	af00      	add	r7, sp, #0
    39d2:	6078      	str	r0, [r7, #4]
    39d4:	6039      	str	r1, [r7, #0]
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    39d6:	687b      	ldr	r3, [r7, #4]
    39d8:	60bb      	str	r3, [r7, #8]

		configASSERT( pxMutex );
    39da:	68bb      	ldr	r3, [r7, #8]
    39dc:	2b00      	cmp	r3, #0
    39de:	d104      	bne.n	39ea <xQueueTakeMutexRecursive+0x1e>
    39e0:	f04f 0050 	mov.w	r0, #80	; 0x50
    39e4:	f380 8811 	msr	BASEPRI, r0
    39e8:	e7fe      	b.n	39e8 <xQueueTakeMutexRecursive+0x1c>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    39ea:	68bb      	ldr	r3, [r7, #8]
    39ec:	685c      	ldr	r4, [r3, #4]
    39ee:	f7ff fa65 	bl	2ebc <xTaskGetCurrentTaskHandle>
    39f2:	4603      	mov	r3, r0
    39f4:	429c      	cmp	r4, r3
    39f6:	d107      	bne.n	3a08 <xQueueTakeMutexRecursive+0x3c>
		{
			( pxMutex->u.uxRecursiveCallCount )++;
    39f8:	68bb      	ldr	r3, [r7, #8]
    39fa:	68db      	ldr	r3, [r3, #12]
    39fc:	1c5a      	adds	r2, r3, #1
    39fe:	68bb      	ldr	r3, [r7, #8]
    3a00:	60da      	str	r2, [r3, #12]
			xReturn = pdPASS;
    3a02:	2301      	movs	r3, #1
    3a04:	60fb      	str	r3, [r7, #12]
    3a06:	e00e      	b.n	3a26 <xQueueTakeMutexRecursive+0x5a>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
    3a08:	68b8      	ldr	r0, [r7, #8]
    3a0a:	2100      	movs	r1, #0
    3a0c:	683a      	ldr	r2, [r7, #0]
    3a0e:	2300      	movs	r3, #0
    3a10:	f000 f9e4 	bl	3ddc <xQueueGenericReceive>
    3a14:	60f8      	str	r0, [r7, #12]

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn == pdPASS )
    3a16:	68fb      	ldr	r3, [r7, #12]
    3a18:	2b01      	cmp	r3, #1
    3a1a:	d104      	bne.n	3a26 <xQueueTakeMutexRecursive+0x5a>
			{
				( pxMutex->u.uxRecursiveCallCount )++;
    3a1c:	68bb      	ldr	r3, [r7, #8]
    3a1e:	68db      	ldr	r3, [r3, #12]
    3a20:	1c5a      	adds	r2, r3, #1
    3a22:	68bb      	ldr	r3, [r7, #8]
    3a24:	60da      	str	r2, [r3, #12]
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    3a26:	68fb      	ldr	r3, [r7, #12]
	}
    3a28:	4618      	mov	r0, r3
    3a2a:	3714      	adds	r7, #20
    3a2c:	46bd      	mov	sp, r7
    3a2e:	bd90      	pop	{r4, r7, pc}

00003a30 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    3a30:	b580      	push	{r7, lr}
    3a32:	b084      	sub	sp, #16
    3a34:	af00      	add	r7, sp, #0
    3a36:	6078      	str	r0, [r7, #4]
    3a38:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
    3a3a:	687b      	ldr	r3, [r7, #4]
    3a3c:	2b00      	cmp	r3, #0
    3a3e:	d104      	bne.n	3a4a <xQueueCreateCountingSemaphore+0x1a>
    3a40:	f04f 0050 	mov.w	r0, #80	; 0x50
    3a44:	f380 8811 	msr	BASEPRI, r0
    3a48:	e7fe      	b.n	3a48 <xQueueCreateCountingSemaphore+0x18>
		configASSERT( uxInitialCount <= uxMaxCount );
    3a4a:	683a      	ldr	r2, [r7, #0]
    3a4c:	687b      	ldr	r3, [r7, #4]
    3a4e:	429a      	cmp	r2, r3
    3a50:	d904      	bls.n	3a5c <xQueueCreateCountingSemaphore+0x2c>
    3a52:	f04f 0050 	mov.w	r0, #80	; 0x50
    3a56:	f380 8811 	msr	BASEPRI, r0
    3a5a:	e7fe      	b.n	3a5a <xQueueCreateCountingSemaphore+0x2a>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    3a5c:	6878      	ldr	r0, [r7, #4]
    3a5e:	2100      	movs	r1, #0
    3a60:	2202      	movs	r2, #2
    3a62:	f7ff fedb 	bl	381c <xQueueGenericCreate>
    3a66:	60f8      	str	r0, [r7, #12]

		if( xHandle != NULL )
    3a68:	68fb      	ldr	r3, [r7, #12]
    3a6a:	2b00      	cmp	r3, #0
    3a6c:	d002      	beq.n	3a74 <xQueueCreateCountingSemaphore+0x44>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    3a6e:	68fb      	ldr	r3, [r7, #12]
    3a70:	683a      	ldr	r2, [r7, #0]
    3a72:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
    3a74:	68fb      	ldr	r3, [r7, #12]
    3a76:	2b00      	cmp	r3, #0
    3a78:	d104      	bne.n	3a84 <xQueueCreateCountingSemaphore+0x54>
    3a7a:	f04f 0050 	mov.w	r0, #80	; 0x50
    3a7e:	f380 8811 	msr	BASEPRI, r0
    3a82:	e7fe      	b.n	3a82 <xQueueCreateCountingSemaphore+0x52>
		return xHandle;
    3a84:	68fb      	ldr	r3, [r7, #12]
	}
    3a86:	4618      	mov	r0, r3
    3a88:	3710      	adds	r7, #16
    3a8a:	46bd      	mov	sp, r7
    3a8c:	bd80      	pop	{r7, pc}
    3a8e:	bf00      	nop

00003a90 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3a90:	b580      	push	{r7, lr}
    3a92:	b08a      	sub	sp, #40	; 0x28
    3a94:	af00      	add	r7, sp, #0
    3a96:	60f8      	str	r0, [r7, #12]
    3a98:	60b9      	str	r1, [r7, #8]
    3a9a:	607a      	str	r2, [r7, #4]
    3a9c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3a9e:	2300      	movs	r3, #0
    3aa0:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3aa2:	68fb      	ldr	r3, [r7, #12]
    3aa4:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
    3aa6:	6a3b      	ldr	r3, [r7, #32]
    3aa8:	2b00      	cmp	r3, #0
    3aaa:	d104      	bne.n	3ab6 <xQueueGenericSend+0x26>
    3aac:	f04f 0050 	mov.w	r0, #80	; 0x50
    3ab0:	f380 8811 	msr	BASEPRI, r0
    3ab4:	e7fe      	b.n	3ab4 <xQueueGenericSend+0x24>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3ab6:	68bb      	ldr	r3, [r7, #8]
    3ab8:	2b00      	cmp	r3, #0
    3aba:	d103      	bne.n	3ac4 <xQueueGenericSend+0x34>
    3abc:	6a3b      	ldr	r3, [r7, #32]
    3abe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3ac0:	2b00      	cmp	r3, #0
    3ac2:	d101      	bne.n	3ac8 <xQueueGenericSend+0x38>
    3ac4:	2301      	movs	r3, #1
    3ac6:	e000      	b.n	3aca <xQueueGenericSend+0x3a>
    3ac8:	2300      	movs	r3, #0
    3aca:	2b00      	cmp	r3, #0
    3acc:	d104      	bne.n	3ad8 <xQueueGenericSend+0x48>
    3ace:	f04f 0050 	mov.w	r0, #80	; 0x50
    3ad2:	f380 8811 	msr	BASEPRI, r0
    3ad6:	e7fe      	b.n	3ad6 <xQueueGenericSend+0x46>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    3ad8:	683b      	ldr	r3, [r7, #0]
    3ada:	2b02      	cmp	r3, #2
    3adc:	d103      	bne.n	3ae6 <xQueueGenericSend+0x56>
    3ade:	6a3b      	ldr	r3, [r7, #32]
    3ae0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3ae2:	2b01      	cmp	r3, #1
    3ae4:	d101      	bne.n	3aea <xQueueGenericSend+0x5a>
    3ae6:	2301      	movs	r3, #1
    3ae8:	e000      	b.n	3aec <xQueueGenericSend+0x5c>
    3aea:	2300      	movs	r3, #0
    3aec:	2b00      	cmp	r3, #0
    3aee:	d104      	bne.n	3afa <xQueueGenericSend+0x6a>
    3af0:	f04f 0050 	mov.w	r0, #80	; 0x50
    3af4:	f380 8811 	msr	BASEPRI, r0
    3af8:	e7fe      	b.n	3af8 <xQueueGenericSend+0x68>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    3afa:	f7ff f9ef 	bl	2edc <xTaskGetSchedulerState>
    3afe:	4603      	mov	r3, r0
    3b00:	2b00      	cmp	r3, #0
    3b02:	d102      	bne.n	3b0a <xQueueGenericSend+0x7a>
    3b04:	687b      	ldr	r3, [r7, #4]
    3b06:	2b00      	cmp	r3, #0
    3b08:	d101      	bne.n	3b0e <xQueueGenericSend+0x7e>
    3b0a:	2301      	movs	r3, #1
    3b0c:	e000      	b.n	3b10 <xQueueGenericSend+0x80>
    3b0e:	2300      	movs	r3, #0
    3b10:	2b00      	cmp	r3, #0
    3b12:	d104      	bne.n	3b1e <xQueueGenericSend+0x8e>
    3b14:	f04f 0050 	mov.w	r0, #80	; 0x50
    3b18:	f380 8811 	msr	BASEPRI, r0
    3b1c:	e7fe      	b.n	3b1c <xQueueGenericSend+0x8c>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3b1e:	f000 fd7b 	bl	4618 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3b22:	6a3b      	ldr	r3, [r7, #32]
    3b24:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3b26:	6a3b      	ldr	r3, [r7, #32]
    3b28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3b2a:	429a      	cmp	r2, r3
    3b2c:	d302      	bcc.n	3b34 <xQueueGenericSend+0xa4>
    3b2e:	683b      	ldr	r3, [r7, #0]
    3b30:	2b02      	cmp	r3, #2
    3b32:	d11d      	bne.n	3b70 <xQueueGenericSend+0xe0>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3b34:	6a38      	ldr	r0, [r7, #32]
    3b36:	68b9      	ldr	r1, [r7, #8]
    3b38:	683a      	ldr	r2, [r7, #0]
    3b3a:	f000 fb67 	bl	420c <prvCopyDataToQueue>
    3b3e:	61f8      	str	r0, [r7, #28]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b40:	6a3b      	ldr	r3, [r7, #32]
    3b42:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3b44:	2b00      	cmp	r3, #0
    3b46:	d00a      	beq.n	3b5e <xQueueGenericSend+0xce>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3b48:	6a3b      	ldr	r3, [r7, #32]
    3b4a:	3324      	adds	r3, #36	; 0x24
    3b4c:	4618      	mov	r0, r3
    3b4e:	f7fe fe5b 	bl	2808 <xTaskRemoveFromEventList>
    3b52:	4603      	mov	r3, r0
    3b54:	2b01      	cmp	r3, #1
    3b56:	d107      	bne.n	3b68 <xQueueGenericSend+0xd8>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    3b58:	f000 fd8a 	bl	4670 <vPortYieldFromISR>
    3b5c:	e004      	b.n	3b68 <xQueueGenericSend+0xd8>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3b5e:	69fb      	ldr	r3, [r7, #28]
    3b60:	2b00      	cmp	r3, #0
    3b62:	d001      	beq.n	3b68 <xQueueGenericSend+0xd8>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3b64:	f000 fd84 	bl	4670 <vPortYieldFromISR>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3b68:	f000 fd6c 	bl	4644 <vPortExitCritical>
				return pdPASS;
    3b6c:	2301      	movs	r3, #1
    3b6e:	e059      	b.n	3c24 <xQueueGenericSend+0x194>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3b70:	687b      	ldr	r3, [r7, #4]
    3b72:	2b00      	cmp	r3, #0
    3b74:	d103      	bne.n	3b7e <xQueueGenericSend+0xee>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3b76:	f000 fd65 	bl	4644 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3b7a:	2300      	movs	r3, #0
    3b7c:	e052      	b.n	3c24 <xQueueGenericSend+0x194>
				}
				else if( xEntryTimeSet == pdFALSE )
    3b7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3b80:	2b00      	cmp	r3, #0
    3b82:	d106      	bne.n	3b92 <xQueueGenericSend+0x102>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3b84:	f107 0314 	add.w	r3, r7, #20
    3b88:	4618      	mov	r0, r3
    3b8a:	f7fe fef7 	bl	297c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3b8e:	2301      	movs	r3, #1
    3b90:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3b92:	f000 fd57 	bl	4644 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3b96:	f7fe fb1f 	bl	21d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3b9a:	f000 fd3d 	bl	4618 <vPortEnterCritical>
    3b9e:	6a3b      	ldr	r3, [r7, #32]
    3ba0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    3ba2:	f1b3 3fff 	cmp.w	r3, #4294967295
    3ba6:	d102      	bne.n	3bae <xQueueGenericSend+0x11e>
    3ba8:	6a3b      	ldr	r3, [r7, #32]
    3baa:	2200      	movs	r2, #0
    3bac:	645a      	str	r2, [r3, #68]	; 0x44
    3bae:	6a3b      	ldr	r3, [r7, #32]
    3bb0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3bb2:	f1b3 3fff 	cmp.w	r3, #4294967295
    3bb6:	d102      	bne.n	3bbe <xQueueGenericSend+0x12e>
    3bb8:	6a3b      	ldr	r3, [r7, #32]
    3bba:	2200      	movs	r2, #0
    3bbc:	649a      	str	r2, [r3, #72]	; 0x48
    3bbe:	f000 fd41 	bl	4644 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3bc2:	f107 0214 	add.w	r2, r7, #20
    3bc6:	1d3b      	adds	r3, r7, #4
    3bc8:	4610      	mov	r0, r2
    3bca:	4619      	mov	r1, r3
    3bcc:	f7fe fef4 	bl	29b8 <xTaskCheckForTimeOut>
    3bd0:	4603      	mov	r3, r0
    3bd2:	2b00      	cmp	r3, #0
    3bd4:	d11e      	bne.n	3c14 <xQueueGenericSend+0x184>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3bd6:	6a38      	ldr	r0, [r7, #32]
    3bd8:	f000 fc2a 	bl	4430 <prvIsQueueFull>
    3bdc:	4603      	mov	r3, r0
    3bde:	2b00      	cmp	r3, #0
    3be0:	d012      	beq.n	3c08 <xQueueGenericSend+0x178>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3be2:	6a3b      	ldr	r3, [r7, #32]
    3be4:	f103 0210 	add.w	r2, r3, #16
    3be8:	687b      	ldr	r3, [r7, #4]
    3bea:	4610      	mov	r0, r2
    3bec:	4619      	mov	r1, r3
    3bee:	f7fe fd89 	bl	2704 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3bf2:	6a38      	ldr	r0, [r7, #32]
    3bf4:	f000 fb9e 	bl	4334 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3bf8:	f7fe fafc 	bl	21f4 <xTaskResumeAll>
    3bfc:	4603      	mov	r3, r0
    3bfe:	2b00      	cmp	r3, #0
    3c00:	d10f      	bne.n	3c22 <xQueueGenericSend+0x192>
				{
					portYIELD_WITHIN_API();
    3c02:	f000 fd35 	bl	4670 <vPortYieldFromISR>
    3c06:	e00c      	b.n	3c22 <xQueueGenericSend+0x192>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3c08:	6a38      	ldr	r0, [r7, #32]
    3c0a:	f000 fb93 	bl	4334 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3c0e:	f7fe faf1 	bl	21f4 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    3c12:	e784      	b.n	3b1e <xQueueGenericSend+0x8e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3c14:	6a38      	ldr	r0, [r7, #32]
    3c16:	f000 fb8d 	bl	4334 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3c1a:	f7fe faeb 	bl	21f4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3c1e:	2300      	movs	r3, #0
    3c20:	e000      	b.n	3c24 <xQueueGenericSend+0x194>
		}
	}
    3c22:	e77c      	b.n	3b1e <xQueueGenericSend+0x8e>
}
    3c24:	4618      	mov	r0, r3
    3c26:	3728      	adds	r7, #40	; 0x28
    3c28:	46bd      	mov	sp, r7
    3c2a:	bd80      	pop	{r7, pc}

00003c2c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    3c2c:	b580      	push	{r7, lr}
    3c2e:	b088      	sub	sp, #32
    3c30:	af00      	add	r7, sp, #0
    3c32:	60f8      	str	r0, [r7, #12]
    3c34:	60b9      	str	r1, [r7, #8]
    3c36:	607a      	str	r2, [r7, #4]
    3c38:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3c3a:	68fb      	ldr	r3, [r7, #12]
    3c3c:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    3c3e:	69bb      	ldr	r3, [r7, #24]
    3c40:	2b00      	cmp	r3, #0
    3c42:	d104      	bne.n	3c4e <xQueueGenericSendFromISR+0x22>
    3c44:	f04f 0050 	mov.w	r0, #80	; 0x50
    3c48:	f380 8811 	msr	BASEPRI, r0
    3c4c:	e7fe      	b.n	3c4c <xQueueGenericSendFromISR+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3c4e:	68bb      	ldr	r3, [r7, #8]
    3c50:	2b00      	cmp	r3, #0
    3c52:	d103      	bne.n	3c5c <xQueueGenericSendFromISR+0x30>
    3c54:	69bb      	ldr	r3, [r7, #24]
    3c56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3c58:	2b00      	cmp	r3, #0
    3c5a:	d101      	bne.n	3c60 <xQueueGenericSendFromISR+0x34>
    3c5c:	2301      	movs	r3, #1
    3c5e:	e000      	b.n	3c62 <xQueueGenericSendFromISR+0x36>
    3c60:	2300      	movs	r3, #0
    3c62:	2b00      	cmp	r3, #0
    3c64:	d104      	bne.n	3c70 <xQueueGenericSendFromISR+0x44>
    3c66:	f04f 0050 	mov.w	r0, #80	; 0x50
    3c6a:	f380 8811 	msr	BASEPRI, r0
    3c6e:	e7fe      	b.n	3c6e <xQueueGenericSendFromISR+0x42>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
    3c70:	683b      	ldr	r3, [r7, #0]
    3c72:	2b02      	cmp	r3, #2
    3c74:	d103      	bne.n	3c7e <xQueueGenericSendFromISR+0x52>
    3c76:	69bb      	ldr	r3, [r7, #24]
    3c78:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3c7a:	2b01      	cmp	r3, #1
    3c7c:	d101      	bne.n	3c82 <xQueueGenericSendFromISR+0x56>
    3c7e:	2301      	movs	r3, #1
    3c80:	e000      	b.n	3c84 <xQueueGenericSendFromISR+0x58>
    3c82:	2300      	movs	r3, #0
    3c84:	2b00      	cmp	r3, #0
    3c86:	d104      	bne.n	3c92 <xQueueGenericSendFromISR+0x66>
    3c88:	f04f 0050 	mov.w	r0, #80	; 0x50
    3c8c:	f380 8811 	msr	BASEPRI, r0
    3c90:	e7fe      	b.n	3c90 <xQueueGenericSendFromISR+0x64>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3c92:	2300      	movs	r3, #0
    3c94:	617b      	str	r3, [r7, #20]
    3c96:	f04f 0050 	mov.w	r0, #80	; 0x50
    3c9a:	f380 8811 	msr	BASEPRI, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3c9e:	69bb      	ldr	r3, [r7, #24]
    3ca0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3ca2:	69bb      	ldr	r3, [r7, #24]
    3ca4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3ca6:	429a      	cmp	r2, r3
    3ca8:	d302      	bcc.n	3cb0 <xQueueGenericSendFromISR+0x84>
    3caa:	683b      	ldr	r3, [r7, #0]
    3cac:	2b02      	cmp	r3, #2
    3cae:	d124      	bne.n	3cfa <xQueueGenericSendFromISR+0xce>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3cb0:	69b8      	ldr	r0, [r7, #24]
    3cb2:	68b9      	ldr	r1, [r7, #8]
    3cb4:	683a      	ldr	r2, [r7, #0]
    3cb6:	f000 faa9 	bl	420c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3cba:	69bb      	ldr	r3, [r7, #24]
    3cbc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3cbe:	f1b3 3fff 	cmp.w	r3, #4294967295
    3cc2:	d112      	bne.n	3cea <xQueueGenericSendFromISR+0xbe>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3cc4:	69bb      	ldr	r3, [r7, #24]
    3cc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3cc8:	2b00      	cmp	r3, #0
    3cca:	d013      	beq.n	3cf4 <xQueueGenericSendFromISR+0xc8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ccc:	69bb      	ldr	r3, [r7, #24]
    3cce:	3324      	adds	r3, #36	; 0x24
    3cd0:	4618      	mov	r0, r3
    3cd2:	f7fe fd99 	bl	2808 <xTaskRemoveFromEventList>
    3cd6:	4603      	mov	r3, r0
    3cd8:	2b00      	cmp	r3, #0
    3cda:	d00b      	beq.n	3cf4 <xQueueGenericSendFromISR+0xc8>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3cdc:	687b      	ldr	r3, [r7, #4]
    3cde:	2b00      	cmp	r3, #0
    3ce0:	d008      	beq.n	3cf4 <xQueueGenericSendFromISR+0xc8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3ce2:	687b      	ldr	r3, [r7, #4]
    3ce4:	2201      	movs	r2, #1
    3ce6:	601a      	str	r2, [r3, #0]
    3ce8:	e004      	b.n	3cf4 <xQueueGenericSendFromISR+0xc8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3cea:	69bb      	ldr	r3, [r7, #24]
    3cec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3cee:	1c5a      	adds	r2, r3, #1
    3cf0:	69bb      	ldr	r3, [r7, #24]
    3cf2:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
    3cf4:	2301      	movs	r3, #1
    3cf6:	61fb      	str	r3, [r7, #28]
    3cf8:	e001      	b.n	3cfe <xQueueGenericSendFromISR+0xd2>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3cfa:	2300      	movs	r3, #0
    3cfc:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    3cfe:	f04f 0000 	mov.w	r0, #0
    3d02:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    3d06:	69fb      	ldr	r3, [r7, #28]
}
    3d08:	4618      	mov	r0, r3
    3d0a:	3720      	adds	r7, #32
    3d0c:	46bd      	mov	sp, r7
    3d0e:	bd80      	pop	{r7, pc}

00003d10 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3d10:	b580      	push	{r7, lr}
    3d12:	b086      	sub	sp, #24
    3d14:	af00      	add	r7, sp, #0
    3d16:	6078      	str	r0, [r7, #4]
    3d18:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3d1a:	687b      	ldr	r3, [r7, #4]
    3d1c:	613b      	str	r3, [r7, #16]
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
    3d1e:	693b      	ldr	r3, [r7, #16]
    3d20:	2b00      	cmp	r3, #0
    3d22:	d104      	bne.n	3d2e <xQueueGiveFromISR+0x1e>
    3d24:	f04f 0050 	mov.w	r0, #80	; 0x50
    3d28:	f380 8811 	msr	BASEPRI, r0
    3d2c:	e7fe      	b.n	3d2c <xQueueGiveFromISR+0x1c>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
    3d2e:	693b      	ldr	r3, [r7, #16]
    3d30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3d32:	2b00      	cmp	r3, #0
    3d34:	d004      	beq.n	3d40 <xQueueGiveFromISR+0x30>
    3d36:	f04f 0050 	mov.w	r0, #80	; 0x50
    3d3a:	f380 8811 	msr	BASEPRI, r0
    3d3e:	e7fe      	b.n	3d3e <xQueueGiveFromISR+0x2e>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
    3d40:	693b      	ldr	r3, [r7, #16]
    3d42:	681b      	ldr	r3, [r3, #0]
    3d44:	2b00      	cmp	r3, #0
    3d46:	d103      	bne.n	3d50 <xQueueGiveFromISR+0x40>
    3d48:	693b      	ldr	r3, [r7, #16]
    3d4a:	685b      	ldr	r3, [r3, #4]
    3d4c:	2b00      	cmp	r3, #0
    3d4e:	d101      	bne.n	3d54 <xQueueGiveFromISR+0x44>
    3d50:	2301      	movs	r3, #1
    3d52:	e000      	b.n	3d56 <xQueueGiveFromISR+0x46>
    3d54:	2300      	movs	r3, #0
    3d56:	2b00      	cmp	r3, #0
    3d58:	d104      	bne.n	3d64 <xQueueGiveFromISR+0x54>
    3d5a:	f04f 0050 	mov.w	r0, #80	; 0x50
    3d5e:	f380 8811 	msr	BASEPRI, r0
    3d62:	e7fe      	b.n	3d62 <xQueueGiveFromISR+0x52>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d64:	2300      	movs	r3, #0
    3d66:	60fb      	str	r3, [r7, #12]
    3d68:	f04f 0050 	mov.w	r0, #80	; 0x50
    3d6c:	f380 8811 	msr	BASEPRI, r0
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3d70:	693b      	ldr	r3, [r7, #16]
    3d72:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    3d74:	693b      	ldr	r3, [r7, #16]
    3d76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    3d78:	429a      	cmp	r2, r3
    3d7a:	d224      	bcs.n	3dc6 <xQueueGiveFromISR+0xb6>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    3d7c:	693b      	ldr	r3, [r7, #16]
    3d7e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3d80:	1c5a      	adds	r2, r3, #1
    3d82:	693b      	ldr	r3, [r7, #16]
    3d84:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3d86:	693b      	ldr	r3, [r7, #16]
    3d88:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3d8a:	f1b3 3fff 	cmp.w	r3, #4294967295
    3d8e:	d112      	bne.n	3db6 <xQueueGiveFromISR+0xa6>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d90:	693b      	ldr	r3, [r7, #16]
    3d92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3d94:	2b00      	cmp	r3, #0
    3d96:	d013      	beq.n	3dc0 <xQueueGiveFromISR+0xb0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d98:	693b      	ldr	r3, [r7, #16]
    3d9a:	3324      	adds	r3, #36	; 0x24
    3d9c:	4618      	mov	r0, r3
    3d9e:	f7fe fd33 	bl	2808 <xTaskRemoveFromEventList>
    3da2:	4603      	mov	r3, r0
    3da4:	2b00      	cmp	r3, #0
    3da6:	d00b      	beq.n	3dc0 <xQueueGiveFromISR+0xb0>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3da8:	683b      	ldr	r3, [r7, #0]
    3daa:	2b00      	cmp	r3, #0
    3dac:	d008      	beq.n	3dc0 <xQueueGiveFromISR+0xb0>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3dae:	683b      	ldr	r3, [r7, #0]
    3db0:	2201      	movs	r2, #1
    3db2:	601a      	str	r2, [r3, #0]
    3db4:	e004      	b.n	3dc0 <xQueueGiveFromISR+0xb0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3db6:	693b      	ldr	r3, [r7, #16]
    3db8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3dba:	1c5a      	adds	r2, r3, #1
    3dbc:	693b      	ldr	r3, [r7, #16]
    3dbe:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
    3dc0:	2301      	movs	r3, #1
    3dc2:	617b      	str	r3, [r7, #20]
    3dc4:	e001      	b.n	3dca <xQueueGiveFromISR+0xba>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3dc6:	2300      	movs	r3, #0
    3dc8:	617b      	str	r3, [r7, #20]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    3dca:	f04f 0000 	mov.w	r0, #0
    3dce:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    3dd2:	697b      	ldr	r3, [r7, #20]
}
    3dd4:	4618      	mov	r0, r3
    3dd6:	3718      	adds	r7, #24
    3dd8:	46bd      	mov	sp, r7
    3dda:	bd80      	pop	{r7, pc}

00003ddc <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3ddc:	b580      	push	{r7, lr}
    3dde:	b08a      	sub	sp, #40	; 0x28
    3de0:	af00      	add	r7, sp, #0
    3de2:	60f8      	str	r0, [r7, #12]
    3de4:	60b9      	str	r1, [r7, #8]
    3de6:	607a      	str	r2, [r7, #4]
    3de8:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
    3dea:	2300      	movs	r3, #0
    3dec:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3dee:	68fb      	ldr	r3, [r7, #12]
    3df0:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
    3df2:	6a3b      	ldr	r3, [r7, #32]
    3df4:	2b00      	cmp	r3, #0
    3df6:	d104      	bne.n	3e02 <xQueueGenericReceive+0x26>
    3df8:	f04f 0050 	mov.w	r0, #80	; 0x50
    3dfc:	f380 8811 	msr	BASEPRI, r0
    3e00:	e7fe      	b.n	3e00 <xQueueGenericReceive+0x24>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3e02:	68bb      	ldr	r3, [r7, #8]
    3e04:	2b00      	cmp	r3, #0
    3e06:	d103      	bne.n	3e10 <xQueueGenericReceive+0x34>
    3e08:	6a3b      	ldr	r3, [r7, #32]
    3e0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3e0c:	2b00      	cmp	r3, #0
    3e0e:	d101      	bne.n	3e14 <xQueueGenericReceive+0x38>
    3e10:	2301      	movs	r3, #1
    3e12:	e000      	b.n	3e16 <xQueueGenericReceive+0x3a>
    3e14:	2300      	movs	r3, #0
    3e16:	2b00      	cmp	r3, #0
    3e18:	d104      	bne.n	3e24 <xQueueGenericReceive+0x48>
    3e1a:	f04f 0050 	mov.w	r0, #80	; 0x50
    3e1e:	f380 8811 	msr	BASEPRI, r0
    3e22:	e7fe      	b.n	3e22 <xQueueGenericReceive+0x46>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    3e24:	f7ff f85a 	bl	2edc <xTaskGetSchedulerState>
    3e28:	4603      	mov	r3, r0
    3e2a:	2b00      	cmp	r3, #0
    3e2c:	d102      	bne.n	3e34 <xQueueGenericReceive+0x58>
    3e2e:	687b      	ldr	r3, [r7, #4]
    3e30:	2b00      	cmp	r3, #0
    3e32:	d101      	bne.n	3e38 <xQueueGenericReceive+0x5c>
    3e34:	2301      	movs	r3, #1
    3e36:	e000      	b.n	3e3a <xQueueGenericReceive+0x5e>
    3e38:	2300      	movs	r3, #0
    3e3a:	2b00      	cmp	r3, #0
    3e3c:	d104      	bne.n	3e48 <xQueueGenericReceive+0x6c>
    3e3e:	f04f 0050 	mov.w	r0, #80	; 0x50
    3e42:	f380 8811 	msr	BASEPRI, r0
    3e46:	e7fe      	b.n	3e46 <xQueueGenericReceive+0x6a>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3e48:	f000 fbe6 	bl	4618 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3e4c:	6a3b      	ldr	r3, [r7, #32]
    3e4e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3e50:	2b00      	cmp	r3, #0
    3e52:	d03b      	beq.n	3ecc <xQueueGenericReceive+0xf0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3e54:	6a3b      	ldr	r3, [r7, #32]
    3e56:	68db      	ldr	r3, [r3, #12]
    3e58:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e5a:	6a38      	ldr	r0, [r7, #32]
    3e5c:	68b9      	ldr	r1, [r7, #8]
    3e5e:	f000 fa43 	bl	42e8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3e62:	683b      	ldr	r3, [r7, #0]
    3e64:	2b00      	cmp	r3, #0
    3e66:	d11c      	bne.n	3ea2 <xQueueGenericReceive+0xc6>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    3e68:	6a3b      	ldr	r3, [r7, #32]
    3e6a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3e6c:	1e5a      	subs	r2, r3, #1
    3e6e:	6a3b      	ldr	r3, [r7, #32]
    3e70:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3e72:	6a3b      	ldr	r3, [r7, #32]
    3e74:	681b      	ldr	r3, [r3, #0]
    3e76:	2b00      	cmp	r3, #0
    3e78:	d104      	bne.n	3e84 <xQueueGenericReceive+0xa8>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    3e7a:	f7ff f9c5 	bl	3208 <pvTaskIncrementMutexHeldCount>
    3e7e:	4602      	mov	r2, r0
    3e80:	6a3b      	ldr	r3, [r7, #32]
    3e82:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e84:	6a3b      	ldr	r3, [r7, #32]
    3e86:	691b      	ldr	r3, [r3, #16]
    3e88:	2b00      	cmp	r3, #0
    3e8a:	d01b      	beq.n	3ec4 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3e8c:	6a3b      	ldr	r3, [r7, #32]
    3e8e:	3310      	adds	r3, #16
    3e90:	4618      	mov	r0, r3
    3e92:	f7fe fcb9 	bl	2808 <xTaskRemoveFromEventList>
    3e96:	4603      	mov	r3, r0
    3e98:	2b01      	cmp	r3, #1
    3e9a:	d113      	bne.n	3ec4 <xQueueGenericReceive+0xe8>
						{
							queueYIELD_IF_USING_PREEMPTION();
    3e9c:	f000 fbe8 	bl	4670 <vPortYieldFromISR>
    3ea0:	e010      	b.n	3ec4 <xQueueGenericReceive+0xe8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3ea2:	6a3b      	ldr	r3, [r7, #32]
    3ea4:	69fa      	ldr	r2, [r7, #28]
    3ea6:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ea8:	6a3b      	ldr	r3, [r7, #32]
    3eaa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3eac:	2b00      	cmp	r3, #0
    3eae:	d009      	beq.n	3ec4 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3eb0:	6a3b      	ldr	r3, [r7, #32]
    3eb2:	3324      	adds	r3, #36	; 0x24
    3eb4:	4618      	mov	r0, r3
    3eb6:	f7fe fca7 	bl	2808 <xTaskRemoveFromEventList>
    3eba:	4603      	mov	r3, r0
    3ebc:	2b00      	cmp	r3, #0
    3ebe:	d001      	beq.n	3ec4 <xQueueGenericReceive+0xe8>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3ec0:	f000 fbd6 	bl	4670 <vPortYieldFromISR>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3ec4:	f000 fbbe 	bl	4644 <vPortExitCritical>
				return pdPASS;
    3ec8:	2301      	movs	r3, #1
    3eca:	e066      	b.n	3f9a <xQueueGenericReceive+0x1be>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3ecc:	687b      	ldr	r3, [r7, #4]
    3ece:	2b00      	cmp	r3, #0
    3ed0:	d103      	bne.n	3eda <xQueueGenericReceive+0xfe>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3ed2:	f000 fbb7 	bl	4644 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3ed6:	2300      	movs	r3, #0
    3ed8:	e05f      	b.n	3f9a <xQueueGenericReceive+0x1be>
				}
				else if( xEntryTimeSet == pdFALSE )
    3eda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    3edc:	2b00      	cmp	r3, #0
    3ede:	d106      	bne.n	3eee <xQueueGenericReceive+0x112>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3ee0:	f107 0314 	add.w	r3, r7, #20
    3ee4:	4618      	mov	r0, r3
    3ee6:	f7fe fd49 	bl	297c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3eea:	2301      	movs	r3, #1
    3eec:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3eee:	f000 fba9 	bl	4644 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3ef2:	f7fe f971 	bl	21d8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3ef6:	f000 fb8f 	bl	4618 <vPortEnterCritical>
    3efa:	6a3b      	ldr	r3, [r7, #32]
    3efc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    3efe:	f1b3 3fff 	cmp.w	r3, #4294967295
    3f02:	d102      	bne.n	3f0a <xQueueGenericReceive+0x12e>
    3f04:	6a3b      	ldr	r3, [r7, #32]
    3f06:	2200      	movs	r2, #0
    3f08:	645a      	str	r2, [r3, #68]	; 0x44
    3f0a:	6a3b      	ldr	r3, [r7, #32]
    3f0c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    3f0e:	f1b3 3fff 	cmp.w	r3, #4294967295
    3f12:	d102      	bne.n	3f1a <xQueueGenericReceive+0x13e>
    3f14:	6a3b      	ldr	r3, [r7, #32]
    3f16:	2200      	movs	r2, #0
    3f18:	649a      	str	r2, [r3, #72]	; 0x48
    3f1a:	f000 fb93 	bl	4644 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3f1e:	f107 0214 	add.w	r2, r7, #20
    3f22:	1d3b      	adds	r3, r7, #4
    3f24:	4610      	mov	r0, r2
    3f26:	4619      	mov	r1, r3
    3f28:	f7fe fd46 	bl	29b8 <xTaskCheckForTimeOut>
    3f2c:	4603      	mov	r3, r0
    3f2e:	2b00      	cmp	r3, #0
    3f30:	d12b      	bne.n	3f8a <xQueueGenericReceive+0x1ae>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3f32:	6a38      	ldr	r0, [r7, #32]
    3f34:	f000 fa4a 	bl	43cc <prvIsQueueEmpty>
    3f38:	4603      	mov	r3, r0
    3f3a:	2b00      	cmp	r3, #0
    3f3c:	d01f      	beq.n	3f7e <xQueueGenericReceive+0x1a2>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3f3e:	6a3b      	ldr	r3, [r7, #32]
    3f40:	681b      	ldr	r3, [r3, #0]
    3f42:	2b00      	cmp	r3, #0
    3f44:	d108      	bne.n	3f58 <xQueueGenericReceive+0x17c>
					{
						taskENTER_CRITICAL();
    3f46:	f000 fb67 	bl	4618 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    3f4a:	6a3b      	ldr	r3, [r7, #32]
    3f4c:	685b      	ldr	r3, [r3, #4]
    3f4e:	4618      	mov	r0, r3
    3f50:	f7fe ffe2 	bl	2f18 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    3f54:	f000 fb76 	bl	4644 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3f58:	6a3b      	ldr	r3, [r7, #32]
    3f5a:	f103 0224 	add.w	r2, r3, #36	; 0x24
    3f5e:	687b      	ldr	r3, [r7, #4]
    3f60:	4610      	mov	r0, r2
    3f62:	4619      	mov	r1, r3
    3f64:	f7fe fbce 	bl	2704 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3f68:	6a38      	ldr	r0, [r7, #32]
    3f6a:	f000 f9e3 	bl	4334 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3f6e:	f7fe f941 	bl	21f4 <xTaskResumeAll>
    3f72:	4603      	mov	r3, r0
    3f74:	2b00      	cmp	r3, #0
    3f76:	d10f      	bne.n	3f98 <xQueueGenericReceive+0x1bc>
				{
					portYIELD_WITHIN_API();
    3f78:	f000 fb7a 	bl	4670 <vPortYieldFromISR>
    3f7c:	e00c      	b.n	3f98 <xQueueGenericReceive+0x1bc>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3f7e:	6a38      	ldr	r0, [r7, #32]
    3f80:	f000 f9d8 	bl	4334 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3f84:	f7fe f936 	bl	21f4 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    3f88:	e75e      	b.n	3e48 <xQueueGenericReceive+0x6c>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3f8a:	6a38      	ldr	r0, [r7, #32]
    3f8c:	f000 f9d2 	bl	4334 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3f90:	f7fe f930 	bl	21f4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3f94:	2300      	movs	r3, #0
    3f96:	e000      	b.n	3f9a <xQueueGenericReceive+0x1be>
		}
	}
    3f98:	e756      	b.n	3e48 <xQueueGenericReceive+0x6c>
}
    3f9a:	4618      	mov	r0, r3
    3f9c:	3728      	adds	r7, #40	; 0x28
    3f9e:	46bd      	mov	sp, r7
    3fa0:	bd80      	pop	{r7, pc}
    3fa2:	bf00      	nop

00003fa4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3fa4:	b580      	push	{r7, lr}
    3fa6:	b088      	sub	sp, #32
    3fa8:	af00      	add	r7, sp, #0
    3faa:	60f8      	str	r0, [r7, #12]
    3fac:	60b9      	str	r1, [r7, #8]
    3fae:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    3fb0:	68fb      	ldr	r3, [r7, #12]
    3fb2:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
    3fb4:	69bb      	ldr	r3, [r7, #24]
    3fb6:	2b00      	cmp	r3, #0
    3fb8:	d104      	bne.n	3fc4 <xQueueReceiveFromISR+0x20>
    3fba:	f04f 0050 	mov.w	r0, #80	; 0x50
    3fbe:	f380 8811 	msr	BASEPRI, r0
    3fc2:	e7fe      	b.n	3fc2 <xQueueReceiveFromISR+0x1e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    3fc4:	68bb      	ldr	r3, [r7, #8]
    3fc6:	2b00      	cmp	r3, #0
    3fc8:	d103      	bne.n	3fd2 <xQueueReceiveFromISR+0x2e>
    3fca:	69bb      	ldr	r3, [r7, #24]
    3fcc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3fce:	2b00      	cmp	r3, #0
    3fd0:	d101      	bne.n	3fd6 <xQueueReceiveFromISR+0x32>
    3fd2:	2301      	movs	r3, #1
    3fd4:	e000      	b.n	3fd8 <xQueueReceiveFromISR+0x34>
    3fd6:	2300      	movs	r3, #0
    3fd8:	2b00      	cmp	r3, #0
    3fda:	d104      	bne.n	3fe6 <xQueueReceiveFromISR+0x42>
    3fdc:	f04f 0050 	mov.w	r0, #80	; 0x50
    3fe0:	f380 8811 	msr	BASEPRI, r0
    3fe4:	e7fe      	b.n	3fe4 <xQueueReceiveFromISR+0x40>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3fe6:	2300      	movs	r3, #0
    3fe8:	617b      	str	r3, [r7, #20]
    3fea:	f04f 0050 	mov.w	r0, #80	; 0x50
    3fee:	f380 8811 	msr	BASEPRI, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3ff2:	69bb      	ldr	r3, [r7, #24]
    3ff4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    3ff6:	2b00      	cmp	r3, #0
    3ff8:	d028      	beq.n	404c <xQueueReceiveFromISR+0xa8>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3ffa:	69b8      	ldr	r0, [r7, #24]
    3ffc:	68b9      	ldr	r1, [r7, #8]
    3ffe:	f000 f973 	bl	42e8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    4002:	69bb      	ldr	r3, [r7, #24]
    4004:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4006:	1e5a      	subs	r2, r3, #1
    4008:	69bb      	ldr	r3, [r7, #24]
    400a:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    400c:	69bb      	ldr	r3, [r7, #24]
    400e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4010:	f1b3 3fff 	cmp.w	r3, #4294967295
    4014:	d112      	bne.n	403c <xQueueReceiveFromISR+0x98>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4016:	69bb      	ldr	r3, [r7, #24]
    4018:	691b      	ldr	r3, [r3, #16]
    401a:	2b00      	cmp	r3, #0
    401c:	d013      	beq.n	4046 <xQueueReceiveFromISR+0xa2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    401e:	69bb      	ldr	r3, [r7, #24]
    4020:	3310      	adds	r3, #16
    4022:	4618      	mov	r0, r3
    4024:	f7fe fbf0 	bl	2808 <xTaskRemoveFromEventList>
    4028:	4603      	mov	r3, r0
    402a:	2b00      	cmp	r3, #0
    402c:	d00b      	beq.n	4046 <xQueueReceiveFromISR+0xa2>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    402e:	687b      	ldr	r3, [r7, #4]
    4030:	2b00      	cmp	r3, #0
    4032:	d008      	beq.n	4046 <xQueueReceiveFromISR+0xa2>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    4034:	687b      	ldr	r3, [r7, #4]
    4036:	2201      	movs	r2, #1
    4038:	601a      	str	r2, [r3, #0]
    403a:	e004      	b.n	4046 <xQueueReceiveFromISR+0xa2>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    403c:	69bb      	ldr	r3, [r7, #24]
    403e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    4040:	1c5a      	adds	r2, r3, #1
    4042:	69bb      	ldr	r3, [r7, #24]
    4044:	645a      	str	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
    4046:	2301      	movs	r3, #1
    4048:	61fb      	str	r3, [r7, #28]
    404a:	e001      	b.n	4050 <xQueueReceiveFromISR+0xac>
		}
		else
		{
			xReturn = pdFAIL;
    404c:	2300      	movs	r3, #0
    404e:	61fb      	str	r3, [r7, #28]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    4050:	f04f 0000 	mov.w	r0, #0
    4054:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    4058:	69fb      	ldr	r3, [r7, #28]
}
    405a:	4618      	mov	r0, r3
    405c:	3720      	adds	r7, #32
    405e:	46bd      	mov	sp, r7
    4060:	bd80      	pop	{r7, pc}
    4062:	bf00      	nop

00004064 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    4064:	b580      	push	{r7, lr}
    4066:	b086      	sub	sp, #24
    4068:	af00      	add	r7, sp, #0
    406a:	6078      	str	r0, [r7, #4]
    406c:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    406e:	687b      	ldr	r3, [r7, #4]
    4070:	613b      	str	r3, [r7, #16]

	configASSERT( pxQueue );
    4072:	693b      	ldr	r3, [r7, #16]
    4074:	2b00      	cmp	r3, #0
    4076:	d104      	bne.n	4082 <xQueuePeekFromISR+0x1e>
    4078:	f04f 0050 	mov.w	r0, #80	; 0x50
    407c:	f380 8811 	msr	BASEPRI, r0
    4080:	e7fe      	b.n	4080 <xQueuePeekFromISR+0x1c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    4082:	683b      	ldr	r3, [r7, #0]
    4084:	2b00      	cmp	r3, #0
    4086:	d103      	bne.n	4090 <xQueuePeekFromISR+0x2c>
    4088:	693b      	ldr	r3, [r7, #16]
    408a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    408c:	2b00      	cmp	r3, #0
    408e:	d101      	bne.n	4094 <xQueuePeekFromISR+0x30>
    4090:	2301      	movs	r3, #1
    4092:	e000      	b.n	4096 <xQueuePeekFromISR+0x32>
    4094:	2300      	movs	r3, #0
    4096:	2b00      	cmp	r3, #0
    4098:	d104      	bne.n	40a4 <xQueuePeekFromISR+0x40>
    409a:	f04f 0050 	mov.w	r0, #80	; 0x50
    409e:	f380 8811 	msr	BASEPRI, r0
    40a2:	e7fe      	b.n	40a2 <xQueuePeekFromISR+0x3e>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
    40a4:	693b      	ldr	r3, [r7, #16]
    40a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    40a8:	2b00      	cmp	r3, #0
    40aa:	d104      	bne.n	40b6 <xQueuePeekFromISR+0x52>
    40ac:	f04f 0050 	mov.w	r0, #80	; 0x50
    40b0:	f380 8811 	msr	BASEPRI, r0
    40b4:	e7fe      	b.n	40b4 <xQueuePeekFromISR+0x50>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    40b6:	2300      	movs	r3, #0
    40b8:	60fb      	str	r3, [r7, #12]
    40ba:	f04f 0050 	mov.w	r0, #80	; 0x50
    40be:	f380 8811 	msr	BASEPRI, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    40c2:	693b      	ldr	r3, [r7, #16]
    40c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    40c6:	2b00      	cmp	r3, #0
    40c8:	d00c      	beq.n	40e4 <xQueuePeekFromISR+0x80>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    40ca:	693b      	ldr	r3, [r7, #16]
    40cc:	68db      	ldr	r3, [r3, #12]
    40ce:	60bb      	str	r3, [r7, #8]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    40d0:	6938      	ldr	r0, [r7, #16]
    40d2:	6839      	ldr	r1, [r7, #0]
    40d4:	f000 f908 	bl	42e8 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    40d8:	693b      	ldr	r3, [r7, #16]
    40da:	68ba      	ldr	r2, [r7, #8]
    40dc:	60da      	str	r2, [r3, #12]

			xReturn = pdPASS;
    40de:	2301      	movs	r3, #1
    40e0:	617b      	str	r3, [r7, #20]
    40e2:	e001      	b.n	40e8 <xQueuePeekFromISR+0x84>
		}
		else
		{
			xReturn = pdFAIL;
    40e4:	2300      	movs	r3, #0
    40e6:	617b      	str	r3, [r7, #20]
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    40e8:	f04f 0000 	mov.w	r0, #0
    40ec:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
    40f0:	697b      	ldr	r3, [r7, #20]
}
    40f2:	4618      	mov	r0, r3
    40f4:	3718      	adds	r7, #24
    40f6:	46bd      	mov	sp, r7
    40f8:	bd80      	pop	{r7, pc}
    40fa:	bf00      	nop

000040fc <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    40fc:	b580      	push	{r7, lr}
    40fe:	b084      	sub	sp, #16
    4100:	af00      	add	r7, sp, #0
    4102:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4104:	687b      	ldr	r3, [r7, #4]
    4106:	2b00      	cmp	r3, #0
    4108:	d104      	bne.n	4114 <uxQueueMessagesWaiting+0x18>
    410a:	f04f 0050 	mov.w	r0, #80	; 0x50
    410e:	f380 8811 	msr	BASEPRI, r0
    4112:	e7fe      	b.n	4112 <uxQueueMessagesWaiting+0x16>

	taskENTER_CRITICAL();
    4114:	f000 fa80 	bl	4618 <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4118:	687b      	ldr	r3, [r7, #4]
    411a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    411c:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
    411e:	f000 fa91 	bl	4644 <vPortExitCritical>

	return uxReturn;
    4122:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4124:	4618      	mov	r0, r3
    4126:	3710      	adds	r7, #16
    4128:	46bd      	mov	sp, r7
    412a:	bd80      	pop	{r7, pc}

0000412c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    412c:	b580      	push	{r7, lr}
    412e:	b084      	sub	sp, #16
    4130:	af00      	add	r7, sp, #0
    4132:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    4134:	687b      	ldr	r3, [r7, #4]
    4136:	60fb      	str	r3, [r7, #12]
	configASSERT( pxQueue );
    4138:	68fb      	ldr	r3, [r7, #12]
    413a:	2b00      	cmp	r3, #0
    413c:	d104      	bne.n	4148 <uxQueueSpacesAvailable+0x1c>
    413e:	f04f 0050 	mov.w	r0, #80	; 0x50
    4142:	f380 8811 	msr	BASEPRI, r0
    4146:	e7fe      	b.n	4146 <uxQueueSpacesAvailable+0x1a>

	taskENTER_CRITICAL();
    4148:	f000 fa66 	bl	4618 <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    414c:	68fb      	ldr	r3, [r7, #12]
    414e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    4150:	68fb      	ldr	r3, [r7, #12]
    4152:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4154:	1ad3      	subs	r3, r2, r3
    4156:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
    4158:	f000 fa74 	bl	4644 <vPortExitCritical>

	return uxReturn;
    415c:	68bb      	ldr	r3, [r7, #8]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    415e:	4618      	mov	r0, r3
    4160:	3710      	adds	r7, #16
    4162:	46bd      	mov	sp, r7
    4164:	bd80      	pop	{r7, pc}
    4166:	bf00      	nop

00004168 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    4168:	b480      	push	{r7}
    416a:	b085      	sub	sp, #20
    416c:	af00      	add	r7, sp, #0
    416e:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4170:	687b      	ldr	r3, [r7, #4]
    4172:	2b00      	cmp	r3, #0
    4174:	d104      	bne.n	4180 <uxQueueMessagesWaitingFromISR+0x18>
    4176:	f04f 0050 	mov.w	r0, #80	; 0x50
    417a:	f380 8811 	msr	BASEPRI, r0
    417e:	e7fe      	b.n	417e <uxQueueMessagesWaitingFromISR+0x16>

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4180:	687b      	ldr	r3, [r7, #4]
    4182:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4184:	60fb      	str	r3, [r7, #12]

	return uxReturn;
    4186:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4188:	4618      	mov	r0, r3
    418a:	3714      	adds	r7, #20
    418c:	46bd      	mov	sp, r7
    418e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4192:	4770      	bx	lr

00004194 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    4194:	b580      	push	{r7, lr}
    4196:	b084      	sub	sp, #16
    4198:	af00      	add	r7, sp, #0
    419a:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    419c:	687b      	ldr	r3, [r7, #4]
    419e:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
    41a0:	68fb      	ldr	r3, [r7, #12]
    41a2:	2b00      	cmp	r3, #0
    41a4:	d104      	bne.n	41b0 <vQueueDelete+0x1c>
    41a6:	f04f 0050 	mov.w	r0, #80	; 0x50
    41aa:	f380 8811 	msr	BASEPRI, r0
    41ae:	e7fe      	b.n	41ae <vQueueDelete+0x1a>
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    41b0:	68f8      	ldr	r0, [r7, #12]
    41b2:	f000 fc41 	bl	4a38 <vPortFree>
}
    41b6:	3710      	adds	r7, #16
    41b8:	46bd      	mov	sp, r7
    41ba:	bd80      	pop	{r7, pc}

000041bc <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
    41bc:	b480      	push	{r7}
    41be:	b083      	sub	sp, #12
    41c0:	af00      	add	r7, sp, #0
    41c2:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
    41c4:	687b      	ldr	r3, [r7, #4]
    41c6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
	}
    41c8:	4618      	mov	r0, r3
    41ca:	370c      	adds	r7, #12
    41cc:	46bd      	mov	sp, r7
    41ce:	f85d 7b04 	ldr.w	r7, [sp], #4
    41d2:	4770      	bx	lr

000041d4 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
    41d4:	b480      	push	{r7}
    41d6:	b083      	sub	sp, #12
    41d8:	af00      	add	r7, sp, #0
    41da:	6078      	str	r0, [r7, #4]
    41dc:	6039      	str	r1, [r7, #0]
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
    41de:	687b      	ldr	r3, [r7, #4]
    41e0:	683a      	ldr	r2, [r7, #0]
    41e2:	64da      	str	r2, [r3, #76]	; 0x4c
	}
    41e4:	370c      	adds	r7, #12
    41e6:	46bd      	mov	sp, r7
    41e8:	f85d 7b04 	ldr.w	r7, [sp], #4
    41ec:	4770      	bx	lr
    41ee:	bf00      	nop

000041f0 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
    41f0:	b480      	push	{r7}
    41f2:	b083      	sub	sp, #12
    41f4:	af00      	add	r7, sp, #0
    41f6:	6078      	str	r0, [r7, #4]
		return ( ( Queue_t * ) xQueue )->ucQueueType;
    41f8:	687b      	ldr	r3, [r7, #4]
    41fa:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
	}
    41fe:	4618      	mov	r0, r3
    4200:	370c      	adds	r7, #12
    4202:	46bd      	mov	sp, r7
    4204:	f85d 7b04 	ldr.w	r7, [sp], #4
    4208:	4770      	bx	lr
    420a:	bf00      	nop

0000420c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    420c:	b580      	push	{r7, lr}
    420e:	b086      	sub	sp, #24
    4210:	af00      	add	r7, sp, #0
    4212:	60f8      	str	r0, [r7, #12]
    4214:	60b9      	str	r1, [r7, #8]
    4216:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
    4218:	2300      	movs	r3, #0
    421a:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    421c:	68fb      	ldr	r3, [r7, #12]
    421e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4220:	2b00      	cmp	r3, #0
    4222:	d10d      	bne.n	4240 <prvCopyDataToQueue+0x34>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    4224:	68fb      	ldr	r3, [r7, #12]
    4226:	681b      	ldr	r3, [r3, #0]
    4228:	2b00      	cmp	r3, #0
    422a:	d152      	bne.n	42d2 <prvCopyDataToQueue+0xc6>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    422c:	68fb      	ldr	r3, [r7, #12]
    422e:	685b      	ldr	r3, [r3, #4]
    4230:	4618      	mov	r0, r3
    4232:	f7fe fecf 	bl	2fd4 <xTaskPriorityDisinherit>
    4236:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
    4238:	68fb      	ldr	r3, [r7, #12]
    423a:	2200      	movs	r2, #0
    423c:	605a      	str	r2, [r3, #4]
    423e:	e048      	b.n	42d2 <prvCopyDataToQueue+0xc6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    4240:	687b      	ldr	r3, [r7, #4]
    4242:	2b00      	cmp	r3, #0
    4244:	d11a      	bne.n	427c <prvCopyDataToQueue+0x70>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    4246:	68fb      	ldr	r3, [r7, #12]
    4248:	689a      	ldr	r2, [r3, #8]
    424a:	68fb      	ldr	r3, [r7, #12]
    424c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    424e:	4610      	mov	r0, r2
    4250:	68b9      	ldr	r1, [r7, #8]
    4252:	461a      	mov	r2, r3
    4254:	f002 ffca 	bl	71ec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4258:	68fb      	ldr	r3, [r7, #12]
    425a:	689a      	ldr	r2, [r3, #8]
    425c:	68fb      	ldr	r3, [r7, #12]
    425e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4260:	441a      	add	r2, r3
    4262:	68fb      	ldr	r3, [r7, #12]
    4264:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    4266:	68fb      	ldr	r3, [r7, #12]
    4268:	689a      	ldr	r2, [r3, #8]
    426a:	68fb      	ldr	r3, [r7, #12]
    426c:	685b      	ldr	r3, [r3, #4]
    426e:	429a      	cmp	r2, r3
    4270:	d32f      	bcc.n	42d2 <prvCopyDataToQueue+0xc6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4272:	68fb      	ldr	r3, [r7, #12]
    4274:	681a      	ldr	r2, [r3, #0]
    4276:	68fb      	ldr	r3, [r7, #12]
    4278:	609a      	str	r2, [r3, #8]
    427a:	e02a      	b.n	42d2 <prvCopyDataToQueue+0xc6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    427c:	68fb      	ldr	r3, [r7, #12]
    427e:	68da      	ldr	r2, [r3, #12]
    4280:	68fb      	ldr	r3, [r7, #12]
    4282:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4284:	4610      	mov	r0, r2
    4286:	68b9      	ldr	r1, [r7, #8]
    4288:	461a      	mov	r2, r3
    428a:	f002 ffaf 	bl	71ec <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    428e:	68fb      	ldr	r3, [r7, #12]
    4290:	68da      	ldr	r2, [r3, #12]
    4292:	68fb      	ldr	r3, [r7, #12]
    4294:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4296:	425b      	negs	r3, r3
    4298:	441a      	add	r2, r3
    429a:	68fb      	ldr	r3, [r7, #12]
    429c:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    429e:	68fb      	ldr	r3, [r7, #12]
    42a0:	68da      	ldr	r2, [r3, #12]
    42a2:	68fb      	ldr	r3, [r7, #12]
    42a4:	681b      	ldr	r3, [r3, #0]
    42a6:	429a      	cmp	r2, r3
    42a8:	d207      	bcs.n	42ba <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    42aa:	68fb      	ldr	r3, [r7, #12]
    42ac:	685a      	ldr	r2, [r3, #4]
    42ae:	68fb      	ldr	r3, [r7, #12]
    42b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    42b2:	425b      	negs	r3, r3
    42b4:	441a      	add	r2, r3
    42b6:	68fb      	ldr	r3, [r7, #12]
    42b8:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    42ba:	687b      	ldr	r3, [r7, #4]
    42bc:	2b02      	cmp	r3, #2
    42be:	d108      	bne.n	42d2 <prvCopyDataToQueue+0xc6>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    42c0:	68fb      	ldr	r3, [r7, #12]
    42c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    42c4:	2b00      	cmp	r3, #0
    42c6:	d004      	beq.n	42d2 <prvCopyDataToQueue+0xc6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    42c8:	68fb      	ldr	r3, [r7, #12]
    42ca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    42cc:	1e5a      	subs	r2, r3, #1
    42ce:	68fb      	ldr	r3, [r7, #12]
    42d0:	639a      	str	r2, [r3, #56]	; 0x38
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    42d2:	68fb      	ldr	r3, [r7, #12]
    42d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    42d6:	1c5a      	adds	r2, r3, #1
    42d8:	68fb      	ldr	r3, [r7, #12]
    42da:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
    42dc:	697b      	ldr	r3, [r7, #20]
}
    42de:	4618      	mov	r0, r3
    42e0:	3718      	adds	r7, #24
    42e2:	46bd      	mov	sp, r7
    42e4:	bd80      	pop	{r7, pc}
    42e6:	bf00      	nop

000042e8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    42e8:	b580      	push	{r7, lr}
    42ea:	b082      	sub	sp, #8
    42ec:	af00      	add	r7, sp, #0
    42ee:	6078      	str	r0, [r7, #4]
    42f0:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    42f2:	687b      	ldr	r3, [r7, #4]
    42f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    42f6:	2b00      	cmp	r3, #0
    42f8:	d019      	beq.n	432e <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    42fa:	687b      	ldr	r3, [r7, #4]
    42fc:	68da      	ldr	r2, [r3, #12]
    42fe:	687b      	ldr	r3, [r7, #4]
    4300:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4302:	441a      	add	r2, r3
    4304:	687b      	ldr	r3, [r7, #4]
    4306:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    4308:	687b      	ldr	r3, [r7, #4]
    430a:	68da      	ldr	r2, [r3, #12]
    430c:	687b      	ldr	r3, [r7, #4]
    430e:	685b      	ldr	r3, [r3, #4]
    4310:	429a      	cmp	r2, r3
    4312:	d303      	bcc.n	431c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    4314:	687b      	ldr	r3, [r7, #4]
    4316:	681a      	ldr	r2, [r3, #0]
    4318:	687b      	ldr	r3, [r7, #4]
    431a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    431c:	687b      	ldr	r3, [r7, #4]
    431e:	68da      	ldr	r2, [r3, #12]
    4320:	687b      	ldr	r3, [r7, #4]
    4322:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    4324:	6838      	ldr	r0, [r7, #0]
    4326:	4611      	mov	r1, r2
    4328:	461a      	mov	r2, r3
    432a:	f002 ff5f 	bl	71ec <memcpy>
	}
}
    432e:	3708      	adds	r7, #8
    4330:	46bd      	mov	sp, r7
    4332:	bd80      	pop	{r7, pc}

00004334 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    4334:	b580      	push	{r7, lr}
    4336:	b082      	sub	sp, #8
    4338:	af00      	add	r7, sp, #0
    433a:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    433c:	f000 f96c 	bl	4618 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4340:	e014      	b.n	436c <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4342:	687b      	ldr	r3, [r7, #4]
    4344:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    4346:	2b00      	cmp	r3, #0
    4348:	d00a      	beq.n	4360 <prvUnlockQueue+0x2c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    434a:	687b      	ldr	r3, [r7, #4]
    434c:	3324      	adds	r3, #36	; 0x24
    434e:	4618      	mov	r0, r3
    4350:	f7fe fa5a 	bl	2808 <xTaskRemoveFromEventList>
    4354:	4603      	mov	r3, r0
    4356:	2b00      	cmp	r3, #0
    4358:	d003      	beq.n	4362 <prvUnlockQueue+0x2e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    435a:	f7fe fb81 	bl	2a60 <vTaskMissedYield>
    435e:	e000      	b.n	4362 <prvUnlockQueue+0x2e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    4360:	e008      	b.n	4374 <prvUnlockQueue+0x40>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4362:	687b      	ldr	r3, [r7, #4]
    4364:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4366:	1e5a      	subs	r2, r3, #1
    4368:	687b      	ldr	r3, [r7, #4]
    436a:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    436c:	687b      	ldr	r3, [r7, #4]
    436e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    4370:	2b00      	cmp	r3, #0
    4372:	dce6      	bgt.n	4342 <prvUnlockQueue+0xe>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4374:	687b      	ldr	r3, [r7, #4]
    4376:	f04f 32ff 	mov.w	r2, #4294967295
    437a:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
    437c:	f000 f962 	bl	4644 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4380:	f000 f94a 	bl	4618 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4384:	e014      	b.n	43b0 <prvUnlockQueue+0x7c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4386:	687b      	ldr	r3, [r7, #4]
    4388:	691b      	ldr	r3, [r3, #16]
    438a:	2b00      	cmp	r3, #0
    438c:	d00f      	beq.n	43ae <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    438e:	687b      	ldr	r3, [r7, #4]
    4390:	3310      	adds	r3, #16
    4392:	4618      	mov	r0, r3
    4394:	f7fe fa38 	bl	2808 <xTaskRemoveFromEventList>
    4398:	4603      	mov	r3, r0
    439a:	2b00      	cmp	r3, #0
    439c:	d001      	beq.n	43a2 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
    439e:	f7fe fb5f 	bl	2a60 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    43a2:	687b      	ldr	r3, [r7, #4]
    43a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    43a6:	1e5a      	subs	r2, r3, #1
    43a8:	687b      	ldr	r3, [r7, #4]
    43aa:	645a      	str	r2, [r3, #68]	; 0x44
    43ac:	e000      	b.n	43b0 <prvUnlockQueue+0x7c>
			}
			else
			{
				break;
    43ae:	e003      	b.n	43b8 <prvUnlockQueue+0x84>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    43b0:	687b      	ldr	r3, [r7, #4]
    43b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    43b4:	2b00      	cmp	r3, #0
    43b6:	dce6      	bgt.n	4386 <prvUnlockQueue+0x52>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    43b8:	687b      	ldr	r3, [r7, #4]
    43ba:	f04f 32ff 	mov.w	r2, #4294967295
    43be:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
    43c0:	f000 f940 	bl	4644 <vPortExitCritical>
}
    43c4:	3708      	adds	r7, #8
    43c6:	46bd      	mov	sp, r7
    43c8:	bd80      	pop	{r7, pc}
    43ca:	bf00      	nop

000043cc <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    43cc:	b580      	push	{r7, lr}
    43ce:	b084      	sub	sp, #16
    43d0:	af00      	add	r7, sp, #0
    43d2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
    43d4:	f000 f920 	bl	4618 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    43d8:	687b      	ldr	r3, [r7, #4]
    43da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    43dc:	2b00      	cmp	r3, #0
    43de:	d102      	bne.n	43e6 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
    43e0:	2301      	movs	r3, #1
    43e2:	60fb      	str	r3, [r7, #12]
    43e4:	e001      	b.n	43ea <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
    43e6:	2300      	movs	r3, #0
    43e8:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    43ea:	f000 f92b 	bl	4644 <vPortExitCritical>

	return xReturn;
    43ee:	68fb      	ldr	r3, [r7, #12]
}
    43f0:	4618      	mov	r0, r3
    43f2:	3710      	adds	r7, #16
    43f4:	46bd      	mov	sp, r7
    43f6:	bd80      	pop	{r7, pc}

000043f8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    43f8:	b480      	push	{r7}
    43fa:	b085      	sub	sp, #20
    43fc:	af00      	add	r7, sp, #0
    43fe:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	configASSERT( xQueue );
    4400:	687b      	ldr	r3, [r7, #4]
    4402:	2b00      	cmp	r3, #0
    4404:	d104      	bne.n	4410 <xQueueIsQueueEmptyFromISR+0x18>
    4406:	f04f 0050 	mov.w	r0, #80	; 0x50
    440a:	f380 8811 	msr	BASEPRI, r0
    440e:	e7fe      	b.n	440e <xQueueIsQueueEmptyFromISR+0x16>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4410:	687b      	ldr	r3, [r7, #4]
    4412:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    4414:	2b00      	cmp	r3, #0
    4416:	d102      	bne.n	441e <xQueueIsQueueEmptyFromISR+0x26>
	{
		xReturn = pdTRUE;
    4418:	2301      	movs	r3, #1
    441a:	60fb      	str	r3, [r7, #12]
    441c:	e001      	b.n	4422 <xQueueIsQueueEmptyFromISR+0x2a>
	}
	else
	{
		xReturn = pdFALSE;
    441e:	2300      	movs	r3, #0
    4420:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
    4422:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4424:	4618      	mov	r0, r3
    4426:	3714      	adds	r7, #20
    4428:	46bd      	mov	sp, r7
    442a:	f85d 7b04 	ldr.w	r7, [sp], #4
    442e:	4770      	bx	lr

00004430 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    4430:	b580      	push	{r7, lr}
    4432:	b084      	sub	sp, #16
    4434:	af00      	add	r7, sp, #0
    4436:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4438:	f000 f8ee 	bl	4618 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    443c:	687b      	ldr	r3, [r7, #4]
    443e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    4440:	687b      	ldr	r3, [r7, #4]
    4442:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4444:	429a      	cmp	r2, r3
    4446:	d102      	bne.n	444e <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
    4448:	2301      	movs	r3, #1
    444a:	60fb      	str	r3, [r7, #12]
    444c:	e001      	b.n	4452 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
    444e:	2300      	movs	r3, #0
    4450:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
    4452:	f000 f8f7 	bl	4644 <vPortExitCritical>

	return xReturn;
    4456:	68fb      	ldr	r3, [r7, #12]
}
    4458:	4618      	mov	r0, r3
    445a:	3710      	adds	r7, #16
    445c:	46bd      	mov	sp, r7
    445e:	bd80      	pop	{r7, pc}

00004460 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4460:	b480      	push	{r7}
    4462:	b085      	sub	sp, #20
    4464:	af00      	add	r7, sp, #0
    4466:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	configASSERT( xQueue );
    4468:	687b      	ldr	r3, [r7, #4]
    446a:	2b00      	cmp	r3, #0
    446c:	d104      	bne.n	4478 <xQueueIsQueueFullFromISR+0x18>
    446e:	f04f 0050 	mov.w	r0, #80	; 0x50
    4472:	f380 8811 	msr	BASEPRI, r0
    4476:	e7fe      	b.n	4476 <xQueueIsQueueFullFromISR+0x16>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    4478:	687b      	ldr	r3, [r7, #4]
    447a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    447c:	687b      	ldr	r3, [r7, #4]
    447e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    4480:	429a      	cmp	r2, r3
    4482:	d102      	bne.n	448a <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    4484:	2301      	movs	r3, #1
    4486:	60fb      	str	r3, [r7, #12]
    4488:	e001      	b.n	448e <xQueueIsQueueFullFromISR+0x2e>
	}
	else
	{
		xReturn = pdFALSE;
    448a:	2300      	movs	r3, #0
    448c:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
    448e:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4490:	4618      	mov	r0, r3
    4492:	3714      	adds	r7, #20
    4494:	46bd      	mov	sp, r7
    4496:	f85d 7b04 	ldr.w	r7, [sp], #4
    449a:	4770      	bx	lr

0000449c <prvTaskExitError>:
#if configUSE_TASK_END_SCHEDULER
#include <setjmp.h>
static jmp_buf xJumpBuf; /* Used to restore the original context when the scheduler is ended. */
#endif
/*-----------------------------------------------------------*/
void prvTaskExitError(void) {
    449c:	b480      	push	{r7}
    449e:	af00      	add	r7, sp, #0
  its caller as there is nothing to return to.  If a task wants to exit it
  should instead call vTaskDelete( NULL ).

  Artificially force an assert() to be triggered if configASSERT() is
  defined, then stop here so application writers can catch the error. */
  configASSERT(uxCriticalNesting == ~0UL);
    44a0:	4b07      	ldr	r3, [pc, #28]	; (44c0 <prvTaskExitError+0x24>)
    44a2:	681b      	ldr	r3, [r3, #0]
    44a4:	f1b3 3fff 	cmp.w	r3, #4294967295
    44a8:	d004      	beq.n	44b4 <prvTaskExitError+0x18>
    44aa:	f04f 0050 	mov.w	r0, #80	; 0x50
    44ae:	f380 8811 	msr	BASEPRI, r0
    44b2:	e7fe      	b.n	44b2 <prvTaskExitError+0x16>
  portDISABLE_INTERRUPTS();
    44b4:	f04f 0050 	mov.w	r0, #80	; 0x50
    44b8:	f380 8811 	msr	BASEPRI, r0
  for(;;) {
    /* wait here */
  }
    44bc:	e7fe      	b.n	44bc <prvTaskExitError+0x20>
    44be:	bf00      	nop
    44c0:	20000004 	.word	0x20000004

000044c4 <pxPortInitialiseStack>:
  msr basepri, r0
  bx r14
}
#endif /* (configCOMPILER==configCOMPILER_ARM_KEIL) */
/*-----------------------------------------------------------*/
portSTACK_TYPE *pxPortInitialiseStack(portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters) {
    44c4:	b480      	push	{r7}
    44c6:	b085      	sub	sp, #20
    44c8:	af00      	add	r7, sp, #0
    44ca:	60f8      	str	r0, [r7, #12]
    44cc:	60b9      	str	r1, [r7, #8]
    44ce:	607a      	str	r2, [r7, #4]
  /* Simulate the stack frame as it would be created by a context switch interrupt. */
  pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts,
    44d0:	68fb      	ldr	r3, [r7, #12]
    44d2:	3b04      	subs	r3, #4
    44d4:	60fb      	str	r3, [r7, #12]
                        and to ensure alignment. */
  *pxTopOfStack = portINITIAL_XPSR;   /* xPSR */
    44d6:	68fb      	ldr	r3, [r7, #12]
    44d8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    44dc:	601a      	str	r2, [r3, #0]
  pxTopOfStack--;
    44de:	68fb      	ldr	r3, [r7, #12]
    44e0:	3b04      	subs	r3, #4
    44e2:	60fb      	str	r3, [r7, #12]
  *pxTopOfStack = (portSTACK_TYPE)pxCode;  /* PC */
    44e4:	68ba      	ldr	r2, [r7, #8]
    44e6:	68fb      	ldr	r3, [r7, #12]
    44e8:	601a      	str	r2, [r3, #0]
  pxTopOfStack--;
    44ea:	68fb      	ldr	r3, [r7, #12]
    44ec:	3b04      	subs	r3, #4
    44ee:	60fb      	str	r3, [r7, #12]
  *pxTopOfStack = (portSTACK_TYPE)portTASK_RETURN_ADDRESS;  /* LR */
    44f0:	68fb      	ldr	r3, [r7, #12]
    44f2:	2200      	movs	r2, #0
    44f4:	601a      	str	r2, [r3, #0]

  /* Save code space by skipping register initialization. */
  pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
    44f6:	68fb      	ldr	r3, [r7, #12]
    44f8:	3b14      	subs	r3, #20
    44fa:	60fb      	str	r3, [r7, #12]
  *pxTopOfStack = (portSTACK_TYPE)pvParameters; /* R0 */
    44fc:	687a      	ldr	r2, [r7, #4]
    44fe:	68fb      	ldr	r3, [r7, #12]
    4500:	601a      	str	r2, [r3, #0]

#if configCPU_FAMILY==configCPU_FAMILY_ARM_M4F /* floating point unit */
  /* A save method is being used that requires each task to maintain its
     own exec return value. */
  pxTopOfStack--;
    4502:	68fb      	ldr	r3, [r7, #12]
    4504:	3b04      	subs	r3, #4
    4506:	60fb      	str	r3, [r7, #12]
  *pxTopOfStack = portINITIAL_EXEC_RETURN;
    4508:	68fb      	ldr	r3, [r7, #12]
    450a:	f06f 0202 	mvn.w	r2, #2
    450e:	601a      	str	r2, [r3, #0]
#endif
  pxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */
    4510:	68fb      	ldr	r3, [r7, #12]
    4512:	3b20      	subs	r3, #32
    4514:	60fb      	str	r3, [r7, #12]
  return pxTopOfStack;
    4516:	68fb      	ldr	r3, [r7, #12]
}
    4518:	4618      	mov	r0, r3
    451a:	3714      	adds	r7, #20
    451c:	46bd      	mov	sp, r7
    451e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4522:	4770      	bx	lr

00004524 <vPortInitTickTimer>:
    portEXIT_CRITICAL();
  }
}
#endif /* #if configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/
void vPortInitTickTimer(void) {
    4524:	b480      	push	{r7}
    4526:	af00      	add	r7, sp, #0

  /* set timer interrupt priority in IP[] and enable it in ISER[] */
  NVIC_SetPriority(configLOW_POWER_TIMER_VECTOR_NUMBER, configLIBRARY_LOWEST_INTERRUPT_PRIORITY);
  NVIC_EnableIRQ(configLOW_POWER_TIMER_VECTOR_NUMBER); /* enable IRQ in NVIC_ISER[] */
#else /* use normal SysTick Counter */
  *(portNVIC_SYSPRI3) |= portNVIC_SYSTICK_PRI; /* set priority of SysTick interrupt */
    4528:	4b09      	ldr	r3, [pc, #36]	; (4550 <vPortInitTickTimer+0x2c>)
    452a:	4a09      	ldr	r2, [pc, #36]	; (4550 <vPortInitTickTimer+0x2c>)
    452c:	6812      	ldr	r2, [r2, #0]
    452e:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
    4532:	601a      	str	r2, [r3, #0]
#endif
  /* Configure timer to interrupt at the requested rate. */
  SET_TICK_DURATION(TIMER_COUNTS_FOR_ONE_TICK-1UL);
    4534:	4b07      	ldr	r3, [pc, #28]	; (4554 <vPortInitTickTimer+0x30>)
    4536:	4a08      	ldr	r2, [pc, #32]	; (4558 <vPortInitTickTimer+0x34>)
    4538:	601a      	str	r2, [r3, #0]
  RESET_TICK_COUNTER_VAL();
    453a:	4b08      	ldr	r3, [pc, #32]	; (455c <vPortInitTickTimer+0x38>)
    453c:	2200      	movs	r2, #0
    453e:	601a      	str	r2, [r3, #0]
  ENABLE_TICK_COUNTER();
    4540:	4b07      	ldr	r3, [pc, #28]	; (4560 <vPortInitTickTimer+0x3c>)
    4542:	2207      	movs	r2, #7
    4544:	601a      	str	r2, [r3, #0]
}
    4546:	46bd      	mov	sp, r7
    4548:	f85d 7b04 	ldr.w	r7, [sp], #4
    454c:	4770      	bx	lr
    454e:	bf00      	nop
    4550:	e000ed20 	.word	0xe000ed20
    4554:	e000e014 	.word	0xe000e014
    4558:	00033332 	.word	0x00033332
    455c:	e000e018 	.word	0xe000e018
    4560:	e000e010 	.word	0xe000e010

00004564 <vPortStartTickTimer>:
/*-----------------------------------------------------------*/
void vPortStartTickTimer(void) {
    4564:	b480      	push	{r7}
    4566:	af00      	add	r7, sp, #0
  ENABLE_TICK_COUNTER();
    4568:	4b03      	ldr	r3, [pc, #12]	; (4578 <vPortStartTickTimer+0x14>)
    456a:	2207      	movs	r2, #7
    456c:	601a      	str	r2, [r3, #0]
}
    456e:	46bd      	mov	sp, r7
    4570:	f85d 7b04 	ldr.w	r7, [sp], #4
    4574:	4770      	bx	lr
    4576:	bf00      	nop
    4578:	e000e010 	.word	0xe000e010

0000457c <vPortStopTickTimer>:
/*-----------------------------------------------------------*/
void vPortStopTickTimer(void) {
    457c:	b480      	push	{r7}
    457e:	af00      	add	r7, sp, #0
  DISABLE_TICK_COUNTER();
    4580:	4b03      	ldr	r3, [pc, #12]	; (4590 <vPortStopTickTimer+0x14>)
    4582:	2206      	movs	r2, #6
    4584:	601a      	str	r2, [r3, #0]
}
    4586:	46bd      	mov	sp, r7
    4588:	f85d 7b04 	ldr.w	r7, [sp], #4
    458c:	4770      	bx	lr
    458e:	bf00      	nop
    4590:	e000e010 	.word	0xe000e010

00004594 <vPortEnableVFP>:
/*-----------------------------------------------------------*/
#if configCPU_FAMILY==configCPU_FAMILY_ARM_M4F /* floating point unit */
#if (configCOMPILER==configCOMPILER_ARM_GCC)
void vPortEnableVFP(void) {
    4594:	b480      	push	{r7}
    4596:	af00      	add	r7, sp, #0
  /* The FPU enable bits are in the CPACR. */
  __asm volatile (
    4598:	f8df 01c0 	ldr.w	r0, [pc, #448]	; 475c <pxCurrentTCBConst+0x4>
    459c:	6801      	ldr	r1, [r0, #0]
    459e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    45a2:	6001      	str	r1, [r0, #0]
    "  str r1, [r0]           \n" /* store to new value back */
    : /* no output */
    : /* no input */
    : "r0","r1" /* clobber */
  );
}
    45a4:	46bd      	mov	sp, r7
    45a6:	f85d 7b04 	ldr.w	r7, [sp], #4
    45aa:	4770      	bx	lr

000045ac <xPortStartScheduler>:
	nop
}
#endif /* GNU or Keil */
#endif /* configCPU_FAMILY_ARM_M4F */
/*-----------------------------------------------------------*/
BaseType_t xPortStartScheduler(void) {
    45ac:	b580      	push	{r7, lr}
    45ae:	af00      	add	r7, sp, #0
#if 0 /* do NOT set the SVCall priority */
  /* why: execution of an SVC instruction at a priority equal or higher than SVCall can cause a hard fault (at least on Cortex-M4),
  see https://community.freescale.com/thread/302511 */
  *(portNVIC_SYSPRI2) |= portNVIC_SVCALL_PRI; /* set priority of SVCall interrupt */
#endif
  *(portNVIC_SYSPRI3) |= portNVIC_PENDSV_PRI; /* set priority of PendSV interrupt */
    45b0:	4b10      	ldr	r3, [pc, #64]	; (45f4 <xPortStartScheduler+0x48>)
    45b2:	4a10      	ldr	r2, [pc, #64]	; (45f4 <xPortStartScheduler+0x48>)
    45b4:	6812      	ldr	r2, [r2, #0]
    45b6:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    45ba:	601a      	str	r2, [r3, #0]
  uxCriticalNesting = 0; /* Initialize the critical nesting count ready for the first task. */
    45bc:	4b0e      	ldr	r3, [pc, #56]	; (45f8 <xPortStartScheduler+0x4c>)
    45be:	2200      	movs	r2, #0
    45c0:	601a      	str	r2, [r3, #0]
  vPortInitTickTimer(); /* initialize tick timer */
    45c2:	f7ff ffaf 	bl	4524 <vPortInitTickTimer>
  vPortStartTickTimer(); /* start tick timer */
    45c6:	f7ff ffcd 	bl	4564 <vPortStartTickTimer>
#if configCPU_FAMILY==configCPU_FAMILY_ARM_M4F /* floating point unit */
  vPortEnableVFP(); /* Ensure the VFP is enabled - it should be anyway */
    45ca:	f7ff ffe3 	bl	4594 <vPortEnableVFP>
  *(portFPCCR) |= portASPEN_AND_LSPEN_BITS; /* Lazy register save always */
    45ce:	4b0b      	ldr	r3, [pc, #44]	; (45fc <xPortStartScheduler+0x50>)
    45d0:	4a0a      	ldr	r2, [pc, #40]	; (45fc <xPortStartScheduler+0x50>)
    45d2:	6812      	ldr	r2, [r2, #0]
    45d4:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    45d8:	601a      	str	r2, [r3, #0]
#endif
#if configUSE_TASK_END_SCHEDULER
    if(setjmp(xJumpBuf) != 0 ) {
    45da:	4809      	ldr	r0, [pc, #36]	; (4600 <xPortStartScheduler+0x54>)
    45dc:	f002 fdd2 	bl	7184 <setjmp>
    45e0:	4603      	mov	r3, r0
    45e2:	2b00      	cmp	r3, #0
    45e4:	d001      	beq.n	45ea <xPortStartScheduler+0x3e>
      /* here we will get in case of call to vTaskEndScheduler() */
      return pdFALSE;
    45e6:	2300      	movs	r3, #0
    45e8:	e002      	b.n	45f0 <xPortStartScheduler+0x44>
    }
#endif
  vPortStartFirstTask(); /* Start the first task. */
    45ea:	f000 f873 	bl	46d4 <vPortStartFirstTask>
  /* Should not get here, unless you call vTaskEndScheduler()! */
  return pdFALSE;
    45ee:	2300      	movs	r3, #0
}
    45f0:	4618      	mov	r0, r3
    45f2:	bd80      	pop	{r7, pc}
    45f4:	e000ed20 	.word	0xe000ed20
    45f8:	20000004 	.word	0x20000004
    45fc:	e000ef34 	.word	0xe000ef34
    4600:	20000128 	.word	0x20000128

00004604 <vPortEndScheduler>:
/*-----------------------------------------------------------*/
void vPortEndScheduler(void) {
    4604:	b580      	push	{r7, lr}
    4606:	af00      	add	r7, sp, #0
  vPortStopTickTimer();
    4608:	f7ff ffb8 	bl	457c <vPortStopTickTimer>
  /* Jump back to the processor state prior to starting the
     scheduler.  This means we are not going to be using a
     task stack frame so the task can be deleted. */
#if configUSE_TASK_END_SCHEDULER
  longjmp(xJumpBuf, 1);
    460c:	4801      	ldr	r0, [pc, #4]	; (4614 <vPortEndScheduler+0x10>)
    460e:	2101      	movs	r1, #1
    4610:	f002 fdbe 	bl	7190 <longjmp>
    4614:	20000128 	.word	0x20000128

00004618 <vPortEnterCritical>:
#else
  for(;;){} /* wait here */
#endif
}
/*-----------------------------------------------------------*/
void vPortEnterCritical(void) {
    4618:	b480      	push	{r7}
    461a:	af00      	add	r7, sp, #0
 * Disable interrupts before incrementing the count of critical section nesting.
 * The nesting count is maintained so we know when interrupts should be
 * re-enabled.  Once interrupts are disabled the nesting count can be accessed
 * directly.  Each task maintains its own nesting count.
 */
  portDISABLE_INTERRUPTS();
    461c:	f04f 0050 	mov.w	r0, #80	; 0x50
    4620:	f380 8811 	msr	BASEPRI, r0
  portPOST_ENABLE_DISABLE_INTERRUPTS();
  uxCriticalNesting++;
    4624:	4b06      	ldr	r3, [pc, #24]	; (4640 <vPortEnterCritical+0x28>)
    4626:	681b      	ldr	r3, [r3, #0]
    4628:	1c5a      	adds	r2, r3, #1
    462a:	4b05      	ldr	r3, [pc, #20]	; (4640 <vPortEnterCritical+0x28>)
    462c:	601a      	str	r2, [r3, #0]
  __asm volatile("dsb");
    462e:	f3bf 8f4f 	dsb	sy
  __asm volatile("isb");
    4632:	f3bf 8f6f 	isb	sy
}
    4636:	46bd      	mov	sp, r7
    4638:	f85d 7b04 	ldr.w	r7, [sp], #4
    463c:	4770      	bx	lr
    463e:	bf00      	nop
    4640:	20000004 	.word	0x20000004

00004644 <vPortExitCritical>:
/*-----------------------------------------------------------*/
void vPortExitCritical(void) {
    4644:	b480      	push	{r7}
    4646:	af00      	add	r7, sp, #0
 /* Interrupts are disabled so we can access the nesting count directly.  If the
  * nesting is found to be 0 (no nesting) then we are leaving the critical
  * section and interrupts can be re-enabled.
  */
  uxCriticalNesting--;
    4648:	4b08      	ldr	r3, [pc, #32]	; (466c <vPortExitCritical+0x28>)
    464a:	681b      	ldr	r3, [r3, #0]
    464c:	1e5a      	subs	r2, r3, #1
    464e:	4b07      	ldr	r3, [pc, #28]	; (466c <vPortExitCritical+0x28>)
    4650:	601a      	str	r2, [r3, #0]
  if (uxCriticalNesting == 0)  {
    4652:	4b06      	ldr	r3, [pc, #24]	; (466c <vPortExitCritical+0x28>)
    4654:	681b      	ldr	r3, [r3, #0]
    4656:	2b00      	cmp	r3, #0
    4658:	d103      	bne.n	4662 <vPortExitCritical+0x1e>
    portENABLE_INTERRUPTS();
    465a:	f04f 0000 	mov.w	r0, #0
    465e:	f380 8811 	msr	BASEPRI, r0
    portPOST_ENABLE_DISABLE_INTERRUPTS();
  }
}
    4662:	46bd      	mov	sp, r7
    4664:	f85d 7b04 	ldr.w	r7, [sp], #4
    4668:	4770      	bx	lr
    466a:	bf00      	nop
    466c:	20000004 	.word	0x20000004

00004670 <vPortYieldFromISR>:
/*-----------------------------------------------------------*/
void vPortYieldFromISR(void) {
    4670:	b480      	push	{r7}
    4672:	af00      	add	r7, sp, #0
  /* Set a PendSV to request a context switch. */
  *(portNVIC_INT_CTRL) = portNVIC_PENDSVSET_BIT;
    4674:	4b05      	ldr	r3, [pc, #20]	; (468c <vPortYieldFromISR+0x1c>)
    4676:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    467a:	601a      	str	r2, [r3, #0]
  /* Barriers are normally not required but do ensure the code is completely
  within the specified behavior for the architecture. */
  __asm volatile("dsb");
    467c:	f3bf 8f4f 	dsb	sy
  __asm volatile("isb");
    4680:	f3bf 8f6f 	isb	sy
}
    4684:	46bd      	mov	sp, r7
    4686:	f85d 7b04 	ldr.w	r7, [sp], #4
    468a:	4770      	bx	lr
    468c:	e000ed04 	.word	0xe000ed04

00004690 <uxGetTickCounterValue>:
/*-----------------------------------------------------------*/
/* return the tick raw counter value. It is assumed that the counter register has been reset at the last tick time */
portLONG uxGetTickCounterValue(void) {
    4690:	b480      	push	{r7}
    4692:	b083      	sub	sp, #12
    4694:	af00      	add	r7, sp, #0
  portLONG val;
  
  GET_TICK_CURRENT_VAL(&val);
    4696:	4b05      	ldr	r3, [pc, #20]	; (46ac <uxGetTickCounterValue+0x1c>)
    4698:	681b      	ldr	r3, [r3, #0]
    469a:	607b      	str	r3, [r7, #4]
  return val;
    469c:	687b      	ldr	r3, [r7, #4]
}
    469e:	4618      	mov	r0, r3
    46a0:	370c      	adds	r7, #12
    46a2:	46bd      	mov	sp, r7
    46a4:	f85d 7b04 	ldr.w	r7, [sp], #4
    46a8:	4770      	bx	lr
    46aa:	bf00      	nop
    46ac:	e000e018 	.word	0xe000e018

000046b0 <vPortTickHandler>:
/*-----------------------------------------------------------*/
#if (configCOMPILER==configCOMPILER_ARM_GCC)
#if configPEX_KINETIS_SDK /* the SDK expects different interrupt handler names */
void SysTick_Handler(void) {
#else
void vPortTickHandler(void) {
    46b0:	b580      	push	{r7, lr}
    46b2:	af00      	add	r7, sp, #0
  SEGGER_SYSVIEW_TickCnt++; /* tick counter for Segger SystemViewer */
#endif
#if configUSE_TICKLESS_IDLE == 1
  TICK_INTERRUPT_FLAG_SET();
#endif
  portSET_INTERRUPT_MASK();   /* disable interrupts */
    46b4:	f04f 0050 	mov.w	r0, #80	; 0x50
    46b8:	f380 8811 	msr	BASEPRI, r0
      ENABLE_TICK_COUNTER();
    }
    restoreTickInterval -= 1;
  }
#endif
  if (xTaskIncrementTick()!=pdFALSE) { /* increment tick count */
    46bc:	f7fd fefa 	bl	24b4 <xTaskIncrementTick>
    46c0:	4603      	mov	r3, r0
    46c2:	2b00      	cmp	r3, #0
    46c4:	d001      	beq.n	46ca <vPortTickHandler+0x1a>
    taskYIELD();
    46c6:	f7ff ffd3 	bl	4670 <vPortYieldFromISR>
  }
  portCLEAR_INTERRUPT_MASK(); /* enable interrupts again */
    46ca:	f04f 0000 	mov.w	r0, #0
    46ce:	f380 8811 	msr	BASEPRI, r0
}
    46d2:	bd80      	pop	{r7, pc}

000046d4 <vPortStartFirstTask>:
  nop
}
#endif
/*-----------------------------------------------------------*/
#if (configCOMPILER==configCOMPILER_ARM_GCC)
void vPortStartFirstTask(void) {
    46d4:	b480      	push	{r7}
    46d6:	af00      	add	r7, sp, #0
  __asm volatile (
    46d8:	4821      	ldr	r0, [pc, #132]	; (4760 <pxCurrentTCBConst+0x8>)
    46da:	6800      	ldr	r0, [r0, #0]
    46dc:	6800      	ldr	r0, [r0, #0]
    46de:	f380 8808 	msr	MSP, r0
    46e2:	b662      	cpsie	i
    46e4:	df00      	svc	0
    46e6:	bf00      	nop
    " msr msp, r0         \n" /* Set the msp back to the start of the stack. */
    " cpsie i             \n" /* Globally enable interrupts. */
    " svc 0               \n" /* System call to start first task. */
    " nop                 \n"
  );
}
    46e8:	46bd      	mov	sp, r7
    46ea:	f85d 7b04 	ldr.w	r7, [sp], #4
    46ee:	4770      	bx	lr

000046f0 <vPortSVCHandler>:
__attribute__ ((naked)) void SVC_Handler(void) {
#else
__attribute__ ((naked)) void vPortSVCHandler(void) {
#endif
#if configCPU_FAMILY_IS_ARM_M4(configCPU_FAMILY) /* Cortex M4 */
__asm volatile (
    46f0:	4b05      	ldr	r3, [pc, #20]	; (4708 <pxCurrentTCBConst2>)
    46f2:	6819      	ldr	r1, [r3, #0]
    46f4:	6808      	ldr	r0, [r1, #0]
    46f6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    46fa:	f380 8809 	msr	PSP, r0
    46fe:	f04f 0000 	mov.w	r0, #0
    4702:	f380 8811 	msr	BASEPRI, r0
    4706:	4770      	bx	lr

00004708 <pxCurrentTCBConst2>:
    4708:	20000028 	.word	0x20000028

0000470c <vPortPendSVHandler>:
__attribute__ ((naked)) void PendSV_Handler(void) {
#else
__attribute__ ((naked)) void vPortPendSVHandler(void) {
#endif
#if configCPU_FAMILY_IS_ARM_M4(configCPU_FAMILY) /* Cortex M4 */
  __asm volatile (
    470c:	f3ef 8009 	mrs	r0, PSP
    4710:	4b11      	ldr	r3, [pc, #68]	; (4758 <pxCurrentTCBConst>)
    4712:	681a      	ldr	r2, [r3, #0]
    4714:	f01e 0f10 	tst.w	lr, #16
    4718:	bf08      	it	eq
    471a:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    471e:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4722:	6010      	str	r0, [r2, #0]
    4724:	e92d 4008 	stmdb	sp!, {r3, lr}
    4728:	f04f 0050 	mov.w	r0, #80	; 0x50
    472c:	f380 8811 	msr	BASEPRI, r0
    4730:	f7fd ff82 	bl	2638 <vTaskSwitchContext>
    4734:	f04f 0000 	mov.w	r0, #0
    4738:	f380 8811 	msr	BASEPRI, r0
    473c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    4740:	6819      	ldr	r1, [r3, #0]
    4742:	6808      	ldr	r0, [r1, #0]
    4744:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4748:	f01e 0f10 	tst.w	lr, #16
    474c:	bf08      	it	eq
    474e:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    4752:	f380 8809 	msr	PSP, r0
    4756:	4770      	bx	lr

00004758 <pxCurrentTCBConst>:
    4758:	20000028 	.word	0x20000028
    475c:	e000ed88 	.word	0xe000ed88
    4760:	e000ed08 	.word	0xe000ed08

00004764 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    4764:	b480      	push	{r7}
    4766:	b083      	sub	sp, #12
    4768:	af00      	add	r7, sp, #0
    476a:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    476c:	687b      	ldr	r3, [r7, #4]
    476e:	f103 0208 	add.w	r2, r3, #8
    4772:	687b      	ldr	r3, [r7, #4]
    4774:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4776:	687b      	ldr	r3, [r7, #4]
    4778:	f04f 32ff 	mov.w	r2, #4294967295
    477c:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    477e:	687b      	ldr	r3, [r7, #4]
    4780:	f103 0208 	add.w	r2, r3, #8
    4784:	687b      	ldr	r3, [r7, #4]
    4786:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4788:	687b      	ldr	r3, [r7, #4]
    478a:	f103 0208 	add.w	r2, r3, #8
    478e:	687b      	ldr	r3, [r7, #4]
    4790:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    4792:	687b      	ldr	r3, [r7, #4]
    4794:	2200      	movs	r2, #0
    4796:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    4798:	370c      	adds	r7, #12
    479a:	46bd      	mov	sp, r7
    479c:	f85d 7b04 	ldr.w	r7, [sp], #4
    47a0:	4770      	bx	lr
    47a2:	bf00      	nop

000047a4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    47a4:	b480      	push	{r7}
    47a6:	b083      	sub	sp, #12
    47a8:	af00      	add	r7, sp, #0
    47aa:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    47ac:	687b      	ldr	r3, [r7, #4]
    47ae:	2200      	movs	r2, #0
    47b0:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    47b2:	370c      	adds	r7, #12
    47b4:	46bd      	mov	sp, r7
    47b6:	f85d 7b04 	ldr.w	r7, [sp], #4
    47ba:	4770      	bx	lr

000047bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    47bc:	b480      	push	{r7}
    47be:	b085      	sub	sp, #20
    47c0:	af00      	add	r7, sp, #0
    47c2:	6078      	str	r0, [r7, #4]
    47c4:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
    47c6:	687b      	ldr	r3, [r7, #4]
    47c8:	685b      	ldr	r3, [r3, #4]
    47ca:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    47cc:	683b      	ldr	r3, [r7, #0]
    47ce:	68fa      	ldr	r2, [r7, #12]
    47d0:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    47d2:	68fb      	ldr	r3, [r7, #12]
    47d4:	689a      	ldr	r2, [r3, #8]
    47d6:	683b      	ldr	r3, [r7, #0]
    47d8:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    47da:	68fb      	ldr	r3, [r7, #12]
    47dc:	689b      	ldr	r3, [r3, #8]
    47de:	683a      	ldr	r2, [r7, #0]
    47e0:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
    47e2:	68fb      	ldr	r3, [r7, #12]
    47e4:	683a      	ldr	r2, [r7, #0]
    47e6:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    47e8:	683b      	ldr	r3, [r7, #0]
    47ea:	687a      	ldr	r2, [r7, #4]
    47ec:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    47ee:	687b      	ldr	r3, [r7, #4]
    47f0:	681b      	ldr	r3, [r3, #0]
    47f2:	1c5a      	adds	r2, r3, #1
    47f4:	687b      	ldr	r3, [r7, #4]
    47f6:	601a      	str	r2, [r3, #0]
}
    47f8:	3714      	adds	r7, #20
    47fa:	46bd      	mov	sp, r7
    47fc:	f85d 7b04 	ldr.w	r7, [sp], #4
    4800:	4770      	bx	lr
    4802:	bf00      	nop

00004804 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    4804:	b480      	push	{r7}
    4806:	b085      	sub	sp, #20
    4808:	af00      	add	r7, sp, #0
    480a:	6078      	str	r0, [r7, #4]
    480c:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    480e:	683b      	ldr	r3, [r7, #0]
    4810:	681b      	ldr	r3, [r3, #0]
    4812:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4814:	68bb      	ldr	r3, [r7, #8]
    4816:	f1b3 3fff 	cmp.w	r3, #4294967295
    481a:	d103      	bne.n	4824 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    481c:	687b      	ldr	r3, [r7, #4]
    481e:	691b      	ldr	r3, [r3, #16]
    4820:	60fb      	str	r3, [r7, #12]
    4822:	e00c      	b.n	483e <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4824:	687b      	ldr	r3, [r7, #4]
    4826:	3308      	adds	r3, #8
    4828:	60fb      	str	r3, [r7, #12]
    482a:	e002      	b.n	4832 <vListInsert+0x2e>
    482c:	68fb      	ldr	r3, [r7, #12]
    482e:	685b      	ldr	r3, [r3, #4]
    4830:	60fb      	str	r3, [r7, #12]
    4832:	68fb      	ldr	r3, [r7, #12]
    4834:	685b      	ldr	r3, [r3, #4]
    4836:	681a      	ldr	r2, [r3, #0]
    4838:	68bb      	ldr	r3, [r7, #8]
    483a:	429a      	cmp	r2, r3
    483c:	d9f6      	bls.n	482c <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    483e:	68fb      	ldr	r3, [r7, #12]
    4840:	685a      	ldr	r2, [r3, #4]
    4842:	683b      	ldr	r3, [r7, #0]
    4844:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    4846:	683b      	ldr	r3, [r7, #0]
    4848:	685b      	ldr	r3, [r3, #4]
    484a:	683a      	ldr	r2, [r7, #0]
    484c:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
    484e:	683b      	ldr	r3, [r7, #0]
    4850:	68fa      	ldr	r2, [r7, #12]
    4852:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
    4854:	68fb      	ldr	r3, [r7, #12]
    4856:	683a      	ldr	r2, [r7, #0]
    4858:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    485a:	683b      	ldr	r3, [r7, #0]
    485c:	687a      	ldr	r2, [r7, #4]
    485e:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
    4860:	687b      	ldr	r3, [r7, #4]
    4862:	681b      	ldr	r3, [r3, #0]
    4864:	1c5a      	adds	r2, r3, #1
    4866:	687b      	ldr	r3, [r7, #4]
    4868:	601a      	str	r2, [r3, #0]
}
    486a:	3714      	adds	r7, #20
    486c:	46bd      	mov	sp, r7
    486e:	f85d 7b04 	ldr.w	r7, [sp], #4
    4872:	4770      	bx	lr

00004874 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    4874:	b480      	push	{r7}
    4876:	b085      	sub	sp, #20
    4878:	af00      	add	r7, sp, #0
    487a:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    487c:	687b      	ldr	r3, [r7, #4]
    487e:	691b      	ldr	r3, [r3, #16]
    4880:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4882:	687b      	ldr	r3, [r7, #4]
    4884:	685b      	ldr	r3, [r3, #4]
    4886:	687a      	ldr	r2, [r7, #4]
    4888:	6892      	ldr	r2, [r2, #8]
    488a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    488c:	687b      	ldr	r3, [r7, #4]
    488e:	689b      	ldr	r3, [r3, #8]
    4890:	687a      	ldr	r2, [r7, #4]
    4892:	6852      	ldr	r2, [r2, #4]
    4894:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    4896:	68fb      	ldr	r3, [r7, #12]
    4898:	685a      	ldr	r2, [r3, #4]
    489a:	687b      	ldr	r3, [r7, #4]
    489c:	429a      	cmp	r2, r3
    489e:	d103      	bne.n	48a8 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    48a0:	687b      	ldr	r3, [r7, #4]
    48a2:	689a      	ldr	r2, [r3, #8]
    48a4:	68fb      	ldr	r3, [r7, #12]
    48a6:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    48a8:	687b      	ldr	r3, [r7, #4]
    48aa:	2200      	movs	r2, #0
    48ac:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
    48ae:	68fb      	ldr	r3, [r7, #12]
    48b0:	681b      	ldr	r3, [r3, #0]
    48b2:	1e5a      	subs	r2, r3, #1
    48b4:	68fb      	ldr	r3, [r7, #12]
    48b6:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    48b8:	68fb      	ldr	r3, [r7, #12]
    48ba:	681b      	ldr	r3, [r3, #0]
}
    48bc:	4618      	mov	r0, r3
    48be:	3714      	adds	r7, #20
    48c0:	46bd      	mov	sp, r7
    48c2:	f85d 7b04 	ldr.w	r7, [sp], #4
    48c6:	4770      	bx	lr

000048c8 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    48c8:	b580      	push	{r7, lr}
    48ca:	b086      	sub	sp, #24
    48cc:	af00      	add	r7, sp, #0
    48ce:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    48d0:	2300      	movs	r3, #0
    48d2:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
    48d4:	f7fd fc80 	bl	21d8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    48d8:	4b52      	ldr	r3, [pc, #328]	; (4a24 <pvPortMalloc+0x15c>)
    48da:	681b      	ldr	r3, [r3, #0]
    48dc:	2b00      	cmp	r3, #0
    48de:	d101      	bne.n	48e4 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
    48e0:	f000 f916 	bl	4b10 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    48e4:	4b50      	ldr	r3, [pc, #320]	; (4a28 <pvPortMalloc+0x160>)
    48e6:	681a      	ldr	r2, [r3, #0]
    48e8:	687b      	ldr	r3, [r7, #4]
    48ea:	4013      	ands	r3, r2
    48ec:	2b00      	cmp	r3, #0
    48ee:	f040 8082 	bne.w	49f6 <pvPortMalloc+0x12e>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    48f2:	687b      	ldr	r3, [r7, #4]
    48f4:	2b00      	cmp	r3, #0
    48f6:	d017      	beq.n	4928 <pvPortMalloc+0x60>
			{
				xWantedSize += xHeapStructSize;
    48f8:	2308      	movs	r3, #8
    48fa:	687a      	ldr	r2, [r7, #4]
    48fc:	4413      	add	r3, r2
    48fe:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    4900:	687b      	ldr	r3, [r7, #4]
    4902:	f003 0307 	and.w	r3, r3, #7
    4906:	2b00      	cmp	r3, #0
    4908:	d00e      	beq.n	4928 <pvPortMalloc+0x60>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    490a:	687b      	ldr	r3, [r7, #4]
    490c:	f023 0307 	bic.w	r3, r3, #7
    4910:	3308      	adds	r3, #8
    4912:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
    4914:	687b      	ldr	r3, [r7, #4]
    4916:	f003 0307 	and.w	r3, r3, #7
    491a:	2b00      	cmp	r3, #0
    491c:	d004      	beq.n	4928 <pvPortMalloc+0x60>
    491e:	f04f 0050 	mov.w	r0, #80	; 0x50
    4922:	f380 8811 	msr	BASEPRI, r0
    4926:	e7fe      	b.n	4926 <pvPortMalloc+0x5e>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    4928:	687b      	ldr	r3, [r7, #4]
    492a:	2b00      	cmp	r3, #0
    492c:	d063      	beq.n	49f6 <pvPortMalloc+0x12e>
    492e:	4b3f      	ldr	r3, [pc, #252]	; (4a2c <pvPortMalloc+0x164>)
    4930:	681b      	ldr	r3, [r3, #0]
    4932:	687a      	ldr	r2, [r7, #4]
    4934:	429a      	cmp	r2, r3
    4936:	d85e      	bhi.n	49f6 <pvPortMalloc+0x12e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    4938:	4b3d      	ldr	r3, [pc, #244]	; (4a30 <pvPortMalloc+0x168>)
    493a:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
    493c:	4b3c      	ldr	r3, [pc, #240]	; (4a30 <pvPortMalloc+0x168>)
    493e:	681b      	ldr	r3, [r3, #0]
    4940:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    4942:	e004      	b.n	494e <pvPortMalloc+0x86>
				{
					pxPreviousBlock = pxBlock;
    4944:	697b      	ldr	r3, [r7, #20]
    4946:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
    4948:	697b      	ldr	r3, [r7, #20]
    494a:	681b      	ldr	r3, [r3, #0]
    494c:	617b      	str	r3, [r7, #20]
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    494e:	697b      	ldr	r3, [r7, #20]
    4950:	685a      	ldr	r2, [r3, #4]
    4952:	687b      	ldr	r3, [r7, #4]
    4954:	429a      	cmp	r2, r3
    4956:	d203      	bcs.n	4960 <pvPortMalloc+0x98>
    4958:	697b      	ldr	r3, [r7, #20]
    495a:	681b      	ldr	r3, [r3, #0]
    495c:	2b00      	cmp	r3, #0
    495e:	d1f1      	bne.n	4944 <pvPortMalloc+0x7c>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    4960:	4b30      	ldr	r3, [pc, #192]	; (4a24 <pvPortMalloc+0x15c>)
    4962:	681b      	ldr	r3, [r3, #0]
    4964:	697a      	ldr	r2, [r7, #20]
    4966:	429a      	cmp	r2, r3
    4968:	d045      	beq.n	49f6 <pvPortMalloc+0x12e>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    496a:	693b      	ldr	r3, [r7, #16]
    496c:	681a      	ldr	r2, [r3, #0]
    496e:	2308      	movs	r3, #8
    4970:	4413      	add	r3, r2
    4972:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    4974:	697b      	ldr	r3, [r7, #20]
    4976:	681a      	ldr	r2, [r3, #0]
    4978:	693b      	ldr	r3, [r7, #16]
    497a:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    497c:	697b      	ldr	r3, [r7, #20]
    497e:	685a      	ldr	r2, [r3, #4]
    4980:	687b      	ldr	r3, [r7, #4]
    4982:	1ad2      	subs	r2, r2, r3
    4984:	2308      	movs	r3, #8
    4986:	005b      	lsls	r3, r3, #1
    4988:	429a      	cmp	r2, r3
    498a:	d919      	bls.n	49c0 <pvPortMalloc+0xf8>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    498c:	697a      	ldr	r2, [r7, #20]
    498e:	687b      	ldr	r3, [r7, #4]
    4990:	4413      	add	r3, r2
    4992:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    4994:	68bb      	ldr	r3, [r7, #8]
    4996:	f003 0307 	and.w	r3, r3, #7
    499a:	2b00      	cmp	r3, #0
    499c:	d004      	beq.n	49a8 <pvPortMalloc+0xe0>
    499e:	f04f 0050 	mov.w	r0, #80	; 0x50
    49a2:	f380 8811 	msr	BASEPRI, r0
    49a6:	e7fe      	b.n	49a6 <pvPortMalloc+0xde>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    49a8:	697b      	ldr	r3, [r7, #20]
    49aa:	685a      	ldr	r2, [r3, #4]
    49ac:	687b      	ldr	r3, [r7, #4]
    49ae:	1ad2      	subs	r2, r2, r3
    49b0:	68bb      	ldr	r3, [r7, #8]
    49b2:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
    49b4:	697b      	ldr	r3, [r7, #20]
    49b6:	687a      	ldr	r2, [r7, #4]
    49b8:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    49ba:	68b8      	ldr	r0, [r7, #8]
    49bc:	f000 f90a 	bl	4bd4 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    49c0:	4b1a      	ldr	r3, [pc, #104]	; (4a2c <pvPortMalloc+0x164>)
    49c2:	681a      	ldr	r2, [r3, #0]
    49c4:	697b      	ldr	r3, [r7, #20]
    49c6:	685b      	ldr	r3, [r3, #4]
    49c8:	1ad2      	subs	r2, r2, r3
    49ca:	4b18      	ldr	r3, [pc, #96]	; (4a2c <pvPortMalloc+0x164>)
    49cc:	601a      	str	r2, [r3, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    49ce:	4b17      	ldr	r3, [pc, #92]	; (4a2c <pvPortMalloc+0x164>)
    49d0:	681a      	ldr	r2, [r3, #0]
    49d2:	4b18      	ldr	r3, [pc, #96]	; (4a34 <pvPortMalloc+0x16c>)
    49d4:	681b      	ldr	r3, [r3, #0]
    49d6:	429a      	cmp	r2, r3
    49d8:	d203      	bcs.n	49e2 <pvPortMalloc+0x11a>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    49da:	4b14      	ldr	r3, [pc, #80]	; (4a2c <pvPortMalloc+0x164>)
    49dc:	681a      	ldr	r2, [r3, #0]
    49de:	4b15      	ldr	r3, [pc, #84]	; (4a34 <pvPortMalloc+0x16c>)
    49e0:	601a      	str	r2, [r3, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    49e2:	697b      	ldr	r3, [r7, #20]
    49e4:	685a      	ldr	r2, [r3, #4]
    49e6:	4b10      	ldr	r3, [pc, #64]	; (4a28 <pvPortMalloc+0x160>)
    49e8:	681b      	ldr	r3, [r3, #0]
    49ea:	431a      	orrs	r2, r3
    49ec:	697b      	ldr	r3, [r7, #20]
    49ee:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
    49f0:	697b      	ldr	r3, [r7, #20]
    49f2:	2200      	movs	r2, #0
    49f4:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    49f6:	f7fd fbfd 	bl	21f4 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    49fa:	68fb      	ldr	r3, [r7, #12]
    49fc:	2b00      	cmp	r3, #0
    49fe:	d101      	bne.n	4a04 <pvPortMalloc+0x13c>
		{
      FRTOS1_vApplicationMallocFailedHook();
    4a00:	f7fc fed4 	bl	17ac <FRTOS1_vApplicationMallocFailedHook>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    4a04:	68fb      	ldr	r3, [r7, #12]
    4a06:	f003 0307 	and.w	r3, r3, #7
    4a0a:	2b00      	cmp	r3, #0
    4a0c:	d004      	beq.n	4a18 <pvPortMalloc+0x150>
    4a0e:	f04f 0050 	mov.w	r0, #80	; 0x50
    4a12:	f380 8811 	msr	BASEPRI, r0
    4a16:	e7fe      	b.n	4a16 <pvPortMalloc+0x14e>
	return pvReturn;
    4a18:	68fb      	ldr	r3, [r7, #12]
}
    4a1a:	4618      	mov	r0, r3
    4a1c:	3718      	adds	r7, #24
    4a1e:	46bd      	mov	sp, r7
    4a20:	bd80      	pop	{r7, pc}
    4a22:	bf00      	nop
    4a24:	2000118c 	.word	0x2000118c
    4a28:	20001198 	.word	0x20001198
    4a2c:	20001190 	.word	0x20001190
    4a30:	20001184 	.word	0x20001184
    4a34:	20001194 	.word	0x20001194

00004a38 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4a38:	b580      	push	{r7, lr}
    4a3a:	b084      	sub	sp, #16
    4a3c:	af00      	add	r7, sp, #0
    4a3e:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
    4a40:	687b      	ldr	r3, [r7, #4]
    4a42:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
    4a44:	687b      	ldr	r3, [r7, #4]
    4a46:	2b00      	cmp	r3, #0
    4a48:	d03c      	beq.n	4ac4 <vPortFree+0x8c>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    4a4a:	2308      	movs	r3, #8
    4a4c:	425b      	negs	r3, r3
    4a4e:	68fa      	ldr	r2, [r7, #12]
    4a50:	4413      	add	r3, r2
    4a52:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
    4a54:	68fb      	ldr	r3, [r7, #12]
    4a56:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    4a58:	68bb      	ldr	r3, [r7, #8]
    4a5a:	685a      	ldr	r2, [r3, #4]
    4a5c:	4b1b      	ldr	r3, [pc, #108]	; (4acc <vPortFree+0x94>)
    4a5e:	681b      	ldr	r3, [r3, #0]
    4a60:	4013      	ands	r3, r2
    4a62:	2b00      	cmp	r3, #0
    4a64:	d104      	bne.n	4a70 <vPortFree+0x38>
    4a66:	f04f 0050 	mov.w	r0, #80	; 0x50
    4a6a:	f380 8811 	msr	BASEPRI, r0
    4a6e:	e7fe      	b.n	4a6e <vPortFree+0x36>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
    4a70:	68bb      	ldr	r3, [r7, #8]
    4a72:	681b      	ldr	r3, [r3, #0]
    4a74:	2b00      	cmp	r3, #0
    4a76:	d004      	beq.n	4a82 <vPortFree+0x4a>
    4a78:	f04f 0050 	mov.w	r0, #80	; 0x50
    4a7c:	f380 8811 	msr	BASEPRI, r0
    4a80:	e7fe      	b.n	4a80 <vPortFree+0x48>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    4a82:	68bb      	ldr	r3, [r7, #8]
    4a84:	685a      	ldr	r2, [r3, #4]
    4a86:	4b11      	ldr	r3, [pc, #68]	; (4acc <vPortFree+0x94>)
    4a88:	681b      	ldr	r3, [r3, #0]
    4a8a:	4013      	ands	r3, r2
    4a8c:	2b00      	cmp	r3, #0
    4a8e:	d019      	beq.n	4ac4 <vPortFree+0x8c>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    4a90:	68bb      	ldr	r3, [r7, #8]
    4a92:	681b      	ldr	r3, [r3, #0]
    4a94:	2b00      	cmp	r3, #0
    4a96:	d115      	bne.n	4ac4 <vPortFree+0x8c>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    4a98:	68bb      	ldr	r3, [r7, #8]
    4a9a:	685a      	ldr	r2, [r3, #4]
    4a9c:	4b0b      	ldr	r3, [pc, #44]	; (4acc <vPortFree+0x94>)
    4a9e:	681b      	ldr	r3, [r3, #0]
    4aa0:	43db      	mvns	r3, r3
    4aa2:	401a      	ands	r2, r3
    4aa4:	68bb      	ldr	r3, [r7, #8]
    4aa6:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
    4aa8:	f7fd fb96 	bl	21d8 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    4aac:	68bb      	ldr	r3, [r7, #8]
    4aae:	685a      	ldr	r2, [r3, #4]
    4ab0:	4b07      	ldr	r3, [pc, #28]	; (4ad0 <vPortFree+0x98>)
    4ab2:	681b      	ldr	r3, [r3, #0]
    4ab4:	441a      	add	r2, r3
    4ab6:	4b06      	ldr	r3, [pc, #24]	; (4ad0 <vPortFree+0x98>)
    4ab8:	601a      	str	r2, [r3, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    4aba:	68b8      	ldr	r0, [r7, #8]
    4abc:	f000 f88a 	bl	4bd4 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
    4ac0:	f7fd fb98 	bl	21f4 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    4ac4:	3710      	adds	r7, #16
    4ac6:	46bd      	mov	sp, r7
    4ac8:	bd80      	pop	{r7, pc}
    4aca:	bf00      	nop
    4acc:	20001198 	.word	0x20001198
    4ad0:	20001190 	.word	0x20001190

00004ad4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    4ad4:	b480      	push	{r7}
    4ad6:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
    4ad8:	4b03      	ldr	r3, [pc, #12]	; (4ae8 <xPortGetFreeHeapSize+0x14>)
    4ada:	681b      	ldr	r3, [r3, #0]
}
    4adc:	4618      	mov	r0, r3
    4ade:	46bd      	mov	sp, r7
    4ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
    4ae4:	4770      	bx	lr
    4ae6:	bf00      	nop
    4ae8:	20001190 	.word	0x20001190

00004aec <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    4aec:	b480      	push	{r7}
    4aee:	af00      	add	r7, sp, #0
	return xMinimumEverFreeBytesRemaining;
    4af0:	4b03      	ldr	r3, [pc, #12]	; (4b00 <xPortGetMinimumEverFreeHeapSize+0x14>)
    4af2:	681b      	ldr	r3, [r3, #0]
}
    4af4:	4618      	mov	r0, r3
    4af6:	46bd      	mov	sp, r7
    4af8:	f85d 7b04 	ldr.w	r7, [sp], #4
    4afc:	4770      	bx	lr
    4afe:	bf00      	nop
    4b00:	20001194 	.word	0x20001194

00004b04 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    4b04:	b480      	push	{r7}
    4b06:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
    4b08:	46bd      	mov	sp, r7
    4b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
    4b0e:	4770      	bx	lr

00004b10 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
    4b10:	b480      	push	{r7}
    4b12:	b085      	sub	sp, #20
    4b14:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    4b16:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    4b1a:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
    4b1c:	4b27      	ldr	r3, [pc, #156]	; (4bbc <prvHeapInit+0xac>)
    4b1e:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    4b20:	68fb      	ldr	r3, [r7, #12]
    4b22:	f003 0307 	and.w	r3, r3, #7
    4b26:	2b00      	cmp	r3, #0
    4b28:	d00c      	beq.n	4b44 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
    4b2a:	68fb      	ldr	r3, [r7, #12]
    4b2c:	3307      	adds	r3, #7
    4b2e:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    4b30:	68fb      	ldr	r3, [r7, #12]
    4b32:	f023 0307 	bic.w	r3, r3, #7
    4b36:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
    4b38:	68ba      	ldr	r2, [r7, #8]
    4b3a:	68fb      	ldr	r3, [r7, #12]
    4b3c:	1ad2      	subs	r2, r2, r3
    4b3e:	4b1f      	ldr	r3, [pc, #124]	; (4bbc <prvHeapInit+0xac>)
    4b40:	4413      	add	r3, r2
    4b42:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
    4b44:	68fb      	ldr	r3, [r7, #12]
    4b46:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    4b48:	4b1d      	ldr	r3, [pc, #116]	; (4bc0 <prvHeapInit+0xb0>)
    4b4a:	687a      	ldr	r2, [r7, #4]
    4b4c:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
    4b4e:	4b1c      	ldr	r3, [pc, #112]	; (4bc0 <prvHeapInit+0xb0>)
    4b50:	2200      	movs	r2, #0
    4b52:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
    4b54:	687a      	ldr	r2, [r7, #4]
    4b56:	68bb      	ldr	r3, [r7, #8]
    4b58:	4413      	add	r3, r2
    4b5a:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
    4b5c:	2308      	movs	r3, #8
    4b5e:	68fa      	ldr	r2, [r7, #12]
    4b60:	1ad3      	subs	r3, r2, r3
    4b62:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    4b64:	68fb      	ldr	r3, [r7, #12]
    4b66:	f023 0307 	bic.w	r3, r3, #7
    4b6a:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
    4b6c:	68fa      	ldr	r2, [r7, #12]
    4b6e:	4b15      	ldr	r3, [pc, #84]	; (4bc4 <prvHeapInit+0xb4>)
    4b70:	601a      	str	r2, [r3, #0]
	pxEnd->xBlockSize = 0;
    4b72:	4b14      	ldr	r3, [pc, #80]	; (4bc4 <prvHeapInit+0xb4>)
    4b74:	681b      	ldr	r3, [r3, #0]
    4b76:	2200      	movs	r2, #0
    4b78:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
    4b7a:	4b12      	ldr	r3, [pc, #72]	; (4bc4 <prvHeapInit+0xb4>)
    4b7c:	681b      	ldr	r3, [r3, #0]
    4b7e:	2200      	movs	r2, #0
    4b80:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    4b82:	687b      	ldr	r3, [r7, #4]
    4b84:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    4b86:	683b      	ldr	r3, [r7, #0]
    4b88:	68fa      	ldr	r2, [r7, #12]
    4b8a:	1ad2      	subs	r2, r2, r3
    4b8c:	683b      	ldr	r3, [r7, #0]
    4b8e:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    4b90:	4b0c      	ldr	r3, [pc, #48]	; (4bc4 <prvHeapInit+0xb4>)
    4b92:	681a      	ldr	r2, [r3, #0]
    4b94:	683b      	ldr	r3, [r7, #0]
    4b96:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    4b98:	683b      	ldr	r3, [r7, #0]
    4b9a:	685a      	ldr	r2, [r3, #4]
    4b9c:	4b0a      	ldr	r3, [pc, #40]	; (4bc8 <prvHeapInit+0xb8>)
    4b9e:	601a      	str	r2, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    4ba0:	683b      	ldr	r3, [r7, #0]
    4ba2:	685a      	ldr	r2, [r3, #4]
    4ba4:	4b09      	ldr	r3, [pc, #36]	; (4bcc <prvHeapInit+0xbc>)
    4ba6:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    4ba8:	4b09      	ldr	r3, [pc, #36]	; (4bd0 <prvHeapInit+0xc0>)
    4baa:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    4bae:	601a      	str	r2, [r3, #0]
}
    4bb0:	3714      	adds	r7, #20
    4bb2:	46bd      	mov	sp, r7
    4bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
    4bb8:	4770      	bx	lr
    4bba:	bf00      	nop
    4bbc:	20000184 	.word	0x20000184
    4bc0:	20001184 	.word	0x20001184
    4bc4:	2000118c 	.word	0x2000118c
    4bc8:	20001194 	.word	0x20001194
    4bcc:	20001190 	.word	0x20001190
    4bd0:	20001198 	.word	0x20001198

00004bd4 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    4bd4:	b480      	push	{r7}
    4bd6:	b085      	sub	sp, #20
    4bd8:	af00      	add	r7, sp, #0
    4bda:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    4bdc:	4b27      	ldr	r3, [pc, #156]	; (4c7c <prvInsertBlockIntoFreeList+0xa8>)
    4bde:	60fb      	str	r3, [r7, #12]
    4be0:	e002      	b.n	4be8 <prvInsertBlockIntoFreeList+0x14>
    4be2:	68fb      	ldr	r3, [r7, #12]
    4be4:	681b      	ldr	r3, [r3, #0]
    4be6:	60fb      	str	r3, [r7, #12]
    4be8:	68fb      	ldr	r3, [r7, #12]
    4bea:	681a      	ldr	r2, [r3, #0]
    4bec:	687b      	ldr	r3, [r7, #4]
    4bee:	429a      	cmp	r2, r3
    4bf0:	d3f7      	bcc.n	4be2 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
    4bf2:	68fb      	ldr	r3, [r7, #12]
    4bf4:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    4bf6:	68fb      	ldr	r3, [r7, #12]
    4bf8:	685b      	ldr	r3, [r3, #4]
    4bfa:	68ba      	ldr	r2, [r7, #8]
    4bfc:	441a      	add	r2, r3
    4bfe:	687b      	ldr	r3, [r7, #4]
    4c00:	429a      	cmp	r2, r3
    4c02:	d108      	bne.n	4c16 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    4c04:	68fb      	ldr	r3, [r7, #12]
    4c06:	685a      	ldr	r2, [r3, #4]
    4c08:	687b      	ldr	r3, [r7, #4]
    4c0a:	685b      	ldr	r3, [r3, #4]
    4c0c:	441a      	add	r2, r3
    4c0e:	68fb      	ldr	r3, [r7, #12]
    4c10:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
    4c12:	68fb      	ldr	r3, [r7, #12]
    4c14:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
    4c16:	687b      	ldr	r3, [r7, #4]
    4c18:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    4c1a:	687b      	ldr	r3, [r7, #4]
    4c1c:	685b      	ldr	r3, [r3, #4]
    4c1e:	68ba      	ldr	r2, [r7, #8]
    4c20:	441a      	add	r2, r3
    4c22:	68fb      	ldr	r3, [r7, #12]
    4c24:	681b      	ldr	r3, [r3, #0]
    4c26:	429a      	cmp	r2, r3
    4c28:	d118      	bne.n	4c5c <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    4c2a:	68fb      	ldr	r3, [r7, #12]
    4c2c:	681a      	ldr	r2, [r3, #0]
    4c2e:	4b14      	ldr	r3, [pc, #80]	; (4c80 <prvInsertBlockIntoFreeList+0xac>)
    4c30:	681b      	ldr	r3, [r3, #0]
    4c32:	429a      	cmp	r2, r3
    4c34:	d00d      	beq.n	4c52 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    4c36:	687b      	ldr	r3, [r7, #4]
    4c38:	685a      	ldr	r2, [r3, #4]
    4c3a:	68fb      	ldr	r3, [r7, #12]
    4c3c:	681b      	ldr	r3, [r3, #0]
    4c3e:	685b      	ldr	r3, [r3, #4]
    4c40:	441a      	add	r2, r3
    4c42:	687b      	ldr	r3, [r7, #4]
    4c44:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    4c46:	68fb      	ldr	r3, [r7, #12]
    4c48:	681b      	ldr	r3, [r3, #0]
    4c4a:	681a      	ldr	r2, [r3, #0]
    4c4c:	687b      	ldr	r3, [r7, #4]
    4c4e:	601a      	str	r2, [r3, #0]
    4c50:	e008      	b.n	4c64 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    4c52:	4b0b      	ldr	r3, [pc, #44]	; (4c80 <prvInsertBlockIntoFreeList+0xac>)
    4c54:	681a      	ldr	r2, [r3, #0]
    4c56:	687b      	ldr	r3, [r7, #4]
    4c58:	601a      	str	r2, [r3, #0]
    4c5a:	e003      	b.n	4c64 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    4c5c:	68fb      	ldr	r3, [r7, #12]
    4c5e:	681a      	ldr	r2, [r3, #0]
    4c60:	687b      	ldr	r3, [r7, #4]
    4c62:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    4c64:	68fa      	ldr	r2, [r7, #12]
    4c66:	687b      	ldr	r3, [r7, #4]
    4c68:	429a      	cmp	r2, r3
    4c6a:	d002      	beq.n	4c72 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    4c6c:	68fb      	ldr	r3, [r7, #12]
    4c6e:	687a      	ldr	r2, [r7, #4]
    4c70:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4c72:	3714      	adds	r7, #20
    4c74:	46bd      	mov	sp, r7
    4c76:	f85d 7b04 	ldr.w	r7, [sp], #4
    4c7a:	4770      	bx	lr
    4c7c:	20001184 	.word	0x20001184
    4c80:	2000118c 	.word	0x2000118c

00004c84 <xEventGroupCreate>:
static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );

/*-----------------------------------------------------------*/

EventGroupHandle_t xEventGroupCreate( void )
{
    4c84:	b580      	push	{r7, lr}
    4c86:	b082      	sub	sp, #8
    4c88:	af00      	add	r7, sp, #0
EventGroup_t *pxEventBits;

	pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
    4c8a:	201c      	movs	r0, #28
    4c8c:	f7ff fe1c 	bl	48c8 <pvPortMalloc>
    4c90:	6078      	str	r0, [r7, #4]
	if( pxEventBits != NULL )
    4c92:	687b      	ldr	r3, [r7, #4]
    4c94:	2b00      	cmp	r3, #0
    4c96:	d007      	beq.n	4ca8 <xEventGroupCreate+0x24>
	{
		pxEventBits->uxEventBits = 0;
    4c98:	687b      	ldr	r3, [r7, #4]
    4c9a:	2200      	movs	r2, #0
    4c9c:	601a      	str	r2, [r3, #0]
		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    4c9e:	687b      	ldr	r3, [r7, #4]
    4ca0:	3304      	adds	r3, #4
    4ca2:	4618      	mov	r0, r3
    4ca4:	f7ff fd5e 	bl	4764 <vListInitialise>
	else
	{
		traceEVENT_GROUP_CREATE_FAILED();
	}

	return ( EventGroupHandle_t ) pxEventBits;
    4ca8:	687b      	ldr	r3, [r7, #4]
}
    4caa:	4618      	mov	r0, r3
    4cac:	3708      	adds	r7, #8
    4cae:	46bd      	mov	sp, r7
    4cb0:	bd80      	pop	{r7, pc}
    4cb2:	bf00      	nop

00004cb4 <xEventGroupSync>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    4cb4:	b580      	push	{r7, lr}
    4cb6:	b08a      	sub	sp, #40	; 0x28
    4cb8:	af00      	add	r7, sp, #0
    4cba:	60f8      	str	r0, [r7, #12]
    4cbc:	60b9      	str	r1, [r7, #8]
    4cbe:	607a      	str	r2, [r7, #4]
    4cc0:	603b      	str	r3, [r7, #0]
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    4cc2:	68fb      	ldr	r3, [r7, #12]
    4cc4:	623b      	str	r3, [r7, #32]
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    4cc6:	2300      	movs	r3, #0
    4cc8:	61fb      	str	r3, [r7, #28]

	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    4cca:	687b      	ldr	r3, [r7, #4]
    4ccc:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
    4cd0:	2b00      	cmp	r3, #0
    4cd2:	d004      	beq.n	4cde <xEventGroupSync+0x2a>
    4cd4:	f04f 0050 	mov.w	r0, #80	; 0x50
    4cd8:	f380 8811 	msr	BASEPRI, r0
    4cdc:	e7fe      	b.n	4cdc <xEventGroupSync+0x28>
	configASSERT( uxBitsToWaitFor != 0 );
    4cde:	687b      	ldr	r3, [r7, #4]
    4ce0:	2b00      	cmp	r3, #0
    4ce2:	d104      	bne.n	4cee <xEventGroupSync+0x3a>
    4ce4:	f04f 0050 	mov.w	r0, #80	; 0x50
    4ce8:	f380 8811 	msr	BASEPRI, r0
    4cec:	e7fe      	b.n	4cec <xEventGroupSync+0x38>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    4cee:	f7fe f8f5 	bl	2edc <xTaskGetSchedulerState>
    4cf2:	4603      	mov	r3, r0
    4cf4:	2b00      	cmp	r3, #0
    4cf6:	d102      	bne.n	4cfe <xEventGroupSync+0x4a>
    4cf8:	683b      	ldr	r3, [r7, #0]
    4cfa:	2b00      	cmp	r3, #0
    4cfc:	d101      	bne.n	4d02 <xEventGroupSync+0x4e>
    4cfe:	2301      	movs	r3, #1
    4d00:	e000      	b.n	4d04 <xEventGroupSync+0x50>
    4d02:	2300      	movs	r3, #0
    4d04:	2b00      	cmp	r3, #0
    4d06:	d104      	bne.n	4d12 <xEventGroupSync+0x5e>
    4d08:	f04f 0050 	mov.w	r0, #80	; 0x50
    4d0c:	f380 8811 	msr	BASEPRI, r0
    4d10:	e7fe      	b.n	4d10 <xEventGroupSync+0x5c>
	}
	#endif

	vTaskSuspendAll();
    4d12:	f7fd fa61 	bl	21d8 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    4d16:	6a3b      	ldr	r3, [r7, #32]
    4d18:	681b      	ldr	r3, [r3, #0]
    4d1a:	61bb      	str	r3, [r7, #24]

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    4d1c:	68f8      	ldr	r0, [r7, #12]
    4d1e:	68b9      	ldr	r1, [r7, #8]
    4d20:	f000 f950 	bl	4fc4 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    4d24:	69ba      	ldr	r2, [r7, #24]
    4d26:	68bb      	ldr	r3, [r7, #8]
    4d28:	431a      	orrs	r2, r3
    4d2a:	687b      	ldr	r3, [r7, #4]
    4d2c:	401a      	ands	r2, r3
    4d2e:	687b      	ldr	r3, [r7, #4]
    4d30:	429a      	cmp	r2, r3
    4d32:	d10d      	bne.n	4d50 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    4d34:	69ba      	ldr	r2, [r7, #24]
    4d36:	68bb      	ldr	r3, [r7, #8]
    4d38:	4313      	orrs	r3, r2
    4d3a:	627b      	str	r3, [r7, #36]	; 0x24

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    4d3c:	6a3b      	ldr	r3, [r7, #32]
    4d3e:	681a      	ldr	r2, [r3, #0]
    4d40:	687b      	ldr	r3, [r7, #4]
    4d42:	43db      	mvns	r3, r3
    4d44:	401a      	ands	r2, r3
    4d46:	6a3b      	ldr	r3, [r7, #32]
    4d48:	601a      	str	r2, [r3, #0]

			xTicksToWait = 0;
    4d4a:	2300      	movs	r3, #0
    4d4c:	603b      	str	r3, [r7, #0]
    4d4e:	e012      	b.n	4d76 <xEventGroupSync+0xc2>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    4d50:	683b      	ldr	r3, [r7, #0]
    4d52:	2b00      	cmp	r3, #0
    4d54:	d00c      	beq.n	4d70 <xEventGroupSync+0xbc>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    4d56:	6a3b      	ldr	r3, [r7, #32]
    4d58:	1d1a      	adds	r2, r3, #4
    4d5a:	687b      	ldr	r3, [r7, #4]
    4d5c:	f043 63a0 	orr.w	r3, r3, #83886080	; 0x5000000
    4d60:	4610      	mov	r0, r2
    4d62:	4619      	mov	r1, r3
    4d64:	683a      	ldr	r2, [r7, #0]
    4d66:	f7fd fd05 	bl	2774 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    4d6a:	2300      	movs	r3, #0
    4d6c:	627b      	str	r3, [r7, #36]	; 0x24
    4d6e:	e002      	b.n	4d76 <xEventGroupSync+0xc2>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    4d70:	6a3b      	ldr	r3, [r7, #32]
    4d72:	681b      	ldr	r3, [r3, #0]
    4d74:	627b      	str	r3, [r7, #36]	; 0x24
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    4d76:	f7fd fa3d 	bl	21f4 <xTaskResumeAll>
    4d7a:	6178      	str	r0, [r7, #20]

	if( xTicksToWait != ( TickType_t ) 0 )
    4d7c:	683b      	ldr	r3, [r7, #0]
    4d7e:	2b00      	cmp	r3, #0
    4d80:	d026      	beq.n	4dd0 <xEventGroupSync+0x11c>
	{
		if( xAlreadyYielded == pdFALSE )
    4d82:	697b      	ldr	r3, [r7, #20]
    4d84:	2b00      	cmp	r3, #0
    4d86:	d101      	bne.n	4d8c <xEventGroupSync+0xd8>
		{
			portYIELD_WITHIN_API();
    4d88:	f7ff fc72 	bl	4670 <vPortYieldFromISR>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    4d8c:	f7fe fa24 	bl	31d8 <uxTaskResetEventItemValue>
    4d90:	6278      	str	r0, [r7, #36]	; 0x24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    4d92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4d94:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    4d98:	2b00      	cmp	r3, #0
    4d9a:	d115      	bne.n	4dc8 <xEventGroupSync+0x114>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    4d9c:	f7ff fc3c 	bl	4618 <vPortEnterCritical>
			{
				uxReturn = pxEventBits->uxEventBits;
    4da0:	6a3b      	ldr	r3, [r7, #32]
    4da2:	681b      	ldr	r3, [r3, #0]
    4da4:	627b      	str	r3, [r7, #36]	; 0x24

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    4da6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    4da8:	687b      	ldr	r3, [r7, #4]
    4daa:	401a      	ands	r2, r3
    4dac:	687b      	ldr	r3, [r7, #4]
    4dae:	429a      	cmp	r2, r3
    4db0:	d106      	bne.n	4dc0 <xEventGroupSync+0x10c>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    4db2:	6a3b      	ldr	r3, [r7, #32]
    4db4:	681a      	ldr	r2, [r3, #0]
    4db6:	687b      	ldr	r3, [r7, #4]
    4db8:	43db      	mvns	r3, r3
    4dba:	401a      	ands	r2, r3
    4dbc:	6a3b      	ldr	r3, [r7, #32]
    4dbe:	601a      	str	r2, [r3, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4dc0:	f7ff fc40 	bl	4644 <vPortExitCritical>

			xTimeoutOccurred = pdTRUE;
    4dc4:	2301      	movs	r3, #1
    4dc6:	61fb      	str	r3, [r7, #28]
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    4dc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4dca:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4dce:	627b      	str	r3, [r7, #36]	; 0x24
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    4dd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
    4dd2:	4618      	mov	r0, r3
    4dd4:	3728      	adds	r7, #40	; 0x28
    4dd6:	46bd      	mov	sp, r7
    4dd8:	bd80      	pop	{r7, pc}
    4dda:	bf00      	nop

00004ddc <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    4ddc:	b580      	push	{r7, lr}
    4dde:	b08c      	sub	sp, #48	; 0x30
    4de0:	af00      	add	r7, sp, #0
    4de2:	60f8      	str	r0, [r7, #12]
    4de4:	60b9      	str	r1, [r7, #8]
    4de6:	607a      	str	r2, [r7, #4]
    4de8:	603b      	str	r3, [r7, #0]
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    4dea:	68fb      	ldr	r3, [r7, #12]
    4dec:	627b      	str	r3, [r7, #36]	; 0x24
EventBits_t uxReturn, uxControlBits = 0;
    4dee:	2300      	movs	r3, #0
    4df0:	62bb      	str	r3, [r7, #40]	; 0x28
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    4df2:	2300      	movs	r3, #0
    4df4:	623b      	str	r3, [r7, #32]

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
    4df6:	68fb      	ldr	r3, [r7, #12]
    4df8:	2b00      	cmp	r3, #0
    4dfa:	d104      	bne.n	4e06 <xEventGroupWaitBits+0x2a>
    4dfc:	f04f 0050 	mov.w	r0, #80	; 0x50
    4e00:	f380 8811 	msr	BASEPRI, r0
    4e04:	e7fe      	b.n	4e04 <xEventGroupWaitBits+0x28>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    4e06:	68bb      	ldr	r3, [r7, #8]
    4e08:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
    4e0c:	2b00      	cmp	r3, #0
    4e0e:	d004      	beq.n	4e1a <xEventGroupWaitBits+0x3e>
    4e10:	f04f 0050 	mov.w	r0, #80	; 0x50
    4e14:	f380 8811 	msr	BASEPRI, r0
    4e18:	e7fe      	b.n	4e18 <xEventGroupWaitBits+0x3c>
	configASSERT( uxBitsToWaitFor != 0 );
    4e1a:	68bb      	ldr	r3, [r7, #8]
    4e1c:	2b00      	cmp	r3, #0
    4e1e:	d104      	bne.n	4e2a <xEventGroupWaitBits+0x4e>
    4e20:	f04f 0050 	mov.w	r0, #80	; 0x50
    4e24:	f380 8811 	msr	BASEPRI, r0
    4e28:	e7fe      	b.n	4e28 <xEventGroupWaitBits+0x4c>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    4e2a:	f7fe f857 	bl	2edc <xTaskGetSchedulerState>
    4e2e:	4603      	mov	r3, r0
    4e30:	2b00      	cmp	r3, #0
    4e32:	d102      	bne.n	4e3a <xEventGroupWaitBits+0x5e>
    4e34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    4e36:	2b00      	cmp	r3, #0
    4e38:	d101      	bne.n	4e3e <xEventGroupWaitBits+0x62>
    4e3a:	2301      	movs	r3, #1
    4e3c:	e000      	b.n	4e40 <xEventGroupWaitBits+0x64>
    4e3e:	2300      	movs	r3, #0
    4e40:	2b00      	cmp	r3, #0
    4e42:	d104      	bne.n	4e4e <xEventGroupWaitBits+0x72>
    4e44:	f04f 0050 	mov.w	r0, #80	; 0x50
    4e48:	f380 8811 	msr	BASEPRI, r0
    4e4c:	e7fe      	b.n	4e4c <xEventGroupWaitBits+0x70>
	}
	#endif

	vTaskSuspendAll();
    4e4e:	f7fd f9c3 	bl	21d8 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    4e52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4e54:	681b      	ldr	r3, [r3, #0]
    4e56:	61fb      	str	r3, [r7, #28]

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    4e58:	69f8      	ldr	r0, [r7, #28]
    4e5a:	68b9      	ldr	r1, [r7, #8]
    4e5c:	683a      	ldr	r2, [r7, #0]
    4e5e:	f000 f973 	bl	5148 <prvTestWaitCondition>
    4e62:	61b8      	str	r0, [r7, #24]

		if( xWaitConditionMet != pdFALSE )
    4e64:	69bb      	ldr	r3, [r7, #24]
    4e66:	2b00      	cmp	r3, #0
    4e68:	d00e      	beq.n	4e88 <xEventGroupWaitBits+0xac>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    4e6a:	69fb      	ldr	r3, [r7, #28]
    4e6c:	62fb      	str	r3, [r7, #44]	; 0x2c
			xTicksToWait = ( TickType_t ) 0;
    4e6e:	2300      	movs	r3, #0
    4e70:	63bb      	str	r3, [r7, #56]	; 0x38

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    4e72:	687b      	ldr	r3, [r7, #4]
    4e74:	2b00      	cmp	r3, #0
    4e76:	d027      	beq.n	4ec8 <xEventGroupWaitBits+0xec>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    4e78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4e7a:	681a      	ldr	r2, [r3, #0]
    4e7c:	68bb      	ldr	r3, [r7, #8]
    4e7e:	43db      	mvns	r3, r3
    4e80:	401a      	ands	r2, r3
    4e82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4e84:	601a      	str	r2, [r3, #0]
    4e86:	e01f      	b.n	4ec8 <xEventGroupWaitBits+0xec>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    4e88:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    4e8a:	2b00      	cmp	r3, #0
    4e8c:	d102      	bne.n	4e94 <xEventGroupWaitBits+0xb8>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    4e8e:	69fb      	ldr	r3, [r7, #28]
    4e90:	62fb      	str	r3, [r7, #44]	; 0x2c
    4e92:	e019      	b.n	4ec8 <xEventGroupWaitBits+0xec>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    4e94:	687b      	ldr	r3, [r7, #4]
    4e96:	2b00      	cmp	r3, #0
    4e98:	d003      	beq.n	4ea2 <xEventGroupWaitBits+0xc6>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    4e9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4e9c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    4ea0:	62bb      	str	r3, [r7, #40]	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    4ea2:	683b      	ldr	r3, [r7, #0]
    4ea4:	2b00      	cmp	r3, #0
    4ea6:	d003      	beq.n	4eb0 <xEventGroupWaitBits+0xd4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    4ea8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4eaa:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    4eae:	62bb      	str	r3, [r7, #40]	; 0x28
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    4eb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4eb2:	1d1a      	adds	r2, r3, #4
    4eb4:	68b9      	ldr	r1, [r7, #8]
    4eb6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    4eb8:	430b      	orrs	r3, r1
    4eba:	4610      	mov	r0, r2
    4ebc:	4619      	mov	r1, r3
    4ebe:	6bba      	ldr	r2, [r7, #56]	; 0x38
    4ec0:	f7fd fc58 	bl	2774 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    4ec4:	2300      	movs	r3, #0
    4ec6:	62fb      	str	r3, [r7, #44]	; 0x2c

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    4ec8:	f7fd f994 	bl	21f4 <xTaskResumeAll>
    4ecc:	6178      	str	r0, [r7, #20]

	if( xTicksToWait != ( TickType_t ) 0 )
    4ece:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    4ed0:	2b00      	cmp	r3, #0
    4ed2:	d02b      	beq.n	4f2c <xEventGroupWaitBits+0x150>
	{
		if( xAlreadyYielded == pdFALSE )
    4ed4:	697b      	ldr	r3, [r7, #20]
    4ed6:	2b00      	cmp	r3, #0
    4ed8:	d101      	bne.n	4ede <xEventGroupWaitBits+0x102>
		{
			portYIELD_WITHIN_API();
    4eda:	f7ff fbc9 	bl	4670 <vPortYieldFromISR>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    4ede:	f7fe f97b 	bl	31d8 <uxTaskResetEventItemValue>
    4ee2:	62f8      	str	r0, [r7, #44]	; 0x2c

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    4ee4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    4ee6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    4eea:	2b00      	cmp	r3, #0
    4eec:	d11a      	bne.n	4f24 <xEventGroupWaitBits+0x148>
		{
			taskENTER_CRITICAL();
    4eee:	f7ff fb93 	bl	4618 <vPortEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    4ef2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4ef4:	681b      	ldr	r3, [r3, #0]
    4ef6:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    4ef8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    4efa:	68b9      	ldr	r1, [r7, #8]
    4efc:	683a      	ldr	r2, [r7, #0]
    4efe:	f000 f923 	bl	5148 <prvTestWaitCondition>
    4f02:	4603      	mov	r3, r0
    4f04:	2b00      	cmp	r3, #0
    4f06:	d009      	beq.n	4f1c <xEventGroupWaitBits+0x140>
				{
					if( xClearOnExit != pdFALSE )
    4f08:	687b      	ldr	r3, [r7, #4]
    4f0a:	2b00      	cmp	r3, #0
    4f0c:	d006      	beq.n	4f1c <xEventGroupWaitBits+0x140>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    4f0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4f10:	681a      	ldr	r2, [r3, #0]
    4f12:	68bb      	ldr	r3, [r7, #8]
    4f14:	43db      	mvns	r3, r3
    4f16:	401a      	ands	r2, r3
    4f18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    4f1a:	601a      	str	r2, [r3, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4f1c:	f7ff fb92 	bl	4644 <vPortExitCritical>

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
    4f20:	2300      	movs	r3, #0
    4f22:	623b      	str	r3, [r7, #32]
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    4f24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    4f26:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    4f2a:	62fb      	str	r3, [r7, #44]	; 0x2c
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
    4f2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
    4f2e:	4618      	mov	r0, r3
    4f30:	3730      	adds	r7, #48	; 0x30
    4f32:	46bd      	mov	sp, r7
    4f34:	bd80      	pop	{r7, pc}
    4f36:	bf00      	nop

00004f38 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    4f38:	b580      	push	{r7, lr}
    4f3a:	b084      	sub	sp, #16
    4f3c:	af00      	add	r7, sp, #0
    4f3e:	6078      	str	r0, [r7, #4]
    4f40:	6039      	str	r1, [r7, #0]
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    4f42:	687b      	ldr	r3, [r7, #4]
    4f44:	60fb      	str	r3, [r7, #12]
EventBits_t uxReturn;

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
    4f46:	687b      	ldr	r3, [r7, #4]
    4f48:	2b00      	cmp	r3, #0
    4f4a:	d104      	bne.n	4f56 <xEventGroupClearBits+0x1e>
    4f4c:	f04f 0050 	mov.w	r0, #80	; 0x50
    4f50:	f380 8811 	msr	BASEPRI, r0
    4f54:	e7fe      	b.n	4f54 <xEventGroupClearBits+0x1c>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    4f56:	683b      	ldr	r3, [r7, #0]
    4f58:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
    4f5c:	2b00      	cmp	r3, #0
    4f5e:	d004      	beq.n	4f6a <xEventGroupClearBits+0x32>
    4f60:	f04f 0050 	mov.w	r0, #80	; 0x50
    4f64:	f380 8811 	msr	BASEPRI, r0
    4f68:	e7fe      	b.n	4f68 <xEventGroupClearBits+0x30>

	taskENTER_CRITICAL();
    4f6a:	f7ff fb55 	bl	4618 <vPortEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    4f6e:	68fb      	ldr	r3, [r7, #12]
    4f70:	681b      	ldr	r3, [r3, #0]
    4f72:	60bb      	str	r3, [r7, #8]

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    4f74:	68fb      	ldr	r3, [r7, #12]
    4f76:	681a      	ldr	r2, [r3, #0]
    4f78:	683b      	ldr	r3, [r7, #0]
    4f7a:	43db      	mvns	r3, r3
    4f7c:	401a      	ands	r2, r3
    4f7e:	68fb      	ldr	r3, [r7, #12]
    4f80:	601a      	str	r2, [r3, #0]
	}
	taskEXIT_CRITICAL();
    4f82:	f7ff fb5f 	bl	4644 <vPortExitCritical>

	return uxReturn;
    4f86:	68bb      	ldr	r3, [r7, #8]
}
    4f88:	4618      	mov	r0, r3
    4f8a:	3710      	adds	r7, #16
    4f8c:	46bd      	mov	sp, r7
    4f8e:	bd80      	pop	{r7, pc}

00004f90 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    4f90:	b480      	push	{r7}
    4f92:	b087      	sub	sp, #28
    4f94:	af00      	add	r7, sp, #0
    4f96:	6078      	str	r0, [r7, #4]
UBaseType_t uxSavedInterruptStatus;
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    4f98:	687b      	ldr	r3, [r7, #4]
    4f9a:	617b      	str	r3, [r7, #20]
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f9c:	2300      	movs	r3, #0
    4f9e:	613b      	str	r3, [r7, #16]
    4fa0:	f04f 0050 	mov.w	r0, #80	; 0x50
    4fa4:	f380 8811 	msr	BASEPRI, r0
	{
		uxReturn = pxEventBits->uxEventBits;
    4fa8:	697b      	ldr	r3, [r7, #20]
    4faa:	681b      	ldr	r3, [r3, #0]
    4fac:	60fb      	str	r3, [r7, #12]
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    4fae:	f04f 0000 	mov.w	r0, #0
    4fb2:	f380 8811 	msr	BASEPRI, r0

	return uxReturn;
    4fb6:	68fb      	ldr	r3, [r7, #12]
}
    4fb8:	4618      	mov	r0, r3
    4fba:	371c      	adds	r7, #28
    4fbc:	46bd      	mov	sp, r7
    4fbe:	f85d 7b04 	ldr.w	r7, [sp], #4
    4fc2:	4770      	bx	lr

00004fc4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    4fc4:	b580      	push	{r7, lr}
    4fc6:	b08c      	sub	sp, #48	; 0x30
    4fc8:	af00      	add	r7, sp, #0
    4fca:	6078      	str	r0, [r7, #4]
    4fcc:	6039      	str	r1, [r7, #0]
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    4fce:	2300      	movs	r3, #0
    4fd0:	62bb      	str	r3, [r7, #40]	; 0x28
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    4fd2:	687b      	ldr	r3, [r7, #4]
    4fd4:	623b      	str	r3, [r7, #32]
BaseType_t xMatchFound = pdFALSE;
    4fd6:	2300      	movs	r3, #0
    4fd8:	627b      	str	r3, [r7, #36]	; 0x24

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
    4fda:	687b      	ldr	r3, [r7, #4]
    4fdc:	2b00      	cmp	r3, #0
    4fde:	d104      	bne.n	4fea <xEventGroupSetBits+0x26>
    4fe0:	f04f 0050 	mov.w	r0, #80	; 0x50
    4fe4:	f380 8811 	msr	BASEPRI, r0
    4fe8:	e7fe      	b.n	4fe8 <xEventGroupSetBits+0x24>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
    4fea:	683b      	ldr	r3, [r7, #0]
    4fec:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
    4ff0:	2b00      	cmp	r3, #0
    4ff2:	d004      	beq.n	4ffe <xEventGroupSetBits+0x3a>
    4ff4:	f04f 0050 	mov.w	r0, #80	; 0x50
    4ff8:	f380 8811 	msr	BASEPRI, r0
    4ffc:	e7fe      	b.n	4ffc <xEventGroupSetBits+0x38>

	pxList = &( pxEventBits->xTasksWaitingForBits );
    4ffe:	6a3b      	ldr	r3, [r7, #32]
    5000:	3304      	adds	r3, #4
    5002:	61fb      	str	r3, [r7, #28]
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    5004:	69fb      	ldr	r3, [r7, #28]
    5006:	3308      	adds	r3, #8
    5008:	61bb      	str	r3, [r7, #24]
	vTaskSuspendAll();
    500a:	f7fd f8e5 	bl	21d8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    500e:	69fb      	ldr	r3, [r7, #28]
    5010:	68db      	ldr	r3, [r3, #12]
    5012:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    5014:	6a3b      	ldr	r3, [r7, #32]
    5016:	681a      	ldr	r2, [r3, #0]
    5018:	683b      	ldr	r3, [r7, #0]
    501a:	431a      	orrs	r2, r3
    501c:	6a3b      	ldr	r3, [r7, #32]
    501e:	601a      	str	r2, [r3, #0]

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    5020:	e03c      	b.n	509c <xEventGroupSetBits+0xd8>
		{
			pxNext = listGET_NEXT( pxListItem );
    5022:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    5024:	685b      	ldr	r3, [r3, #4]
    5026:	617b      	str	r3, [r7, #20]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    5028:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    502a:	681b      	ldr	r3, [r3, #0]
    502c:	613b      	str	r3, [r7, #16]
			xMatchFound = pdFALSE;
    502e:	2300      	movs	r3, #0
    5030:	627b      	str	r3, [r7, #36]	; 0x24

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    5032:	693b      	ldr	r3, [r7, #16]
    5034:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
    5038:	60fb      	str	r3, [r7, #12]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    503a:	693b      	ldr	r3, [r7, #16]
    503c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    5040:	613b      	str	r3, [r7, #16]

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    5042:	68fb      	ldr	r3, [r7, #12]
    5044:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    5048:	2b00      	cmp	r3, #0
    504a:	d108      	bne.n	505e <xEventGroupSetBits+0x9a>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    504c:	6a3b      	ldr	r3, [r7, #32]
    504e:	681a      	ldr	r2, [r3, #0]
    5050:	693b      	ldr	r3, [r7, #16]
    5052:	4013      	ands	r3, r2
    5054:	2b00      	cmp	r3, #0
    5056:	d00b      	beq.n	5070 <xEventGroupSetBits+0xac>
				{
					xMatchFound = pdTRUE;
    5058:	2301      	movs	r3, #1
    505a:	627b      	str	r3, [r7, #36]	; 0x24
    505c:	e008      	b.n	5070 <xEventGroupSetBits+0xac>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    505e:	6a3b      	ldr	r3, [r7, #32]
    5060:	681a      	ldr	r2, [r3, #0]
    5062:	693b      	ldr	r3, [r7, #16]
    5064:	401a      	ands	r2, r3
    5066:	693b      	ldr	r3, [r7, #16]
    5068:	429a      	cmp	r2, r3
    506a:	d101      	bne.n	5070 <xEventGroupSetBits+0xac>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    506c:	2301      	movs	r3, #1
    506e:	627b      	str	r3, [r7, #36]	; 0x24
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    5070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    5072:	2b00      	cmp	r3, #0
    5074:	d010      	beq.n	5098 <xEventGroupSetBits+0xd4>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    5076:	68fb      	ldr	r3, [r7, #12]
    5078:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    507c:	2b00      	cmp	r3, #0
    507e:	d003      	beq.n	5088 <xEventGroupSetBits+0xc4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    5080:	6aba      	ldr	r2, [r7, #40]	; 0x28
    5082:	693b      	ldr	r3, [r7, #16]
    5084:	4313      	orrs	r3, r2
    5086:	62bb      	str	r3, [r7, #40]	; 0x28
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    5088:	6a3b      	ldr	r3, [r7, #32]
    508a:	681b      	ldr	r3, [r3, #0]
    508c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
    5090:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    5092:	4619      	mov	r1, r3
    5094:	f7fd fc16 	bl	28c4 <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    5098:	697b      	ldr	r3, [r7, #20]
    509a:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    509c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    509e:	69bb      	ldr	r3, [r7, #24]
    50a0:	429a      	cmp	r2, r3
    50a2:	d1be      	bne.n	5022 <xEventGroupSetBits+0x5e>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    50a4:	6a3b      	ldr	r3, [r7, #32]
    50a6:	681a      	ldr	r2, [r3, #0]
    50a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    50aa:	43db      	mvns	r3, r3
    50ac:	401a      	ands	r2, r3
    50ae:	6a3b      	ldr	r3, [r7, #32]
    50b0:	601a      	str	r2, [r3, #0]
	}
	( void ) xTaskResumeAll();
    50b2:	f7fd f89f 	bl	21f4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    50b6:	6a3b      	ldr	r3, [r7, #32]
    50b8:	681b      	ldr	r3, [r3, #0]
}
    50ba:	4618      	mov	r0, r3
    50bc:	3730      	adds	r7, #48	; 0x30
    50be:	46bd      	mov	sp, r7
    50c0:	bd80      	pop	{r7, pc}
    50c2:	bf00      	nop

000050c4 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    50c4:	b580      	push	{r7, lr}
    50c6:	b084      	sub	sp, #16
    50c8:	af00      	add	r7, sp, #0
    50ca:	6078      	str	r0, [r7, #4]
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    50cc:	687b      	ldr	r3, [r7, #4]
    50ce:	60fb      	str	r3, [r7, #12]
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    50d0:	68fb      	ldr	r3, [r7, #12]
    50d2:	3304      	adds	r3, #4
    50d4:	60bb      	str	r3, [r7, #8]

	vTaskSuspendAll();
    50d6:	f7fd f87f 	bl	21d8 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    50da:	e011      	b.n	5100 <vEventGroupDelete+0x3c>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
    50dc:	68bb      	ldr	r3, [r7, #8]
    50de:	68da      	ldr	r2, [r3, #12]
    50e0:	68bb      	ldr	r3, [r7, #8]
    50e2:	3308      	adds	r3, #8
    50e4:	429a      	cmp	r2, r3
    50e6:	d104      	bne.n	50f2 <vEventGroupDelete+0x2e>
    50e8:	f04f 0050 	mov.w	r0, #80	; 0x50
    50ec:	f380 8811 	msr	BASEPRI, r0
    50f0:	e7fe      	b.n	50f0 <vEventGroupDelete+0x2c>
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    50f2:	68bb      	ldr	r3, [r7, #8]
    50f4:	68db      	ldr	r3, [r3, #12]
    50f6:	4618      	mov	r0, r3
    50f8:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
    50fc:	f7fd fbe2 	bl	28c4 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    5100:	68bb      	ldr	r3, [r7, #8]
    5102:	681b      	ldr	r3, [r3, #0]
    5104:	2b00      	cmp	r3, #0
    5106:	d1e9      	bne.n	50dc <vEventGroupDelete+0x18>
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
		}

		vPortFree( pxEventBits );
    5108:	68f8      	ldr	r0, [r7, #12]
    510a:	f7ff fc95 	bl	4a38 <vPortFree>
	}
	( void ) xTaskResumeAll();
    510e:	f7fd f871 	bl	21f4 <xTaskResumeAll>
}
    5112:	3710      	adds	r7, #16
    5114:	46bd      	mov	sp, r7
    5116:	bd80      	pop	{r7, pc}

00005118 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    5118:	b580      	push	{r7, lr}
    511a:	b082      	sub	sp, #8
    511c:	af00      	add	r7, sp, #0
    511e:	6078      	str	r0, [r7, #4]
    5120:	6039      	str	r1, [r7, #0]
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
    5122:	6878      	ldr	r0, [r7, #4]
    5124:	6839      	ldr	r1, [r7, #0]
    5126:	f7ff ff4d 	bl	4fc4 <xEventGroupSetBits>
}
    512a:	3708      	adds	r7, #8
    512c:	46bd      	mov	sp, r7
    512e:	bd80      	pop	{r7, pc}

00005130 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    5130:	b580      	push	{r7, lr}
    5132:	b082      	sub	sp, #8
    5134:	af00      	add	r7, sp, #0
    5136:	6078      	str	r0, [r7, #4]
    5138:	6039      	str	r1, [r7, #0]
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
    513a:	6878      	ldr	r0, [r7, #4]
    513c:	6839      	ldr	r1, [r7, #0]
    513e:	f7ff fefb 	bl	4f38 <xEventGroupClearBits>
}
    5142:	3708      	adds	r7, #8
    5144:	46bd      	mov	sp, r7
    5146:	bd80      	pop	{r7, pc}

00005148 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    5148:	b480      	push	{r7}
    514a:	b087      	sub	sp, #28
    514c:	af00      	add	r7, sp, #0
    514e:	60f8      	str	r0, [r7, #12]
    5150:	60b9      	str	r1, [r7, #8]
    5152:	607a      	str	r2, [r7, #4]
BaseType_t xWaitConditionMet = pdFALSE;
    5154:	2300      	movs	r3, #0
    5156:	617b      	str	r3, [r7, #20]

	if( xWaitForAllBits == pdFALSE )
    5158:	687b      	ldr	r3, [r7, #4]
    515a:	2b00      	cmp	r3, #0
    515c:	d107      	bne.n	516e <prvTestWaitCondition+0x26>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    515e:	68fa      	ldr	r2, [r7, #12]
    5160:	68bb      	ldr	r3, [r7, #8]
    5162:	4013      	ands	r3, r2
    5164:	2b00      	cmp	r3, #0
    5166:	d00a      	beq.n	517e <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
    5168:	2301      	movs	r3, #1
    516a:	617b      	str	r3, [r7, #20]
    516c:	e007      	b.n	517e <prvTestWaitCondition+0x36>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    516e:	68fa      	ldr	r2, [r7, #12]
    5170:	68bb      	ldr	r3, [r7, #8]
    5172:	401a      	ands	r2, r3
    5174:	68bb      	ldr	r3, [r7, #8]
    5176:	429a      	cmp	r2, r3
    5178:	d101      	bne.n	517e <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
    517a:	2301      	movs	r3, #1
    517c:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    517e:	697b      	ldr	r3, [r7, #20]
}
    5180:	4618      	mov	r0, r3
    5182:	371c      	adds	r7, #28
    5184:	46bd      	mov	sp, r7
    5186:	f85d 7b04 	ldr.w	r7, [sp], #4
    518a:	4770      	bx	lr

0000518c <uxEventGroupGetNumber>:
/*-----------------------------------------------------------*/

#if (configUSE_TRACE_FACILITY == 1)

	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
	{
    518c:	b480      	push	{r7}
    518e:	b085      	sub	sp, #20
    5190:	af00      	add	r7, sp, #0
    5192:	6078      	str	r0, [r7, #4]
	UBaseType_t xReturn;
	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
    5194:	687b      	ldr	r3, [r7, #4]
    5196:	60bb      	str	r3, [r7, #8]

		if( xEventGroup == NULL )
    5198:	687b      	ldr	r3, [r7, #4]
    519a:	2b00      	cmp	r3, #0
    519c:	d102      	bne.n	51a4 <uxEventGroupGetNumber+0x18>
		{
			xReturn = 0;
    519e:	2300      	movs	r3, #0
    51a0:	60fb      	str	r3, [r7, #12]
    51a2:	e002      	b.n	51aa <uxEventGroupGetNumber+0x1e>
		}
		else
		{
			xReturn = pxEventBits->uxEventGroupNumber;
    51a4:	68bb      	ldr	r3, [r7, #8]
    51a6:	699b      	ldr	r3, [r3, #24]
    51a8:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
    51aa:	68fb      	ldr	r3, [r7, #12]
	}
    51ac:	4618      	mov	r0, r3
    51ae:	3714      	adds	r7, #20
    51b0:	46bd      	mov	sp, r7
    51b2:	f85d 7b04 	ldr.w	r7, [sp], #4
    51b6:	4770      	bx	lr

000051b8 <UTIL1_strcpy>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] src The source string to copy
*/
void UTIL1_strcpy(uint8_t *dst, size_t dstSize, const unsigned char *src)
{
    51b8:	b480      	push	{r7}
    51ba:	b085      	sub	sp, #20
    51bc:	af00      	add	r7, sp, #0
    51be:	60f8      	str	r0, [r7, #12]
    51c0:	60b9      	str	r1, [r7, #8]
    51c2:	607a      	str	r2, [r7, #4]
  dstSize--; /* for zero uint8_t */
    51c4:	68bb      	ldr	r3, [r7, #8]
    51c6:	3b01      	subs	r3, #1
    51c8:	60bb      	str	r3, [r7, #8]
  while (dstSize > 0 && *src != '\0') {
    51ca:	e00a      	b.n	51e2 <UTIL1_strcpy+0x2a>
    *dst++ = *src++;
    51cc:	68fb      	ldr	r3, [r7, #12]
    51ce:	1c5a      	adds	r2, r3, #1
    51d0:	60fa      	str	r2, [r7, #12]
    51d2:	687a      	ldr	r2, [r7, #4]
    51d4:	1c51      	adds	r1, r2, #1
    51d6:	6079      	str	r1, [r7, #4]
    51d8:	7812      	ldrb	r2, [r2, #0]
    51da:	701a      	strb	r2, [r3, #0]
    dstSize--;
    51dc:	68bb      	ldr	r3, [r7, #8]
    51de:	3b01      	subs	r3, #1
    51e0:	60bb      	str	r3, [r7, #8]
  \param[in] src The source string to copy
*/
void UTIL1_strcpy(uint8_t *dst, size_t dstSize, const unsigned char *src)
{
  dstSize--; /* for zero uint8_t */
  while (dstSize > 0 && *src != '\0') {
    51e2:	68bb      	ldr	r3, [r7, #8]
    51e4:	2b00      	cmp	r3, #0
    51e6:	d003      	beq.n	51f0 <UTIL1_strcpy+0x38>
    51e8:	687b      	ldr	r3, [r7, #4]
    51ea:	781b      	ldrb	r3, [r3, #0]
    51ec:	2b00      	cmp	r3, #0
    51ee:	d1ed      	bne.n	51cc <UTIL1_strcpy+0x14>
    *dst++ = *src++;
    dstSize--;
  }
  *dst = '\0';
    51f0:	68fb      	ldr	r3, [r7, #12]
    51f2:	2200      	movs	r2, #0
    51f4:	701a      	strb	r2, [r3, #0]
}
    51f6:	3714      	adds	r7, #20
    51f8:	46bd      	mov	sp, r7
    51fa:	f85d 7b04 	ldr.w	r7, [sp], #4
    51fe:	4770      	bx	lr

00005200 <UTIL1_strcat>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] src The source string to add
  */
void UTIL1_strcat(uint8_t *dst, size_t dstSize, const unsigned char *src)
{
    5200:	b480      	push	{r7}
    5202:	b085      	sub	sp, #20
    5204:	af00      	add	r7, sp, #0
    5206:	60f8      	str	r0, [r7, #12]
    5208:	60b9      	str	r1, [r7, #8]
    520a:	607a      	str	r2, [r7, #4]
  dstSize--; /* for zero uint8_t */
    520c:	68bb      	ldr	r3, [r7, #8]
    520e:	3b01      	subs	r3, #1
    5210:	60bb      	str	r3, [r7, #8]
  /* point to the end of the source */
  while (dstSize > 0 && *dst != '\0') {
    5212:	e005      	b.n	5220 <UTIL1_strcat+0x20>
    dst++;
    5214:	68fb      	ldr	r3, [r7, #12]
    5216:	3301      	adds	r3, #1
    5218:	60fb      	str	r3, [r7, #12]
    dstSize--;
    521a:	68bb      	ldr	r3, [r7, #8]
    521c:	3b01      	subs	r3, #1
    521e:	60bb      	str	r3, [r7, #8]
  */
void UTIL1_strcat(uint8_t *dst, size_t dstSize, const unsigned char *src)
{
  dstSize--; /* for zero uint8_t */
  /* point to the end of the source */
  while (dstSize > 0 && *dst != '\0') {
    5220:	68bb      	ldr	r3, [r7, #8]
    5222:	2b00      	cmp	r3, #0
    5224:	d003      	beq.n	522e <UTIL1_strcat+0x2e>
    5226:	68fb      	ldr	r3, [r7, #12]
    5228:	781b      	ldrb	r3, [r3, #0]
    522a:	2b00      	cmp	r3, #0
    522c:	d1f2      	bne.n	5214 <UTIL1_strcat+0x14>
    dst++;
    dstSize--;
  }
  /* copy the src in the destination */
  while (dstSize > 0 && *src != '\0') {
    522e:	e00a      	b.n	5246 <UTIL1_strcat+0x46>
    *dst++ = *src++;
    5230:	68fb      	ldr	r3, [r7, #12]
    5232:	1c5a      	adds	r2, r3, #1
    5234:	60fa      	str	r2, [r7, #12]
    5236:	687a      	ldr	r2, [r7, #4]
    5238:	1c51      	adds	r1, r2, #1
    523a:	6079      	str	r1, [r7, #4]
    523c:	7812      	ldrb	r2, [r2, #0]
    523e:	701a      	strb	r2, [r3, #0]
    dstSize--;
    5240:	68bb      	ldr	r3, [r7, #8]
    5242:	3b01      	subs	r3, #1
    5244:	60bb      	str	r3, [r7, #8]
  while (dstSize > 0 && *dst != '\0') {
    dst++;
    dstSize--;
  }
  /* copy the src in the destination */
  while (dstSize > 0 && *src != '\0') {
    5246:	68bb      	ldr	r3, [r7, #8]
    5248:	2b00      	cmp	r3, #0
    524a:	d003      	beq.n	5254 <UTIL1_strcat+0x54>
    524c:	687b      	ldr	r3, [r7, #4]
    524e:	781b      	ldrb	r3, [r3, #0]
    5250:	2b00      	cmp	r3, #0
    5252:	d1ed      	bne.n	5230 <UTIL1_strcat+0x30>
    *dst++ = *src++;
    dstSize--;
  }
  /* terminate the string */
  *dst = '\0';
    5254:	68fb      	ldr	r3, [r7, #12]
    5256:	2200      	movs	r2, #0
    5258:	701a      	strb	r2, [r3, #0]
}
    525a:	3714      	adds	r7, #20
    525c:	46bd      	mov	sp, r7
    525e:	f85d 7b04 	ldr.w	r7, [sp], #4
    5262:	4770      	bx	lr

00005264 <UTIL1_chcat>:
**         ch              - character to append
**     Returns     : Nothing
** ===================================================================
*/
void UTIL1_chcat(uint8_t *dst, size_t dstSize, uint8_t ch)
{
    5264:	b480      	push	{r7}
    5266:	b085      	sub	sp, #20
    5268:	af00      	add	r7, sp, #0
    526a:	60f8      	str	r0, [r7, #12]
    526c:	60b9      	str	r1, [r7, #8]
    526e:	4613      	mov	r3, r2
    5270:	71fb      	strb	r3, [r7, #7]
  dstSize--; /* for zero uint8_t */
    5272:	68bb      	ldr	r3, [r7, #8]
    5274:	3b01      	subs	r3, #1
    5276:	60bb      	str	r3, [r7, #8]
  /* point to the end of the source */
  while (dstSize > 0 && *dst != '\0') {
    5278:	e005      	b.n	5286 <UTIL1_chcat+0x22>
    dst++;
    527a:	68fb      	ldr	r3, [r7, #12]
    527c:	3301      	adds	r3, #1
    527e:	60fb      	str	r3, [r7, #12]
    dstSize--;
    5280:	68bb      	ldr	r3, [r7, #8]
    5282:	3b01      	subs	r3, #1
    5284:	60bb      	str	r3, [r7, #8]
*/
void UTIL1_chcat(uint8_t *dst, size_t dstSize, uint8_t ch)
{
  dstSize--; /* for zero uint8_t */
  /* point to the end of the source */
  while (dstSize > 0 && *dst != '\0') {
    5286:	68bb      	ldr	r3, [r7, #8]
    5288:	2b00      	cmp	r3, #0
    528a:	d003      	beq.n	5294 <UTIL1_chcat+0x30>
    528c:	68fb      	ldr	r3, [r7, #12]
    528e:	781b      	ldrb	r3, [r3, #0]
    5290:	2b00      	cmp	r3, #0
    5292:	d1f2      	bne.n	527a <UTIL1_chcat+0x16>
    dst++;
    dstSize--;
  }
  /* copy the ch in the destination */
  if (dstSize > 0) {
    5294:	68bb      	ldr	r3, [r7, #8]
    5296:	2b00      	cmp	r3, #0
    5298:	d004      	beq.n	52a4 <UTIL1_chcat+0x40>
    *dst++ = ch;
    529a:	68fb      	ldr	r3, [r7, #12]
    529c:	1c5a      	adds	r2, r3, #1
    529e:	60fa      	str	r2, [r7, #12]
    52a0:	79fa      	ldrb	r2, [r7, #7]
    52a2:	701a      	strb	r2, [r3, #0]
  }
  /* terminate the string */
  *dst = '\0';
    52a4:	68fb      	ldr	r3, [r7, #12]
    52a6:	2200      	movs	r2, #0
    52a8:	701a      	strb	r2, [r3, #0]
}
    52aa:	3714      	adds	r7, #20
    52ac:	46bd      	mov	sp, r7
    52ae:	f85d 7b04 	ldr.w	r7, [sp], #4
    52b2:	4770      	bx	lr

000052b4 <UTIL1_Num8uToStr>:
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in uint8_ts.
  \param[in] val 8bit unsigned number to convert.
 */
void UTIL1_Num8uToStr(uint8_t *dst, size_t dstSize, uint8_t val)
{
    52b4:	b580      	push	{r7, lr}
    52b6:	b084      	sub	sp, #16
    52b8:	af00      	add	r7, sp, #0
    52ba:	60f8      	str	r0, [r7, #12]
    52bc:	60b9      	str	r1, [r7, #8]
    52be:	4613      	mov	r3, r2
    52c0:	71fb      	strb	r3, [r7, #7]
  UTIL1_Num16uToStr(dst, dstSize, (uint16_t)val);
    52c2:	79fb      	ldrb	r3, [r7, #7]
    52c4:	b29b      	uxth	r3, r3
    52c6:	68f8      	ldr	r0, [r7, #12]
    52c8:	68b9      	ldr	r1, [r7, #8]
    52ca:	461a      	mov	r2, r3
    52cc:	f000 f818 	bl	5300 <UTIL1_Num16uToStr>
}
    52d0:	3710      	adds	r7, #16
    52d2:	46bd      	mov	sp, r7
    52d4:	bd80      	pop	{r7, pc}
    52d6:	bf00      	nop

000052d8 <UTIL1_Num8sToStr>:
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in uint8_ts.
  \param[in] val 8bit signed number to convert.
 */
void UTIL1_Num8sToStr(uint8_t *dst, size_t dstSize, signed char val)
{
    52d8:	b580      	push	{r7, lr}
    52da:	b084      	sub	sp, #16
    52dc:	af00      	add	r7, sp, #0
    52de:	60f8      	str	r0, [r7, #12]
    52e0:	60b9      	str	r1, [r7, #8]
    52e2:	4613      	mov	r3, r2
    52e4:	71fb      	strb	r3, [r7, #7]
  UTIL1_Num16sToStr(dst, dstSize, (int16_t)val);
    52e6:	f997 3007 	ldrsb.w	r3, [r7, #7]
    52ea:	b29b      	uxth	r3, r3
    52ec:	b21b      	sxth	r3, r3
    52ee:	68f8      	ldr	r0, [r7, #12]
    52f0:	68b9      	ldr	r1, [r7, #8]
    52f2:	461a      	mov	r2, r3
    52f4:	f000 f878 	bl	53e8 <UTIL1_Num16sToStr>
}
    52f8:	3710      	adds	r7, #16
    52fa:	46bd      	mov	sp, r7
    52fc:	bd80      	pop	{r7, pc}
    52fe:	bf00      	nop

00005300 <UTIL1_Num16uToStr>:
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in uint8_ts.
  \param[in] val 16bit unsigned number to convert.
 */
void UTIL1_Num16uToStr(uint8_t *dst, size_t dstSize, uint16_t val)
{
    5300:	b480      	push	{r7}
    5302:	b089      	sub	sp, #36	; 0x24
    5304:	af00      	add	r7, sp, #0
    5306:	60f8      	str	r0, [r7, #12]
    5308:	60b9      	str	r1, [r7, #8]
    530a:	4613      	mov	r3, r2
    530c:	80fb      	strh	r3, [r7, #6]
  unsigned char *ptr = ((unsigned char *)dst);
    530e:	68fb      	ldr	r3, [r7, #12]
    5310:	61bb      	str	r3, [r7, #24]
  unsigned char i=0, j;
    5312:	2300      	movs	r3, #0
    5314:	77fb      	strb	r3, [r7, #31]
  unsigned char tmp;

  dstSize--; /* for zero uint8_t */
    5316:	68bb      	ldr	r3, [r7, #8]
    5318:	3b01      	subs	r3, #1
    531a:	60bb      	str	r3, [r7, #8]
  if (val == 0 && dstSize > 0){
    531c:	88fb      	ldrh	r3, [r7, #6]
    531e:	2b00      	cmp	r3, #0
    5320:	d10d      	bne.n	533e <UTIL1_Num16uToStr+0x3e>
    5322:	68bb      	ldr	r3, [r7, #8]
    5324:	2b00      	cmp	r3, #0
    5326:	d00a      	beq.n	533e <UTIL1_Num16uToStr+0x3e>
    ptr[i++] = '0';
    5328:	7ffb      	ldrb	r3, [r7, #31]
    532a:	1c5a      	adds	r2, r3, #1
    532c:	77fa      	strb	r2, [r7, #31]
    532e:	69ba      	ldr	r2, [r7, #24]
    5330:	4413      	add	r3, r2
    5332:	2230      	movs	r2, #48	; 0x30
    5334:	701a      	strb	r2, [r3, #0]
    dstSize--;
    5336:	68bb      	ldr	r3, [r7, #8]
    5338:	3b01      	subs	r3, #1
    533a:	60bb      	str	r3, [r7, #8]
  }
  while (val > 0 && dstSize > 0) {
    533c:	e01d      	b.n	537a <UTIL1_Num16uToStr+0x7a>
    533e:	e01c      	b.n	537a <UTIL1_Num16uToStr+0x7a>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    5340:	7ffb      	ldrb	r3, [r7, #31]
    5342:	1c5a      	adds	r2, r3, #1
    5344:	77fa      	strb	r2, [r7, #31]
    5346:	69ba      	ldr	r2, [r7, #24]
    5348:	18d0      	adds	r0, r2, r3
    534a:	88fa      	ldrh	r2, [r7, #6]
    534c:	4b25      	ldr	r3, [pc, #148]	; (53e4 <UTIL1_Num16uToStr+0xe4>)
    534e:	fba3 1302 	umull	r1, r3, r3, r2
    5352:	08d9      	lsrs	r1, r3, #3
    5354:	460b      	mov	r3, r1
    5356:	009b      	lsls	r3, r3, #2
    5358:	440b      	add	r3, r1
    535a:	005b      	lsls	r3, r3, #1
    535c:	1ad3      	subs	r3, r2, r3
    535e:	b29b      	uxth	r3, r3
    5360:	b2db      	uxtb	r3, r3
    5362:	3330      	adds	r3, #48	; 0x30
    5364:	b2db      	uxtb	r3, r3
    5366:	7003      	strb	r3, [r0, #0]
    dstSize--;
    5368:	68bb      	ldr	r3, [r7, #8]
    536a:	3b01      	subs	r3, #1
    536c:	60bb      	str	r3, [r7, #8]
    val /= 10;
    536e:	88fa      	ldrh	r2, [r7, #6]
    5370:	4b1c      	ldr	r3, [pc, #112]	; (53e4 <UTIL1_Num16uToStr+0xe4>)
    5372:	fba3 1302 	umull	r1, r3, r3, r2
    5376:	08db      	lsrs	r3, r3, #3
    5378:	80fb      	strh	r3, [r7, #6]
  dstSize--; /* for zero uint8_t */
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    537a:	88fb      	ldrh	r3, [r7, #6]
    537c:	2b00      	cmp	r3, #0
    537e:	d002      	beq.n	5386 <UTIL1_Num16uToStr+0x86>
    5380:	68bb      	ldr	r3, [r7, #8]
    5382:	2b00      	cmp	r3, #0
    5384:	d1dc      	bne.n	5340 <UTIL1_Num16uToStr+0x40>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    dstSize--;
    val /= 10;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    5386:	2300      	movs	r3, #0
    5388:	77bb      	strb	r3, [r7, #30]
    538a:	e01a      	b.n	53c2 <UTIL1_Num16uToStr+0xc2>
    tmp = ptr[j];
    538c:	7fbb      	ldrb	r3, [r7, #30]
    538e:	69ba      	ldr	r2, [r7, #24]
    5390:	4413      	add	r3, r2
    5392:	781b      	ldrb	r3, [r3, #0]
    5394:	75fb      	strb	r3, [r7, #23]
    ptr[j] = ptr[(i-j)-1];
    5396:	7fbb      	ldrb	r3, [r7, #30]
    5398:	69ba      	ldr	r2, [r7, #24]
    539a:	4413      	add	r3, r2
    539c:	7ff9      	ldrb	r1, [r7, #31]
    539e:	7fba      	ldrb	r2, [r7, #30]
    53a0:	1a8a      	subs	r2, r1, r2
    53a2:	3a01      	subs	r2, #1
    53a4:	69b9      	ldr	r1, [r7, #24]
    53a6:	440a      	add	r2, r1
    53a8:	7812      	ldrb	r2, [r2, #0]
    53aa:	701a      	strb	r2, [r3, #0]
    ptr[(i-j)-1] = tmp;
    53ac:	7ffa      	ldrb	r2, [r7, #31]
    53ae:	7fbb      	ldrb	r3, [r7, #30]
    53b0:	1ad3      	subs	r3, r2, r3
    53b2:	3b01      	subs	r3, #1
    53b4:	69ba      	ldr	r2, [r7, #24]
    53b6:	4413      	add	r3, r2
    53b8:	7dfa      	ldrb	r2, [r7, #23]
    53ba:	701a      	strb	r2, [r3, #0]
  while (val > 0 && dstSize > 0) {
    ptr[i++] = (unsigned char)((val % 10) + '0');
    dstSize--;
    val /= 10;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    53bc:	7fbb      	ldrb	r3, [r7, #30]
    53be:	3301      	adds	r3, #1
    53c0:	77bb      	strb	r3, [r7, #30]
    53c2:	7ffb      	ldrb	r3, [r7, #31]
    53c4:	085b      	lsrs	r3, r3, #1
    53c6:	b2db      	uxtb	r3, r3
    53c8:	7fba      	ldrb	r2, [r7, #30]
    53ca:	429a      	cmp	r2, r3
    53cc:	d3de      	bcc.n	538c <UTIL1_Num16uToStr+0x8c>
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
    53ce:	7ffb      	ldrb	r3, [r7, #31]
    53d0:	69ba      	ldr	r2, [r7, #24]
    53d2:	4413      	add	r3, r2
    53d4:	2200      	movs	r2, #0
    53d6:	701a      	strb	r2, [r3, #0]
}
    53d8:	3724      	adds	r7, #36	; 0x24
    53da:	46bd      	mov	sp, r7
    53dc:	f85d 7b04 	ldr.w	r7, [sp], #4
    53e0:	4770      	bx	lr
    53e2:	bf00      	nop
    53e4:	cccccccd 	.word	0xcccccccd

000053e8 <UTIL1_Num16sToStr>:
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in uint8_ts.
  \param[in] val 16bit signed number to convert.
 */
void UTIL1_Num16sToStr(uint8_t *dst, size_t dstSize, int16_t val)
{
    53e8:	b580      	push	{r7, lr}
    53ea:	b088      	sub	sp, #32
    53ec:	af00      	add	r7, sp, #0
    53ee:	60f8      	str	r0, [r7, #12]
    53f0:	60b9      	str	r1, [r7, #8]
    53f2:	4613      	mov	r3, r2
    53f4:	80fb      	strh	r3, [r7, #6]
  unsigned char *ptr =  ((unsigned char *)dst);
    53f6:	68fb      	ldr	r3, [r7, #12]
    53f8:	61bb      	str	r3, [r7, #24]
  unsigned char i=0, j;
    53fa:	2300      	movs	r3, #0
    53fc:	77fb      	strb	r3, [r7, #31]
  unsigned char tmp;
  unsigned char sign = (unsigned char)(val < 0);
    53fe:	88fb      	ldrh	r3, [r7, #6]
    5400:	0bdb      	lsrs	r3, r3, #15
    5402:	b2db      	uxtb	r3, r3
    5404:	75fb      	strb	r3, [r7, #23]

  if (val==(int16_t)(0x8000)) { /* special case 0x8000/-32768: prevent overflow below. */
    5406:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    540a:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
    540e:	d105      	bne.n	541c <UTIL1_Num16sToStr+0x34>
    UTIL1_strcpy(dst, dstSize, (unsigned char*)"-32768");
    5410:	68f8      	ldr	r0, [r7, #12]
    5412:	68b9      	ldr	r1, [r7, #8]
    5414:	4a43      	ldr	r2, [pc, #268]	; (5524 <UTIL1_Num16sToStr+0x13c>)
    5416:	f7ff fecf 	bl	51b8 <UTIL1_strcpy>
    return;
    541a:	e07f      	b.n	551c <UTIL1_Num16sToStr+0x134>
  }
  dstSize--; /* for zero uint8_t */
    541c:	68bb      	ldr	r3, [r7, #8]
    541e:	3b01      	subs	r3, #1
    5420:	60bb      	str	r3, [r7, #8]
  if (sign) {
    5422:	7dfb      	ldrb	r3, [r7, #23]
    5424:	2b00      	cmp	r3, #0
    5426:	d003      	beq.n	5430 <UTIL1_Num16sToStr+0x48>
    val = -val;
    5428:	88fb      	ldrh	r3, [r7, #6]
    542a:	425b      	negs	r3, r3
    542c:	b29b      	uxth	r3, r3
    542e:	80fb      	strh	r3, [r7, #6]
  }
  if (val == 0 && dstSize > 0){
    5430:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    5434:	2b00      	cmp	r3, #0
    5436:	d10d      	bne.n	5454 <UTIL1_Num16sToStr+0x6c>
    5438:	68bb      	ldr	r3, [r7, #8]
    543a:	2b00      	cmp	r3, #0
    543c:	d00a      	beq.n	5454 <UTIL1_Num16sToStr+0x6c>
    ptr[i++] = '0';
    543e:	7ffb      	ldrb	r3, [r7, #31]
    5440:	1c5a      	adds	r2, r3, #1
    5442:	77fa      	strb	r2, [r7, #31]
    5444:	69ba      	ldr	r2, [r7, #24]
    5446:	4413      	add	r3, r2
    5448:	2230      	movs	r2, #48	; 0x30
    544a:	701a      	strb	r2, [r3, #0]
    dstSize--;
    544c:	68bb      	ldr	r3, [r7, #8]
    544e:	3b01      	subs	r3, #1
    5450:	60bb      	str	r3, [r7, #8]
  }
  while (val > 0 && dstSize > 0) {
    5452:	e023      	b.n	549c <UTIL1_Num16sToStr+0xb4>
    5454:	e022      	b.n	549c <UTIL1_Num16sToStr+0xb4>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    5456:	7ffb      	ldrb	r3, [r7, #31]
    5458:	1c5a      	adds	r2, r3, #1
    545a:	77fa      	strb	r2, [r7, #31]
    545c:	69ba      	ldr	r2, [r7, #24]
    545e:	18d0      	adds	r0, r2, r3
    5460:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    5464:	4b30      	ldr	r3, [pc, #192]	; (5528 <UTIL1_Num16sToStr+0x140>)
    5466:	fb83 1302 	smull	r1, r3, r3, r2
    546a:	1099      	asrs	r1, r3, #2
    546c:	17d3      	asrs	r3, r2, #31
    546e:	1ac9      	subs	r1, r1, r3
    5470:	460b      	mov	r3, r1
    5472:	009b      	lsls	r3, r3, #2
    5474:	440b      	add	r3, r1
    5476:	005b      	lsls	r3, r3, #1
    5478:	1ad3      	subs	r3, r2, r3
    547a:	b29b      	uxth	r3, r3
    547c:	b2db      	uxtb	r3, r3
    547e:	3330      	adds	r3, #48	; 0x30
    5480:	b2db      	uxtb	r3, r3
    5482:	7003      	strb	r3, [r0, #0]
    dstSize--;
    5484:	68bb      	ldr	r3, [r7, #8]
    5486:	3b01      	subs	r3, #1
    5488:	60bb      	str	r3, [r7, #8]
    val /= 10;
    548a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    548e:	4a26      	ldr	r2, [pc, #152]	; (5528 <UTIL1_Num16sToStr+0x140>)
    5490:	fb82 1203 	smull	r1, r2, r2, r3
    5494:	1092      	asrs	r2, r2, #2
    5496:	17db      	asrs	r3, r3, #31
    5498:	1ad3      	subs	r3, r2, r3
    549a:	80fb      	strh	r3, [r7, #6]
  }
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    549c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    54a0:	2b00      	cmp	r3, #0
    54a2:	dd02      	ble.n	54aa <UTIL1_Num16sToStr+0xc2>
    54a4:	68bb      	ldr	r3, [r7, #8]
    54a6:	2b00      	cmp	r3, #0
    54a8:	d1d5      	bne.n	5456 <UTIL1_Num16sToStr+0x6e>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    dstSize--;
    val /= 10;
  }
  if (sign && dstSize > 0){
    54aa:	7dfb      	ldrb	r3, [r7, #23]
    54ac:	2b00      	cmp	r3, #0
    54ae:	d00c      	beq.n	54ca <UTIL1_Num16sToStr+0xe2>
    54b0:	68bb      	ldr	r3, [r7, #8]
    54b2:	2b00      	cmp	r3, #0
    54b4:	d009      	beq.n	54ca <UTIL1_Num16sToStr+0xe2>
    ptr[i++] = '-';
    54b6:	7ffb      	ldrb	r3, [r7, #31]
    54b8:	1c5a      	adds	r2, r3, #1
    54ba:	77fa      	strb	r2, [r7, #31]
    54bc:	69ba      	ldr	r2, [r7, #24]
    54be:	4413      	add	r3, r2
    54c0:	222d      	movs	r2, #45	; 0x2d
    54c2:	701a      	strb	r2, [r3, #0]
    dstSize--;
    54c4:	68bb      	ldr	r3, [r7, #8]
    54c6:	3b01      	subs	r3, #1
    54c8:	60bb      	str	r3, [r7, #8]
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    54ca:	2300      	movs	r3, #0
    54cc:	77bb      	strb	r3, [r7, #30]
    54ce:	e01a      	b.n	5506 <UTIL1_Num16sToStr+0x11e>
    tmp = ptr[j];
    54d0:	7fbb      	ldrb	r3, [r7, #30]
    54d2:	69ba      	ldr	r2, [r7, #24]
    54d4:	4413      	add	r3, r2
    54d6:	781b      	ldrb	r3, [r3, #0]
    54d8:	75bb      	strb	r3, [r7, #22]
    ptr[j] = ptr[(i-j)-1];
    54da:	7fbb      	ldrb	r3, [r7, #30]
    54dc:	69ba      	ldr	r2, [r7, #24]
    54de:	4413      	add	r3, r2
    54e0:	7ff9      	ldrb	r1, [r7, #31]
    54e2:	7fba      	ldrb	r2, [r7, #30]
    54e4:	1a8a      	subs	r2, r1, r2
    54e6:	3a01      	subs	r2, #1
    54e8:	69b9      	ldr	r1, [r7, #24]
    54ea:	440a      	add	r2, r1
    54ec:	7812      	ldrb	r2, [r2, #0]
    54ee:	701a      	strb	r2, [r3, #0]
    ptr[(i-j)-1] = tmp;
    54f0:	7ffa      	ldrb	r2, [r7, #31]
    54f2:	7fbb      	ldrb	r3, [r7, #30]
    54f4:	1ad3      	subs	r3, r2, r3
    54f6:	3b01      	subs	r3, #1
    54f8:	69ba      	ldr	r2, [r7, #24]
    54fa:	4413      	add	r3, r2
    54fc:	7dba      	ldrb	r2, [r7, #22]
    54fe:	701a      	strb	r2, [r3, #0]
  }
  if (sign && dstSize > 0){
    ptr[i++] = '-';
    dstSize--;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    5500:	7fbb      	ldrb	r3, [r7, #30]
    5502:	3301      	adds	r3, #1
    5504:	77bb      	strb	r3, [r7, #30]
    5506:	7ffb      	ldrb	r3, [r7, #31]
    5508:	085b      	lsrs	r3, r3, #1
    550a:	b2db      	uxtb	r3, r3
    550c:	7fba      	ldrb	r2, [r7, #30]
    550e:	429a      	cmp	r2, r3
    5510:	d3de      	bcc.n	54d0 <UTIL1_Num16sToStr+0xe8>
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
    5512:	7ffb      	ldrb	r3, [r7, #31]
    5514:	69ba      	ldr	r2, [r7, #24]
    5516:	4413      	add	r3, r2
    5518:	2200      	movs	r2, #0
    551a:	701a      	strb	r2, [r3, #0]
}
    551c:	3720      	adds	r7, #32
    551e:	46bd      	mov	sp, r7
    5520:	bd80      	pop	{r7, pc}
    5522:	bf00      	nop
    5524:	00007408 	.word	0x00007408
    5528:	66666667 	.word	0x66666667

0000552c <ShiftRightAndFill>:
**         on the left side with a pattern
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void ShiftRightAndFill(uint8_t *dst, uint8_t fill, uint8_t nofFill)
{
    552c:	b480      	push	{r7}
    552e:	b085      	sub	sp, #20
    5530:	af00      	add	r7, sp, #0
    5532:	6078      	str	r0, [r7, #4]
    5534:	4613      	mov	r3, r2
    5536:	460a      	mov	r2, r1
    5538:	70fa      	strb	r2, [r7, #3]
    553a:	70bb      	strb	r3, [r7, #2]
  signed char i, j;

  j = 0;
    553c:	2300      	movs	r3, #0
    553e:	73bb      	strb	r3, [r7, #14]
  while(dst[j] != '\0') {
    5540:	e002      	b.n	5548 <ShiftRightAndFill+0x1c>
    j++;
    5542:	7bbb      	ldrb	r3, [r7, #14]
    5544:	3301      	adds	r3, #1
    5546:	73bb      	strb	r3, [r7, #14]
static void ShiftRightAndFill(uint8_t *dst, uint8_t fill, uint8_t nofFill)
{
  signed char i, j;

  j = 0;
  while(dst[j] != '\0') {
    5548:	f997 300e 	ldrsb.w	r3, [r7, #14]
    554c:	687a      	ldr	r2, [r7, #4]
    554e:	4413      	add	r3, r2
    5550:	781b      	ldrb	r3, [r3, #0]
    5552:	2b00      	cmp	r3, #0
    5554:	d1f5      	bne.n	5542 <ShiftRightAndFill+0x16>
    j++;
  }
  i = (signed char)nofFill;
    5556:	78bb      	ldrb	r3, [r7, #2]
    5558:	73fb      	strb	r3, [r7, #15]
  if (i==j) {
    555a:	f997 200f 	ldrsb.w	r2, [r7, #15]
    555e:	f997 300e 	ldrsb.w	r3, [r7, #14]
    5562:	429a      	cmp	r2, r3
    5564:	d028      	beq.n	55b8 <ShiftRightAndFill+0x8c>
    /* nothing to do, we are done */
  } else if (i>j) {
    5566:	f997 200f 	ldrsb.w	r2, [r7, #15]
    556a:	f997 300e 	ldrsb.w	r3, [r7, #14]
    556e:	429a      	cmp	r2, r3
    5570:	dd22      	ble.n	55b8 <ShiftRightAndFill+0x8c>
    while (j>=0) {
    5572:	e00f      	b.n	5594 <ShiftRightAndFill+0x68>
      dst[i] = dst[j];
    5574:	f997 300f 	ldrsb.w	r3, [r7, #15]
    5578:	687a      	ldr	r2, [r7, #4]
    557a:	4413      	add	r3, r2
    557c:	f997 200e 	ldrsb.w	r2, [r7, #14]
    5580:	6879      	ldr	r1, [r7, #4]
    5582:	440a      	add	r2, r1
    5584:	7812      	ldrb	r2, [r2, #0]
    5586:	701a      	strb	r2, [r3, #0]
      i--; j--;
    5588:	7bfb      	ldrb	r3, [r7, #15]
    558a:	3b01      	subs	r3, #1
    558c:	73fb      	strb	r3, [r7, #15]
    558e:	7bbb      	ldrb	r3, [r7, #14]
    5590:	3b01      	subs	r3, #1
    5592:	73bb      	strb	r3, [r7, #14]
  }
  i = (signed char)nofFill;
  if (i==j) {
    /* nothing to do, we are done */
  } else if (i>j) {
    while (j>=0) {
    5594:	f997 300e 	ldrsb.w	r3, [r7, #14]
    5598:	2b00      	cmp	r3, #0
    559a:	daeb      	bge.n	5574 <ShiftRightAndFill+0x48>
      dst[i] = dst[j];
      i--; j--;
    }
    while(i>=0) {
    559c:	e008      	b.n	55b0 <ShiftRightAndFill+0x84>
      dst[i] = fill;
    559e:	f997 300f 	ldrsb.w	r3, [r7, #15]
    55a2:	687a      	ldr	r2, [r7, #4]
    55a4:	4413      	add	r3, r2
    55a6:	78fa      	ldrb	r2, [r7, #3]
    55a8:	701a      	strb	r2, [r3, #0]
      i--;
    55aa:	7bfb      	ldrb	r3, [r7, #15]
    55ac:	3b01      	subs	r3, #1
    55ae:	73fb      	strb	r3, [r7, #15]
  } else if (i>j) {
    while (j>=0) {
      dst[i] = dst[j];
      i--; j--;
    }
    while(i>=0) {
    55b0:	f997 300f 	ldrsb.w	r3, [r7, #15]
    55b4:	2b00      	cmp	r3, #0
    55b6:	daf2      	bge.n	559e <ShiftRightAndFill+0x72>
      i--;
    }
  } else {
    /* hmmm, not enough space, return what we have, do nothing */
  }
}
    55b8:	3714      	adds	r7, #20
    55ba:	46bd      	mov	sp, r7
    55bc:	f85d 7b04 	ldr.w	r7, [sp], #4
    55c0:	4770      	bx	lr
    55c2:	bf00      	nop

000055c4 <UTIL1_Num16sToStrFormatted>:
  \param[in] val The 16bit signed number to add
  \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
*/
void UTIL1_Num16sToStrFormatted(uint8_t *dst, size_t dstSize, int16_t val, char fill, uint8_t nofFill)
{
    55c4:	b580      	push	{r7, lr}
    55c6:	b084      	sub	sp, #16
    55c8:	af00      	add	r7, sp, #0
    55ca:	60f8      	str	r0, [r7, #12]
    55cc:	60b9      	str	r1, [r7, #8]
    55ce:	80fa      	strh	r2, [r7, #6]
    55d0:	717b      	strb	r3, [r7, #5]
  UTIL1_Num16sToStr(dst, dstSize, val);
    55d2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    55d6:	68f8      	ldr	r0, [r7, #12]
    55d8:	68b9      	ldr	r1, [r7, #8]
    55da:	461a      	mov	r2, r3
    55dc:	f7ff ff04 	bl	53e8 <UTIL1_Num16sToStr>
  ShiftRightAndFill(dst, fill, nofFill);
    55e0:	797a      	ldrb	r2, [r7, #5]
    55e2:	7e3b      	ldrb	r3, [r7, #24]
    55e4:	68f8      	ldr	r0, [r7, #12]
    55e6:	4611      	mov	r1, r2
    55e8:	461a      	mov	r2, r3
    55ea:	f7ff ff9f 	bl	552c <ShiftRightAndFill>
}
    55ee:	3710      	adds	r7, #16
    55f0:	46bd      	mov	sp, r7
    55f2:	bd80      	pop	{r7, pc}

000055f4 <UTIL1_Num16uToStrFormatted>:
  \param[in] val The 16bit unsigned number to add
  \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
*/
void UTIL1_Num16uToStrFormatted(uint8_t *dst, size_t dstSize, uint16_t val, char fill, uint8_t nofFill)
{
    55f4:	b580      	push	{r7, lr}
    55f6:	b084      	sub	sp, #16
    55f8:	af00      	add	r7, sp, #0
    55fa:	60f8      	str	r0, [r7, #12]
    55fc:	60b9      	str	r1, [r7, #8]
    55fe:	80fa      	strh	r2, [r7, #6]
    5600:	717b      	strb	r3, [r7, #5]
  UTIL1_Num16uToStr(dst, dstSize, val);
    5602:	88fb      	ldrh	r3, [r7, #6]
    5604:	68f8      	ldr	r0, [r7, #12]
    5606:	68b9      	ldr	r1, [r7, #8]
    5608:	461a      	mov	r2, r3
    560a:	f7ff fe79 	bl	5300 <UTIL1_Num16uToStr>
  ShiftRightAndFill(dst, fill, nofFill);
    560e:	797a      	ldrb	r2, [r7, #5]
    5610:	7e3b      	ldrb	r3, [r7, #24]
    5612:	68f8      	ldr	r0, [r7, #12]
    5614:	4611      	mov	r1, r2
    5616:	461a      	mov	r2, r3
    5618:	f7ff ff88 	bl	552c <ShiftRightAndFill>
}
    561c:	3710      	adds	r7, #16
    561e:	46bd      	mov	sp, r7
    5620:	bd80      	pop	{r7, pc}
    5622:	bf00      	nop

00005624 <UTIL1_Num32uToStrFormatted>:
  \param[in] val The 32bit unsigned number to add
  \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
*/
void UTIL1_Num32uToStrFormatted(uint8_t *dst, size_t dstSize, uint32_t val, char fill, uint8_t nofFill)
{
    5624:	b580      	push	{r7, lr}
    5626:	b084      	sub	sp, #16
    5628:	af00      	add	r7, sp, #0
    562a:	60f8      	str	r0, [r7, #12]
    562c:	60b9      	str	r1, [r7, #8]
    562e:	607a      	str	r2, [r7, #4]
    5630:	70fb      	strb	r3, [r7, #3]
  UTIL1_Num32uToStr(dst, dstSize, val);
    5632:	68f8      	ldr	r0, [r7, #12]
    5634:	68b9      	ldr	r1, [r7, #8]
    5636:	687a      	ldr	r2, [r7, #4]
    5638:	f000 fa8e 	bl	5b58 <UTIL1_Num32uToStr>
  ShiftRightAndFill(dst, fill, nofFill);
    563c:	78fa      	ldrb	r2, [r7, #3]
    563e:	7e3b      	ldrb	r3, [r7, #24]
    5640:	68f8      	ldr	r0, [r7, #12]
    5642:	4611      	mov	r1, r2
    5644:	461a      	mov	r2, r3
    5646:	f7ff ff71 	bl	552c <ShiftRightAndFill>
}
    564a:	3710      	adds	r7, #16
    564c:	46bd      	mov	sp, r7
    564e:	bd80      	pop	{r7, pc}

00005650 <UTIL1_Num32sToStrFormatted>:
  \param[in] val The 32bit signed number to add
  \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
  \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
*/
void UTIL1_Num32sToStrFormatted(uint8_t *dst, size_t dstSize, int32_t val, char fill, uint8_t nofFill)
{
    5650:	b580      	push	{r7, lr}
    5652:	b084      	sub	sp, #16
    5654:	af00      	add	r7, sp, #0
    5656:	60f8      	str	r0, [r7, #12]
    5658:	60b9      	str	r1, [r7, #8]
    565a:	607a      	str	r2, [r7, #4]
    565c:	70fb      	strb	r3, [r7, #3]
  UTIL1_Num32sToStr(dst, dstSize, val);
    565e:	68f8      	ldr	r0, [r7, #12]
    5660:	68b9      	ldr	r1, [r7, #8]
    5662:	687a      	ldr	r2, [r7, #4]
    5664:	f000 f9de 	bl	5a24 <UTIL1_Num32sToStr>
  ShiftRightAndFill(dst, fill, nofFill);
    5668:	78fa      	ldrb	r2, [r7, #3]
    566a:	7e3b      	ldrb	r3, [r7, #24]
    566c:	68f8      	ldr	r0, [r7, #12]
    566e:	4611      	mov	r1, r2
    5670:	461a      	mov	r2, r3
    5672:	f7ff ff5b 	bl	552c <ShiftRightAndFill>
}
    5676:	3710      	adds	r7, #16
    5678:	46bd      	mov	sp, r7
    567a:	bd80      	pop	{r7, pc}

0000567c <UTIL1_strcatNum8u>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] val The 8bit unsigned number to add
  */
void UTIL1_strcatNum8u(uint8_t *dst, size_t dstSize, uint8_t val)
{
    567c:	b580      	push	{r7, lr}
    567e:	b086      	sub	sp, #24
    5680:	af00      	add	r7, sp, #0
    5682:	60f8      	str	r0, [r7, #12]
    5684:	60b9      	str	r1, [r7, #8]
    5686:	4613      	mov	r3, r2
    5688:	71fb      	strb	r3, [r7, #7]
  unsigned char buf[sizeof("256")]; /* maximum buffer size we need */

  UTIL1_Num8uToStr(buf, sizeof(buf), val);
    568a:	f107 0214 	add.w	r2, r7, #20
    568e:	79fb      	ldrb	r3, [r7, #7]
    5690:	4610      	mov	r0, r2
    5692:	2104      	movs	r1, #4
    5694:	461a      	mov	r2, r3
    5696:	f7ff fe0d 	bl	52b4 <UTIL1_Num8uToStr>
  UTIL1_strcat(dst, dstSize, buf);
    569a:	f107 0314 	add.w	r3, r7, #20
    569e:	68f8      	ldr	r0, [r7, #12]
    56a0:	68b9      	ldr	r1, [r7, #8]
    56a2:	461a      	mov	r2, r3
    56a4:	f7ff fdac 	bl	5200 <UTIL1_strcat>
}
    56a8:	3718      	adds	r7, #24
    56aa:	46bd      	mov	sp, r7
    56ac:	bd80      	pop	{r7, pc}
    56ae:	bf00      	nop

000056b0 <UTIL1_strcatNum8s>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] val The 8bit signed number to add
  */
void UTIL1_strcatNum8s(uint8_t *dst, size_t dstSize, signed char val)
{
    56b0:	b580      	push	{r7, lr}
    56b2:	b086      	sub	sp, #24
    56b4:	af00      	add	r7, sp, #0
    56b6:	60f8      	str	r0, [r7, #12]
    56b8:	60b9      	str	r1, [r7, #8]
    56ba:	4613      	mov	r3, r2
    56bc:	71fb      	strb	r3, [r7, #7]
  unsigned char buf[sizeof("-128")]; /* maximum buffer size we need */

  UTIL1_Num8sToStr(buf, sizeof(buf), val);
    56be:	f107 0210 	add.w	r2, r7, #16
    56c2:	f997 3007 	ldrsb.w	r3, [r7, #7]
    56c6:	4610      	mov	r0, r2
    56c8:	2105      	movs	r1, #5
    56ca:	461a      	mov	r2, r3
    56cc:	f7ff fe04 	bl	52d8 <UTIL1_Num8sToStr>
  UTIL1_strcat(dst, dstSize, buf);
    56d0:	f107 0310 	add.w	r3, r7, #16
    56d4:	68f8      	ldr	r0, [r7, #12]
    56d6:	68b9      	ldr	r1, [r7, #8]
    56d8:	461a      	mov	r2, r3
    56da:	f7ff fd91 	bl	5200 <UTIL1_strcat>
}
    56de:	3718      	adds	r7, #24
    56e0:	46bd      	mov	sp, r7
    56e2:	bd80      	pop	{r7, pc}

000056e4 <UTIL1_strcatNum16u>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] val The 16bit unsigned number to add
  */
void UTIL1_strcatNum16u(uint8_t *dst, size_t dstSize, uint16_t val)
{
    56e4:	b580      	push	{r7, lr}
    56e6:	b086      	sub	sp, #24
    56e8:	af00      	add	r7, sp, #0
    56ea:	60f8      	str	r0, [r7, #12]
    56ec:	60b9      	str	r1, [r7, #8]
    56ee:	4613      	mov	r3, r2
    56f0:	80fb      	strh	r3, [r7, #6]
  unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */

  UTIL1_Num16uToStr(buf, sizeof(buf), val);
    56f2:	f107 0210 	add.w	r2, r7, #16
    56f6:	88fb      	ldrh	r3, [r7, #6]
    56f8:	4610      	mov	r0, r2
    56fa:	2106      	movs	r1, #6
    56fc:	461a      	mov	r2, r3
    56fe:	f7ff fdff 	bl	5300 <UTIL1_Num16uToStr>
  UTIL1_strcat(dst, dstSize, buf);
    5702:	f107 0310 	add.w	r3, r7, #16
    5706:	68f8      	ldr	r0, [r7, #12]
    5708:	68b9      	ldr	r1, [r7, #8]
    570a:	461a      	mov	r2, r3
    570c:	f7ff fd78 	bl	5200 <UTIL1_strcat>
}
    5710:	3718      	adds	r7, #24
    5712:	46bd      	mov	sp, r7
    5714:	bd80      	pop	{r7, pc}
    5716:	bf00      	nop

00005718 <UTIL1_strcatNum16s>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] val The 16bit signed number to add
  */
void UTIL1_strcatNum16s(uint8_t *dst, size_t dstSize, int16_t val)
{
    5718:	b580      	push	{r7, lr}
    571a:	b086      	sub	sp, #24
    571c:	af00      	add	r7, sp, #0
    571e:	60f8      	str	r0, [r7, #12]
    5720:	60b9      	str	r1, [r7, #8]
    5722:	4613      	mov	r3, r2
    5724:	80fb      	strh	r3, [r7, #6]
  unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */

  UTIL1_Num16sToStr(buf, sizeof(buf), val);
    5726:	f107 0210 	add.w	r2, r7, #16
    572a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
    572e:	4610      	mov	r0, r2
    5730:	2107      	movs	r1, #7
    5732:	461a      	mov	r2, r3
    5734:	f7ff fe58 	bl	53e8 <UTIL1_Num16sToStr>
  UTIL1_strcat(dst, dstSize, buf);
    5738:	f107 0310 	add.w	r3, r7, #16
    573c:	68f8      	ldr	r0, [r7, #12]
    573e:	68b9      	ldr	r1, [r7, #8]
    5740:	461a      	mov	r2, r3
    5742:	f7ff fd5d 	bl	5200 <UTIL1_strcat>
}
    5746:	3718      	adds	r7, #24
    5748:	46bd      	mov	sp, r7
    574a:	bd80      	pop	{r7, pc}

0000574c <UTIL1_strcatNum16uFormatted>:
  \param[in] val The 16bit unsigned number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void UTIL1_strcatNum16uFormatted(uint8_t *dst, size_t dstSize, uint16_t val, char fill, uint8_t nofFill)
{
    574c:	b580      	push	{r7, lr}
    574e:	b088      	sub	sp, #32
    5750:	af02      	add	r7, sp, #8
    5752:	60f8      	str	r0, [r7, #12]
    5754:	60b9      	str	r1, [r7, #8]
    5756:	80fa      	strh	r2, [r7, #6]
    5758:	717b      	strb	r3, [r7, #5]
  unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */

  UTIL1_Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
    575a:	f107 0110 	add.w	r1, r7, #16
    575e:	88fa      	ldrh	r2, [r7, #6]
    5760:	797b      	ldrb	r3, [r7, #5]
    5762:	f897 0020 	ldrb.w	r0, [r7, #32]
    5766:	9000      	str	r0, [sp, #0]
    5768:	4608      	mov	r0, r1
    576a:	68b9      	ldr	r1, [r7, #8]
    576c:	f7ff ff42 	bl	55f4 <UTIL1_Num16uToStrFormatted>
  UTIL1_strcat(dst, dstSize, buf);
    5770:	f107 0310 	add.w	r3, r7, #16
    5774:	68f8      	ldr	r0, [r7, #12]
    5776:	68b9      	ldr	r1, [r7, #8]
    5778:	461a      	mov	r2, r3
    577a:	f7ff fd41 	bl	5200 <UTIL1_strcat>
}
    577e:	3718      	adds	r7, #24
    5780:	46bd      	mov	sp, r7
    5782:	bd80      	pop	{r7, pc}

00005784 <UTIL1_strcatNum16sFormatted>:
  \param[in] val The 16bit signed number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void UTIL1_strcatNum16sFormatted(uint8_t *dst, size_t dstSize, int16_t val, char fill, uint8_t nofFill)
{
    5784:	b580      	push	{r7, lr}
    5786:	b088      	sub	sp, #32
    5788:	af02      	add	r7, sp, #8
    578a:	60f8      	str	r0, [r7, #12]
    578c:	60b9      	str	r1, [r7, #8]
    578e:	80fa      	strh	r2, [r7, #6]
    5790:	717b      	strb	r3, [r7, #5]
  unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */

  UTIL1_Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
    5792:	f107 0110 	add.w	r1, r7, #16
    5796:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
    579a:	797b      	ldrb	r3, [r7, #5]
    579c:	f897 0020 	ldrb.w	r0, [r7, #32]
    57a0:	9000      	str	r0, [sp, #0]
    57a2:	4608      	mov	r0, r1
    57a4:	68b9      	ldr	r1, [r7, #8]
    57a6:	f7ff ff0d 	bl	55c4 <UTIL1_Num16sToStrFormatted>
  UTIL1_strcat(dst, dstSize, buf);
    57aa:	f107 0310 	add.w	r3, r7, #16
    57ae:	68f8      	ldr	r0, [r7, #12]
    57b0:	68b9      	ldr	r1, [r7, #8]
    57b2:	461a      	mov	r2, r3
    57b4:	f7ff fd24 	bl	5200 <UTIL1_strcat>
}
    57b8:	3718      	adds	r7, #24
    57ba:	46bd      	mov	sp, r7
    57bc:	bd80      	pop	{r7, pc}
    57be:	bf00      	nop

000057c0 <UTIL1_strcatNum32uFormatted>:
  \param[in] val The 32bit unsigned number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void UTIL1_strcatNum32uFormatted(uint8_t *dst, size_t dstSize, uint32_t val, char fill, uint8_t nofFill)
{
    57c0:	b580      	push	{r7, lr}
    57c2:	b08a      	sub	sp, #40	; 0x28
    57c4:	af02      	add	r7, sp, #8
    57c6:	60f8      	str	r0, [r7, #12]
    57c8:	60b9      	str	r1, [r7, #8]
    57ca:	607a      	str	r2, [r7, #4]
    57cc:	70fb      	strb	r3, [r7, #3]
  unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */

  UTIL1_Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
    57ce:	f107 0214 	add.w	r2, r7, #20
    57d2:	78fb      	ldrb	r3, [r7, #3]
    57d4:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
    57d8:	9100      	str	r1, [sp, #0]
    57da:	4610      	mov	r0, r2
    57dc:	68b9      	ldr	r1, [r7, #8]
    57de:	687a      	ldr	r2, [r7, #4]
    57e0:	f7ff ff20 	bl	5624 <UTIL1_Num32uToStrFormatted>
  UTIL1_strcat(dst, dstSize, buf);
    57e4:	f107 0314 	add.w	r3, r7, #20
    57e8:	68f8      	ldr	r0, [r7, #12]
    57ea:	68b9      	ldr	r1, [r7, #8]
    57ec:	461a      	mov	r2, r3
    57ee:	f7ff fd07 	bl	5200 <UTIL1_strcat>
}
    57f2:	3720      	adds	r7, #32
    57f4:	46bd      	mov	sp, r7
    57f6:	bd80      	pop	{r7, pc}

000057f8 <UTIL1_strcatNum32sFormatted>:
  \param[in] val The 32bit signed number to add
  \param[in] fill Fill character
  \param[in] nofFill Number of fill characters
  */
void UTIL1_strcatNum32sFormatted(uint8_t *dst, size_t dstSize, int32_t val, char fill, uint8_t nofFill)
{
    57f8:	b580      	push	{r7, lr}
    57fa:	b08a      	sub	sp, #40	; 0x28
    57fc:	af02      	add	r7, sp, #8
    57fe:	60f8      	str	r0, [r7, #12]
    5800:	60b9      	str	r1, [r7, #8]
    5802:	607a      	str	r2, [r7, #4]
    5804:	70fb      	strb	r3, [r7, #3]
  unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */

  UTIL1_Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
    5806:	f107 0214 	add.w	r2, r7, #20
    580a:	78fb      	ldrb	r3, [r7, #3]
    580c:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
    5810:	9100      	str	r1, [sp, #0]
    5812:	4610      	mov	r0, r2
    5814:	68b9      	ldr	r1, [r7, #8]
    5816:	687a      	ldr	r2, [r7, #4]
    5818:	f7ff ff1a 	bl	5650 <UTIL1_Num32sToStrFormatted>
  UTIL1_strcat(dst, dstSize, buf);
    581c:	f107 0314 	add.w	r3, r7, #20
    5820:	68f8      	ldr	r0, [r7, #12]
    5822:	68b9      	ldr	r1, [r7, #8]
    5824:	461a      	mov	r2, r3
    5826:	f7ff fceb 	bl	5200 <UTIL1_strcat>
}
    582a:	3720      	adds	r7, #32
    582c:	46bd      	mov	sp, r7
    582e:	bd80      	pop	{r7, pc}

00005830 <UTIL1_strcatNum8Hex>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] num The 8bit number to add
  */
void UTIL1_strcatNum8Hex(uint8_t *dst, size_t dstSize, uint8_t num)
{
    5830:	b580      	push	{r7, lr}
    5832:	b086      	sub	sp, #24
    5834:	af00      	add	r7, sp, #0
    5836:	60f8      	str	r0, [r7, #12]
    5838:	60b9      	str	r1, [r7, #8]
    583a:	4613      	mov	r3, r2
    583c:	71fb      	strb	r3, [r7, #7]
  unsigned char buf[sizeof("FF")]; /* maximum buffer size we need */
  unsigned char hex;

  buf[2] = '\0';
    583e:	2300      	movs	r3, #0
    5840:	75bb      	strb	r3, [r7, #22]
  hex = (char)(num & 0x0F);
    5842:	79fb      	ldrb	r3, [r7, #7]
    5844:	f003 030f 	and.w	r3, r3, #15
    5848:	75fb      	strb	r3, [r7, #23]
  buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    584a:	7dfb      	ldrb	r3, [r7, #23]
    584c:	2b09      	cmp	r3, #9
    584e:	d801      	bhi.n	5854 <UTIL1_strcatNum8Hex+0x24>
    5850:	2330      	movs	r3, #48	; 0x30
    5852:	e000      	b.n	5856 <UTIL1_strcatNum8Hex+0x26>
    5854:	2337      	movs	r3, #55	; 0x37
    5856:	7dfa      	ldrb	r2, [r7, #23]
    5858:	4413      	add	r3, r2
    585a:	b2db      	uxtb	r3, r3
    585c:	757b      	strb	r3, [r7, #21]
  hex = (char)((num>>4) & 0x0F);
    585e:	79fb      	ldrb	r3, [r7, #7]
    5860:	091b      	lsrs	r3, r3, #4
    5862:	75fb      	strb	r3, [r7, #23]
  buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    5864:	7dfb      	ldrb	r3, [r7, #23]
    5866:	2b09      	cmp	r3, #9
    5868:	d801      	bhi.n	586e <UTIL1_strcatNum8Hex+0x3e>
    586a:	2330      	movs	r3, #48	; 0x30
    586c:	e000      	b.n	5870 <UTIL1_strcatNum8Hex+0x40>
    586e:	2337      	movs	r3, #55	; 0x37
    5870:	7dfa      	ldrb	r2, [r7, #23]
    5872:	4413      	add	r3, r2
    5874:	b2db      	uxtb	r3, r3
    5876:	753b      	strb	r3, [r7, #20]
  UTIL1_strcat(dst, dstSize, buf);
    5878:	f107 0314 	add.w	r3, r7, #20
    587c:	68f8      	ldr	r0, [r7, #12]
    587e:	68b9      	ldr	r1, [r7, #8]
    5880:	461a      	mov	r2, r3
    5882:	f7ff fcbd 	bl	5200 <UTIL1_strcat>
}
    5886:	3718      	adds	r7, #24
    5888:	46bd      	mov	sp, r7
    588a:	bd80      	pop	{r7, pc}

0000588c <UTIL1_strcatNum16Hex>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] num The 16bit number to add
  */
void UTIL1_strcatNum16Hex(uint8_t *dst, size_t dstSize, uint16_t num)
{
    588c:	b580      	push	{r7, lr}
    588e:	b086      	sub	sp, #24
    5890:	af00      	add	r7, sp, #0
    5892:	60f8      	str	r0, [r7, #12]
    5894:	60b9      	str	r1, [r7, #8]
    5896:	4613      	mov	r3, r2
    5898:	80fb      	strh	r3, [r7, #6]
  unsigned char buf[sizeof("FFFF")]; /* maximum buffer size we need */
  unsigned char hex;
  int8_t i;

  buf[4] = '\0';
    589a:	2300      	movs	r3, #0
    589c:	753b      	strb	r3, [r7, #20]
  i = 3;
    589e:	2303      	movs	r3, #3
    58a0:	75fb      	strb	r3, [r7, #23]
  do {
    hex = (char)(num & 0x0F);
    58a2:	88fb      	ldrh	r3, [r7, #6]
    58a4:	b2db      	uxtb	r3, r3
    58a6:	f003 030f 	and.w	r3, r3, #15
    58aa:	75bb      	strb	r3, [r7, #22]
    buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    58ac:	f997 1017 	ldrsb.w	r1, [r7, #23]
    58b0:	7dbb      	ldrb	r3, [r7, #22]
    58b2:	2b09      	cmp	r3, #9
    58b4:	d801      	bhi.n	58ba <UTIL1_strcatNum16Hex+0x2e>
    58b6:	2330      	movs	r3, #48	; 0x30
    58b8:	e000      	b.n	58bc <UTIL1_strcatNum16Hex+0x30>
    58ba:	2337      	movs	r3, #55	; 0x37
    58bc:	7dba      	ldrb	r2, [r7, #22]
    58be:	4413      	add	r3, r2
    58c0:	b2da      	uxtb	r2, r3
    58c2:	f107 0318 	add.w	r3, r7, #24
    58c6:	440b      	add	r3, r1
    58c8:	f803 2c08 	strb.w	r2, [r3, #-8]
    num >>= 4;                          /* next nibble */
    58cc:	88fb      	ldrh	r3, [r7, #6]
    58ce:	091b      	lsrs	r3, r3, #4
    58d0:	80fb      	strh	r3, [r7, #6]
    i--;
    58d2:	7dfb      	ldrb	r3, [r7, #23]
    58d4:	3b01      	subs	r3, #1
    58d6:	75fb      	strb	r3, [r7, #23]
  } while (i>=0);
    58d8:	f997 3017 	ldrsb.w	r3, [r7, #23]
    58dc:	2b00      	cmp	r3, #0
    58de:	dae0      	bge.n	58a2 <UTIL1_strcatNum16Hex+0x16>
  UTIL1_strcat(dst, dstSize, buf);
    58e0:	f107 0310 	add.w	r3, r7, #16
    58e4:	68f8      	ldr	r0, [r7, #12]
    58e6:	68b9      	ldr	r1, [r7, #8]
    58e8:	461a      	mov	r2, r3
    58ea:	f7ff fc89 	bl	5200 <UTIL1_strcat>
}
    58ee:	3718      	adds	r7, #24
    58f0:	46bd      	mov	sp, r7
    58f2:	bd80      	pop	{r7, pc}

000058f4 <UTIL1_strcatNum24Hex>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] num The 24bit number to add
  */
void UTIL1_strcatNum24Hex(uint8_t *dst, size_t dstSize, uint32_t num)
{
    58f4:	b580      	push	{r7, lr}
    58f6:	b088      	sub	sp, #32
    58f8:	af00      	add	r7, sp, #0
    58fa:	60f8      	str	r0, [r7, #12]
    58fc:	60b9      	str	r1, [r7, #8]
    58fe:	607a      	str	r2, [r7, #4]
  unsigned char buf[sizeof("FFFFFF")]; /* maximum buffer size we need */
  unsigned char hex;
  int8_t i;

  buf[6] = '\0';
    5900:	2300      	movs	r3, #0
    5902:	76bb      	strb	r3, [r7, #26]
  i = 5;
    5904:	2305      	movs	r3, #5
    5906:	77fb      	strb	r3, [r7, #31]
  do {
    hex = (char)(num & 0x0F);
    5908:	687b      	ldr	r3, [r7, #4]
    590a:	b2db      	uxtb	r3, r3
    590c:	f003 030f 	and.w	r3, r3, #15
    5910:	77bb      	strb	r3, [r7, #30]
    buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    5912:	f997 101f 	ldrsb.w	r1, [r7, #31]
    5916:	7fbb      	ldrb	r3, [r7, #30]
    5918:	2b09      	cmp	r3, #9
    591a:	d801      	bhi.n	5920 <UTIL1_strcatNum24Hex+0x2c>
    591c:	2330      	movs	r3, #48	; 0x30
    591e:	e000      	b.n	5922 <UTIL1_strcatNum24Hex+0x2e>
    5920:	2337      	movs	r3, #55	; 0x37
    5922:	7fba      	ldrb	r2, [r7, #30]
    5924:	4413      	add	r3, r2
    5926:	b2da      	uxtb	r2, r3
    5928:	f107 0320 	add.w	r3, r7, #32
    592c:	440b      	add	r3, r1
    592e:	f803 2c0c 	strb.w	r2, [r3, #-12]
    num >>= 4;                          /* next nibble */
    5932:	687b      	ldr	r3, [r7, #4]
    5934:	091b      	lsrs	r3, r3, #4
    5936:	607b      	str	r3, [r7, #4]
    i--;
    5938:	7ffb      	ldrb	r3, [r7, #31]
    593a:	3b01      	subs	r3, #1
    593c:	77fb      	strb	r3, [r7, #31]
  } while (i>=0);
    593e:	f997 301f 	ldrsb.w	r3, [r7, #31]
    5942:	2b00      	cmp	r3, #0
    5944:	dae0      	bge.n	5908 <UTIL1_strcatNum24Hex+0x14>
  UTIL1_strcat(dst, dstSize, buf);
    5946:	f107 0314 	add.w	r3, r7, #20
    594a:	68f8      	ldr	r0, [r7, #12]
    594c:	68b9      	ldr	r1, [r7, #8]
    594e:	461a      	mov	r2, r3
    5950:	f7ff fc56 	bl	5200 <UTIL1_strcat>
}
    5954:	3720      	adds	r7, #32
    5956:	46bd      	mov	sp, r7
    5958:	bd80      	pop	{r7, pc}
    595a:	bf00      	nop

0000595c <UTIL1_strcatNum32Hex>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] num The 32bit number to add
  */
void UTIL1_strcatNum32Hex(uint8_t *dst, size_t dstSize, uint32_t num)
{
    595c:	b580      	push	{r7, lr}
    595e:	b088      	sub	sp, #32
    5960:	af00      	add	r7, sp, #0
    5962:	60f8      	str	r0, [r7, #12]
    5964:	60b9      	str	r1, [r7, #8]
    5966:	607a      	str	r2, [r7, #4]
  unsigned char buf[sizeof("FFFFFFFF")]; /* maximum buffer size we need */
  unsigned char hex;
  int8_t i;

  buf[8] = '\0';
    5968:	2300      	movs	r3, #0
    596a:	773b      	strb	r3, [r7, #28]
  i = 7;
    596c:	2307      	movs	r3, #7
    596e:	77fb      	strb	r3, [r7, #31]
  do {
    hex = (char)(num & 0x0F);
    5970:	687b      	ldr	r3, [r7, #4]
    5972:	b2db      	uxtb	r3, r3
    5974:	f003 030f 	and.w	r3, r3, #15
    5978:	77bb      	strb	r3, [r7, #30]
    buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
    597a:	f997 101f 	ldrsb.w	r1, [r7, #31]
    597e:	7fbb      	ldrb	r3, [r7, #30]
    5980:	2b09      	cmp	r3, #9
    5982:	d801      	bhi.n	5988 <UTIL1_strcatNum32Hex+0x2c>
    5984:	2330      	movs	r3, #48	; 0x30
    5986:	e000      	b.n	598a <UTIL1_strcatNum32Hex+0x2e>
    5988:	2337      	movs	r3, #55	; 0x37
    598a:	7fba      	ldrb	r2, [r7, #30]
    598c:	4413      	add	r3, r2
    598e:	b2da      	uxtb	r2, r3
    5990:	f107 0320 	add.w	r3, r7, #32
    5994:	440b      	add	r3, r1
    5996:	f803 2c0c 	strb.w	r2, [r3, #-12]
    num >>= 4;                          /* next nibble */
    599a:	687b      	ldr	r3, [r7, #4]
    599c:	091b      	lsrs	r3, r3, #4
    599e:	607b      	str	r3, [r7, #4]
    i--;
    59a0:	7ffb      	ldrb	r3, [r7, #31]
    59a2:	3b01      	subs	r3, #1
    59a4:	77fb      	strb	r3, [r7, #31]
  } while (i>=0);
    59a6:	f997 301f 	ldrsb.w	r3, [r7, #31]
    59aa:	2b00      	cmp	r3, #0
    59ac:	dae0      	bge.n	5970 <UTIL1_strcatNum32Hex+0x14>
  UTIL1_strcat(dst, dstSize, buf);
    59ae:	f107 0314 	add.w	r3, r7, #20
    59b2:	68f8      	ldr	r0, [r7, #12]
    59b4:	68b9      	ldr	r1, [r7, #8]
    59b6:	461a      	mov	r2, r3
    59b8:	f7ff fc22 	bl	5200 <UTIL1_strcat>
}
    59bc:	3720      	adds	r7, #32
    59be:	46bd      	mov	sp, r7
    59c0:	bd80      	pop	{r7, pc}
    59c2:	bf00      	nop

000059c4 <UTIL1_strcatNum32s>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] val The 32bit number to add
  */
void UTIL1_strcatNum32s(uint8_t *dst, size_t dstSize, int32_t val)
{
    59c4:	b580      	push	{r7, lr}
    59c6:	b088      	sub	sp, #32
    59c8:	af00      	add	r7, sp, #0
    59ca:	60f8      	str	r0, [r7, #12]
    59cc:	60b9      	str	r1, [r7, #8]
    59ce:	607a      	str	r2, [r7, #4]
  unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */

  UTIL1_Num32sToStr(buf, sizeof(buf), val);
    59d0:	f107 0314 	add.w	r3, r7, #20
    59d4:	4618      	mov	r0, r3
    59d6:	210c      	movs	r1, #12
    59d8:	687a      	ldr	r2, [r7, #4]
    59da:	f000 f823 	bl	5a24 <UTIL1_Num32sToStr>
  UTIL1_strcat(dst, dstSize, buf);
    59de:	f107 0314 	add.w	r3, r7, #20
    59e2:	68f8      	ldr	r0, [r7, #12]
    59e4:	68b9      	ldr	r1, [r7, #8]
    59e6:	461a      	mov	r2, r3
    59e8:	f7ff fc0a 	bl	5200 <UTIL1_strcat>
}
    59ec:	3720      	adds	r7, #32
    59ee:	46bd      	mov	sp, r7
    59f0:	bd80      	pop	{r7, pc}
    59f2:	bf00      	nop

000059f4 <UTIL1_strcatNum32u>:
  \param[in,out] dst Start of buffer, where to append the number string
  \param[in] dstSize The size of the buffer, including the zero uint8_t
  \param[in] val The 32bit unsigned number to add
  */
void UTIL1_strcatNum32u(uint8_t *dst, size_t dstSize, uint32_t val)
{
    59f4:	b580      	push	{r7, lr}
    59f6:	b088      	sub	sp, #32
    59f8:	af00      	add	r7, sp, #0
    59fa:	60f8      	str	r0, [r7, #12]
    59fc:	60b9      	str	r1, [r7, #8]
    59fe:	607a      	str	r2, [r7, #4]
  unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */

  UTIL1_Num32uToStr(buf, sizeof(buf), val);
    5a00:	f107 0314 	add.w	r3, r7, #20
    5a04:	4618      	mov	r0, r3
    5a06:	210b      	movs	r1, #11
    5a08:	687a      	ldr	r2, [r7, #4]
    5a0a:	f000 f8a5 	bl	5b58 <UTIL1_Num32uToStr>
  UTIL1_strcat(dst, dstSize, buf);
    5a0e:	f107 0314 	add.w	r3, r7, #20
    5a12:	68f8      	ldr	r0, [r7, #12]
    5a14:	68b9      	ldr	r1, [r7, #8]
    5a16:	461a      	mov	r2, r3
    5a18:	f7ff fbf2 	bl	5200 <UTIL1_strcat>
}
    5a1c:	3720      	adds	r7, #32
    5a1e:	46bd      	mov	sp, r7
    5a20:	bd80      	pop	{r7, pc}
    5a22:	bf00      	nop

00005a24 <UTIL1_Num32sToStr>:
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in uint8_ts.
  \param[in] val 32bit signed number to convert.
 */
void UTIL1_Num32sToStr(uint8_t *dst, size_t dstSize, int32_t val)
{
    5a24:	b580      	push	{r7, lr}
    5a26:	b088      	sub	sp, #32
    5a28:	af00      	add	r7, sp, #0
    5a2a:	60f8      	str	r0, [r7, #12]
    5a2c:	60b9      	str	r1, [r7, #8]
    5a2e:	607a      	str	r2, [r7, #4]
  unsigned char *ptr = ((unsigned char *)dst);
    5a30:	68fb      	ldr	r3, [r7, #12]
    5a32:	61bb      	str	r3, [r7, #24]
  unsigned char i=0, j;
    5a34:	2300      	movs	r3, #0
    5a36:	77fb      	strb	r3, [r7, #31]
  unsigned char tmp;
  unsigned char sign = (unsigned char)(val < 0);
    5a38:	687b      	ldr	r3, [r7, #4]
    5a3a:	0fdb      	lsrs	r3, r3, #31
    5a3c:	b2db      	uxtb	r3, r3
    5a3e:	75fb      	strb	r3, [r7, #23]

  if (val==(int32_t)(0x80000000)) { /* special case 0x80000000/-2147483648: prevent overflow below. */
    5a40:	687b      	ldr	r3, [r7, #4]
    5a42:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    5a46:	d105      	bne.n	5a54 <UTIL1_Num32sToStr+0x30>
    UTIL1_strcpy(dst, dstSize, (unsigned char*)"-2147483648");
    5a48:	68f8      	ldr	r0, [r7, #12]
    5a4a:	68b9      	ldr	r1, [r7, #8]
    5a4c:	4a40      	ldr	r2, [pc, #256]	; (5b50 <UTIL1_Num32sToStr+0x12c>)
    5a4e:	f7ff fbb3 	bl	51b8 <UTIL1_strcpy>
    return;
    5a52:	e079      	b.n	5b48 <UTIL1_Num32sToStr+0x124>
  }
  dstSize--; /* for zero uint8_t */
    5a54:	68bb      	ldr	r3, [r7, #8]
    5a56:	3b01      	subs	r3, #1
    5a58:	60bb      	str	r3, [r7, #8]
  if (sign) {
    5a5a:	7dfb      	ldrb	r3, [r7, #23]
    5a5c:	2b00      	cmp	r3, #0
    5a5e:	d002      	beq.n	5a66 <UTIL1_Num32sToStr+0x42>
    val = -val;
    5a60:	687b      	ldr	r3, [r7, #4]
    5a62:	425b      	negs	r3, r3
    5a64:	607b      	str	r3, [r7, #4]
  }
  if (val == 0 && dstSize > 0){
    5a66:	687b      	ldr	r3, [r7, #4]
    5a68:	2b00      	cmp	r3, #0
    5a6a:	d10d      	bne.n	5a88 <UTIL1_Num32sToStr+0x64>
    5a6c:	68bb      	ldr	r3, [r7, #8]
    5a6e:	2b00      	cmp	r3, #0
    5a70:	d00a      	beq.n	5a88 <UTIL1_Num32sToStr+0x64>
    ptr[i++] = '0';
    5a72:	7ffb      	ldrb	r3, [r7, #31]
    5a74:	1c5a      	adds	r2, r3, #1
    5a76:	77fa      	strb	r2, [r7, #31]
    5a78:	69ba      	ldr	r2, [r7, #24]
    5a7a:	4413      	add	r3, r2
    5a7c:	2230      	movs	r2, #48	; 0x30
    5a7e:	701a      	strb	r2, [r3, #0]
    dstSize--;
    5a80:	68bb      	ldr	r3, [r7, #8]
    5a82:	3b01      	subs	r3, #1
    5a84:	60bb      	str	r3, [r7, #8]
  }
  while (val > 0 && dstSize > 0) {
    5a86:	e020      	b.n	5aca <UTIL1_Num32sToStr+0xa6>
    5a88:	e01f      	b.n	5aca <UTIL1_Num32sToStr+0xa6>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    5a8a:	7ffb      	ldrb	r3, [r7, #31]
    5a8c:	1c5a      	adds	r2, r3, #1
    5a8e:	77fa      	strb	r2, [r7, #31]
    5a90:	69ba      	ldr	r2, [r7, #24]
    5a92:	18d0      	adds	r0, r2, r3
    5a94:	6879      	ldr	r1, [r7, #4]
    5a96:	4b2f      	ldr	r3, [pc, #188]	; (5b54 <UTIL1_Num32sToStr+0x130>)
    5a98:	fb83 2301 	smull	r2, r3, r3, r1
    5a9c:	109a      	asrs	r2, r3, #2
    5a9e:	17cb      	asrs	r3, r1, #31
    5aa0:	1ad2      	subs	r2, r2, r3
    5aa2:	4613      	mov	r3, r2
    5aa4:	009b      	lsls	r3, r3, #2
    5aa6:	4413      	add	r3, r2
    5aa8:	005b      	lsls	r3, r3, #1
    5aaa:	1aca      	subs	r2, r1, r3
    5aac:	b2d3      	uxtb	r3, r2
    5aae:	3330      	adds	r3, #48	; 0x30
    5ab0:	b2db      	uxtb	r3, r3
    5ab2:	7003      	strb	r3, [r0, #0]
    dstSize--;
    5ab4:	68bb      	ldr	r3, [r7, #8]
    5ab6:	3b01      	subs	r3, #1
    5ab8:	60bb      	str	r3, [r7, #8]
    val /= 10;
    5aba:	687b      	ldr	r3, [r7, #4]
    5abc:	4a25      	ldr	r2, [pc, #148]	; (5b54 <UTIL1_Num32sToStr+0x130>)
    5abe:	fb82 1203 	smull	r1, r2, r2, r3
    5ac2:	1092      	asrs	r2, r2, #2
    5ac4:	17db      	asrs	r3, r3, #31
    5ac6:	1ad3      	subs	r3, r2, r3
    5ac8:	607b      	str	r3, [r7, #4]
  }
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    5aca:	687b      	ldr	r3, [r7, #4]
    5acc:	2b00      	cmp	r3, #0
    5ace:	dd02      	ble.n	5ad6 <UTIL1_Num32sToStr+0xb2>
    5ad0:	68bb      	ldr	r3, [r7, #8]
    5ad2:	2b00      	cmp	r3, #0
    5ad4:	d1d9      	bne.n	5a8a <UTIL1_Num32sToStr+0x66>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    dstSize--;
    val /= 10;
  }
  if (sign && dstSize > 0){
    5ad6:	7dfb      	ldrb	r3, [r7, #23]
    5ad8:	2b00      	cmp	r3, #0
    5ada:	d00c      	beq.n	5af6 <UTIL1_Num32sToStr+0xd2>
    5adc:	68bb      	ldr	r3, [r7, #8]
    5ade:	2b00      	cmp	r3, #0
    5ae0:	d009      	beq.n	5af6 <UTIL1_Num32sToStr+0xd2>
    ptr[i++] = '-';
    5ae2:	7ffb      	ldrb	r3, [r7, #31]
    5ae4:	1c5a      	adds	r2, r3, #1
    5ae6:	77fa      	strb	r2, [r7, #31]
    5ae8:	69ba      	ldr	r2, [r7, #24]
    5aea:	4413      	add	r3, r2
    5aec:	222d      	movs	r2, #45	; 0x2d
    5aee:	701a      	strb	r2, [r3, #0]
    dstSize--;
    5af0:	68bb      	ldr	r3, [r7, #8]
    5af2:	3b01      	subs	r3, #1
    5af4:	60bb      	str	r3, [r7, #8]
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    5af6:	2300      	movs	r3, #0
    5af8:	77bb      	strb	r3, [r7, #30]
    5afa:	e01a      	b.n	5b32 <UTIL1_Num32sToStr+0x10e>
    tmp = ptr[j];
    5afc:	7fbb      	ldrb	r3, [r7, #30]
    5afe:	69ba      	ldr	r2, [r7, #24]
    5b00:	4413      	add	r3, r2
    5b02:	781b      	ldrb	r3, [r3, #0]
    5b04:	75bb      	strb	r3, [r7, #22]
    ptr[j] = ptr[(i-j)-1];
    5b06:	7fbb      	ldrb	r3, [r7, #30]
    5b08:	69ba      	ldr	r2, [r7, #24]
    5b0a:	4413      	add	r3, r2
    5b0c:	7ff9      	ldrb	r1, [r7, #31]
    5b0e:	7fba      	ldrb	r2, [r7, #30]
    5b10:	1a8a      	subs	r2, r1, r2
    5b12:	3a01      	subs	r2, #1
    5b14:	69b9      	ldr	r1, [r7, #24]
    5b16:	440a      	add	r2, r1
    5b18:	7812      	ldrb	r2, [r2, #0]
    5b1a:	701a      	strb	r2, [r3, #0]
    ptr[(i-j)-1] = tmp;
    5b1c:	7ffa      	ldrb	r2, [r7, #31]
    5b1e:	7fbb      	ldrb	r3, [r7, #30]
    5b20:	1ad3      	subs	r3, r2, r3
    5b22:	3b01      	subs	r3, #1
    5b24:	69ba      	ldr	r2, [r7, #24]
    5b26:	4413      	add	r3, r2
    5b28:	7dba      	ldrb	r2, [r7, #22]
    5b2a:	701a      	strb	r2, [r3, #0]
  }
  if (sign && dstSize > 0){
    ptr[i++] = '-';
    dstSize--;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    5b2c:	7fbb      	ldrb	r3, [r7, #30]
    5b2e:	3301      	adds	r3, #1
    5b30:	77bb      	strb	r3, [r7, #30]
    5b32:	7ffb      	ldrb	r3, [r7, #31]
    5b34:	085b      	lsrs	r3, r3, #1
    5b36:	b2db      	uxtb	r3, r3
    5b38:	7fba      	ldrb	r2, [r7, #30]
    5b3a:	429a      	cmp	r2, r3
    5b3c:	d3de      	bcc.n	5afc <UTIL1_Num32sToStr+0xd8>
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
    5b3e:	7ffb      	ldrb	r3, [r7, #31]
    5b40:	69ba      	ldr	r2, [r7, #24]
    5b42:	4413      	add	r3, r2
    5b44:	2200      	movs	r2, #0
    5b46:	701a      	strb	r2, [r3, #0]
}
    5b48:	3720      	adds	r7, #32
    5b4a:	46bd      	mov	sp, r7
    5b4c:	bd80      	pop	{r7, pc}
    5b4e:	bf00      	nop
    5b50:	00007410 	.word	0x00007410
    5b54:	66666667 	.word	0x66666667

00005b58 <UTIL1_Num32uToStr>:
  \param[in,out] dst String buffer to store the number.
  \param[in] dstSize Size of the destination buffer in uint8_ts.
  \param[in] val 32bit unsigned number to convert.
 */
void UTIL1_Num32uToStr(uint8_t *dst, size_t dstSize, uint32_t val)
{
    5b58:	b480      	push	{r7}
    5b5a:	b089      	sub	sp, #36	; 0x24
    5b5c:	af00      	add	r7, sp, #0
    5b5e:	60f8      	str	r0, [r7, #12]
    5b60:	60b9      	str	r1, [r7, #8]
    5b62:	607a      	str	r2, [r7, #4]
  unsigned char *ptr = ((unsigned char *)dst);
    5b64:	68fb      	ldr	r3, [r7, #12]
    5b66:	61bb      	str	r3, [r7, #24]
  unsigned char i=0, j;
    5b68:	2300      	movs	r3, #0
    5b6a:	77fb      	strb	r3, [r7, #31]
  unsigned char tmp;

  dstSize--; /* for zero uint8_t */
    5b6c:	68bb      	ldr	r3, [r7, #8]
    5b6e:	3b01      	subs	r3, #1
    5b70:	60bb      	str	r3, [r7, #8]
  if (val == 0 && dstSize > 0){
    5b72:	687b      	ldr	r3, [r7, #4]
    5b74:	2b00      	cmp	r3, #0
    5b76:	d10d      	bne.n	5b94 <UTIL1_Num32uToStr+0x3c>
    5b78:	68bb      	ldr	r3, [r7, #8]
    5b7a:	2b00      	cmp	r3, #0
    5b7c:	d00a      	beq.n	5b94 <UTIL1_Num32uToStr+0x3c>
    ptr[i++] = '0';
    5b7e:	7ffb      	ldrb	r3, [r7, #31]
    5b80:	1c5a      	adds	r2, r3, #1
    5b82:	77fa      	strb	r2, [r7, #31]
    5b84:	69ba      	ldr	r2, [r7, #24]
    5b86:	4413      	add	r3, r2
    5b88:	2230      	movs	r2, #48	; 0x30
    5b8a:	701a      	strb	r2, [r3, #0]
    dstSize--;
    5b8c:	68bb      	ldr	r3, [r7, #8]
    5b8e:	3b01      	subs	r3, #1
    5b90:	60bb      	str	r3, [r7, #8]
  }
  while (val > 0 && dstSize > 0) {
    5b92:	e01c      	b.n	5bce <UTIL1_Num32uToStr+0x76>
    5b94:	e01b      	b.n	5bce <UTIL1_Num32uToStr+0x76>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    5b96:	7ffb      	ldrb	r3, [r7, #31]
    5b98:	1c5a      	adds	r2, r3, #1
    5b9a:	77fa      	strb	r2, [r7, #31]
    5b9c:	69ba      	ldr	r2, [r7, #24]
    5b9e:	18d0      	adds	r0, r2, r3
    5ba0:	6879      	ldr	r1, [r7, #4]
    5ba2:	4b25      	ldr	r3, [pc, #148]	; (5c38 <UTIL1_Num32uToStr+0xe0>)
    5ba4:	fba3 2301 	umull	r2, r3, r3, r1
    5ba8:	08da      	lsrs	r2, r3, #3
    5baa:	4613      	mov	r3, r2
    5bac:	009b      	lsls	r3, r3, #2
    5bae:	4413      	add	r3, r2
    5bb0:	005b      	lsls	r3, r3, #1
    5bb2:	1aca      	subs	r2, r1, r3
    5bb4:	b2d3      	uxtb	r3, r2
    5bb6:	3330      	adds	r3, #48	; 0x30
    5bb8:	b2db      	uxtb	r3, r3
    5bba:	7003      	strb	r3, [r0, #0]
    dstSize--;
    5bbc:	68bb      	ldr	r3, [r7, #8]
    5bbe:	3b01      	subs	r3, #1
    5bc0:	60bb      	str	r3, [r7, #8]
    val /= 10;
    5bc2:	687a      	ldr	r2, [r7, #4]
    5bc4:	4b1c      	ldr	r3, [pc, #112]	; (5c38 <UTIL1_Num32uToStr+0xe0>)
    5bc6:	fba3 1302 	umull	r1, r3, r3, r2
    5bca:	08db      	lsrs	r3, r3, #3
    5bcc:	607b      	str	r3, [r7, #4]
  dstSize--; /* for zero uint8_t */
  if (val == 0 && dstSize > 0){
    ptr[i++] = '0';
    dstSize--;
  }
  while (val > 0 && dstSize > 0) {
    5bce:	687b      	ldr	r3, [r7, #4]
    5bd0:	2b00      	cmp	r3, #0
    5bd2:	d002      	beq.n	5bda <UTIL1_Num32uToStr+0x82>
    5bd4:	68bb      	ldr	r3, [r7, #8]
    5bd6:	2b00      	cmp	r3, #0
    5bd8:	d1dd      	bne.n	5b96 <UTIL1_Num32uToStr+0x3e>
    ptr[i++] = (unsigned char)((val % 10) + '0');
    dstSize--;
    val /= 10;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    5bda:	2300      	movs	r3, #0
    5bdc:	77bb      	strb	r3, [r7, #30]
    5bde:	e01a      	b.n	5c16 <UTIL1_Num32uToStr+0xbe>
    tmp = ptr[j];
    5be0:	7fbb      	ldrb	r3, [r7, #30]
    5be2:	69ba      	ldr	r2, [r7, #24]
    5be4:	4413      	add	r3, r2
    5be6:	781b      	ldrb	r3, [r3, #0]
    5be8:	75fb      	strb	r3, [r7, #23]
    ptr[j] = ptr[(i-j)-1];
    5bea:	7fbb      	ldrb	r3, [r7, #30]
    5bec:	69ba      	ldr	r2, [r7, #24]
    5bee:	4413      	add	r3, r2
    5bf0:	7ff9      	ldrb	r1, [r7, #31]
    5bf2:	7fba      	ldrb	r2, [r7, #30]
    5bf4:	1a8a      	subs	r2, r1, r2
    5bf6:	3a01      	subs	r2, #1
    5bf8:	69b9      	ldr	r1, [r7, #24]
    5bfa:	440a      	add	r2, r1
    5bfc:	7812      	ldrb	r2, [r2, #0]
    5bfe:	701a      	strb	r2, [r3, #0]
    ptr[(i-j)-1] = tmp;
    5c00:	7ffa      	ldrb	r2, [r7, #31]
    5c02:	7fbb      	ldrb	r3, [r7, #30]
    5c04:	1ad3      	subs	r3, r2, r3
    5c06:	3b01      	subs	r3, #1
    5c08:	69ba      	ldr	r2, [r7, #24]
    5c0a:	4413      	add	r3, r2
    5c0c:	7dfa      	ldrb	r2, [r7, #23]
    5c0e:	701a      	strb	r2, [r3, #0]
  while (val > 0 && dstSize > 0) {
    ptr[i++] = (unsigned char)((val % 10) + '0');
    dstSize--;
    val /= 10;
  }
  for(j=0; j<(i/2); j++) { /* swap buffer */
    5c10:	7fbb      	ldrb	r3, [r7, #30]
    5c12:	3301      	adds	r3, #1
    5c14:	77bb      	strb	r3, [r7, #30]
    5c16:	7ffb      	ldrb	r3, [r7, #31]
    5c18:	085b      	lsrs	r3, r3, #1
    5c1a:	b2db      	uxtb	r3, r3
    5c1c:	7fba      	ldrb	r2, [r7, #30]
    5c1e:	429a      	cmp	r2, r3
    5c20:	d3de      	bcc.n	5be0 <UTIL1_Num32uToStr+0x88>
    tmp = ptr[j];
    ptr[j] = ptr[(i-j)-1];
    ptr[(i-j)-1] = tmp;
  }
  ptr[i] = '\0';
    5c22:	7ffb      	ldrb	r3, [r7, #31]
    5c24:	69ba      	ldr	r2, [r7, #24]
    5c26:	4413      	add	r3, r2
    5c28:	2200      	movs	r2, #0
    5c2a:	701a      	strb	r2, [r3, #0]
}
    5c2c:	3724      	adds	r7, #36	; 0x24
    5c2e:	46bd      	mov	sp, r7
    5c30:	f85d 7b04 	ldr.w	r7, [sp], #4
    5c34:	4770      	bx	lr
    5c36:	bf00      	nop
    5c38:	cccccccd 	.word	0xcccccccd

00005c3c <UTIL1_IsLeapYear>:
**     Returns     :
**         ---             - If the year is a leap year or not.
** ===================================================================
*/
bool UTIL1_IsLeapYear(uint16_t year)
{
    5c3c:	b480      	push	{r7}
    5c3e:	b083      	sub	sp, #12
    5c40:	af00      	add	r7, sp, #0
    5c42:	4603      	mov	r3, r0
    5c44:	80fb      	strh	r3, [r7, #6]
  return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
    5c46:	88fb      	ldrh	r3, [r7, #6]
    5c48:	f003 0303 	and.w	r3, r3, #3
    5c4c:	b29b      	uxth	r3, r3
    5c4e:	2b00      	cmp	r3, #0
    5c50:	d10b      	bne.n	5c6a <UTIL1_IsLeapYear+0x2e>
    5c52:	88fb      	ldrh	r3, [r7, #6]
    5c54:	4a10      	ldr	r2, [pc, #64]	; (5c98 <UTIL1_IsLeapYear+0x5c>)
    5c56:	fba2 1203 	umull	r1, r2, r2, r3
    5c5a:	0952      	lsrs	r2, r2, #5
    5c5c:	2164      	movs	r1, #100	; 0x64
    5c5e:	fb01 f202 	mul.w	r2, r1, r2
    5c62:	1a9b      	subs	r3, r3, r2
    5c64:	b29b      	uxth	r3, r3
    5c66:	2b00      	cmp	r3, #0
    5c68:	d10c      	bne.n	5c84 <UTIL1_IsLeapYear+0x48>
    5c6a:	88fb      	ldrh	r3, [r7, #6]
    5c6c:	4a0a      	ldr	r2, [pc, #40]	; (5c98 <UTIL1_IsLeapYear+0x5c>)
    5c6e:	fba2 1203 	umull	r1, r2, r2, r3
    5c72:	09d2      	lsrs	r2, r2, #7
    5c74:	f44f 71c8 	mov.w	r1, #400	; 0x190
    5c78:	fb01 f202 	mul.w	r2, r1, r2
    5c7c:	1a9b      	subs	r3, r3, r2
    5c7e:	b29b      	uxth	r3, r3
    5c80:	2b00      	cmp	r3, #0
    5c82:	d101      	bne.n	5c88 <UTIL1_IsLeapYear+0x4c>
    5c84:	2301      	movs	r3, #1
    5c86:	e000      	b.n	5c8a <UTIL1_IsLeapYear+0x4e>
    5c88:	2300      	movs	r3, #0
    5c8a:	b2db      	uxtb	r3, r3
}
    5c8c:	4618      	mov	r0, r3
    5c8e:	370c      	adds	r7, #12
    5c90:	46bd      	mov	sp, r7
    5c92:	f85d 7b04 	ldr.w	r7, [sp], #4
    5c96:	4770      	bx	lr
    5c98:	51eb851f 	.word	0x51eb851f

00005c9c <UTIL1_WeekDay>:
**         ---             - Returns the weekday, 0 for Sunday, 1 for
**                           Monday, 2 for Tuesday, etc.
** ===================================================================
*/
uint8_t UTIL1_WeekDay(uint16_t year, uint8_t month, uint8_t day)
{
    5c9c:	b580      	push	{r7, lr}
    5c9e:	b084      	sub	sp, #16
    5ca0:	af00      	add	r7, sp, #0
    5ca2:	4613      	mov	r3, r2
    5ca4:	4602      	mov	r2, r0
    5ca6:	80fa      	strh	r2, [r7, #6]
    5ca8:	460a      	mov	r2, r1
    5caa:	717a      	strb	r2, [r7, #5]
    5cac:	713b      	strb	r3, [r7, #4]
  /* see http://klausler.com/new-dayofweek.html */
  static const uint8_t skew[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
  uint16_t sum;

  sum = (uint16_t)(year-1900);
    5cae:	88fb      	ldrh	r3, [r7, #6]
    5cb0:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
    5cb4:	81fb      	strh	r3, [r7, #14]
  sum += sum/4;
    5cb6:	89fb      	ldrh	r3, [r7, #14]
    5cb8:	089b      	lsrs	r3, r3, #2
    5cba:	b29a      	uxth	r2, r3
    5cbc:	89fb      	ldrh	r3, [r7, #14]
    5cbe:	4413      	add	r3, r2
    5cc0:	81fb      	strh	r3, [r7, #14]
  sum %= 7;
    5cc2:	89fa      	ldrh	r2, [r7, #14]
    5cc4:	4b24      	ldr	r3, [pc, #144]	; (5d58 <UTIL1_WeekDay+0xbc>)
    5cc6:	fba2 0103 	umull	r0, r1, r2, r3
    5cca:	1a53      	subs	r3, r2, r1
    5ccc:	085b      	lsrs	r3, r3, #1
    5cce:	440b      	add	r3, r1
    5cd0:	0899      	lsrs	r1, r3, #2
    5cd2:	460b      	mov	r3, r1
    5cd4:	00db      	lsls	r3, r3, #3
    5cd6:	1a5b      	subs	r3, r3, r1
    5cd8:	1ad3      	subs	r3, r2, r3
    5cda:	81fb      	strh	r3, [r7, #14]
  if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
    5cdc:	88fb      	ldrh	r3, [r7, #6]
    5cde:	4618      	mov	r0, r3
    5ce0:	f7ff ffac 	bl	5c3c <UTIL1_IsLeapYear>
    5ce4:	4603      	mov	r3, r0
    5ce6:	2b00      	cmp	r3, #0
    5ce8:	d008      	beq.n	5cfc <UTIL1_WeekDay+0x60>
    5cea:	797b      	ldrb	r3, [r7, #5]
    5cec:	2b01      	cmp	r3, #1
    5cee:	d002      	beq.n	5cf6 <UTIL1_WeekDay+0x5a>
    5cf0:	797b      	ldrb	r3, [r7, #5]
    5cf2:	2b02      	cmp	r3, #2
    5cf4:	d102      	bne.n	5cfc <UTIL1_WeekDay+0x60>
    sum--;
    5cf6:	89fb      	ldrh	r3, [r7, #14]
    5cf8:	3b01      	subs	r3, #1
    5cfa:	81fb      	strh	r3, [r7, #14]
  }
  sum += day;
    5cfc:	793b      	ldrb	r3, [r7, #4]
    5cfe:	b29a      	uxth	r2, r3
    5d00:	89fb      	ldrh	r3, [r7, #14]
    5d02:	4413      	add	r3, r2
    5d04:	81fb      	strh	r3, [r7, #14]
  sum %= 7;
    5d06:	89fa      	ldrh	r2, [r7, #14]
    5d08:	4b13      	ldr	r3, [pc, #76]	; (5d58 <UTIL1_WeekDay+0xbc>)
    5d0a:	fba2 0103 	umull	r0, r1, r2, r3
    5d0e:	1a53      	subs	r3, r2, r1
    5d10:	085b      	lsrs	r3, r3, #1
    5d12:	440b      	add	r3, r1
    5d14:	0899      	lsrs	r1, r3, #2
    5d16:	460b      	mov	r3, r1
    5d18:	00db      	lsls	r3, r3, #3
    5d1a:	1a5b      	subs	r3, r3, r1
    5d1c:	1ad3      	subs	r3, r2, r3
    5d1e:	81fb      	strh	r3, [r7, #14]
  sum += skew[month-1];
    5d20:	797b      	ldrb	r3, [r7, #5]
    5d22:	3b01      	subs	r3, #1
    5d24:	4a0d      	ldr	r2, [pc, #52]	; (5d5c <UTIL1_WeekDay+0xc0>)
    5d26:	5cd3      	ldrb	r3, [r2, r3]
    5d28:	461a      	mov	r2, r3
    5d2a:	89fb      	ldrh	r3, [r7, #14]
    5d2c:	4413      	add	r3, r2
    5d2e:	81fb      	strh	r3, [r7, #14]
  sum %= 7;
    5d30:	89fa      	ldrh	r2, [r7, #14]
    5d32:	4b09      	ldr	r3, [pc, #36]	; (5d58 <UTIL1_WeekDay+0xbc>)
    5d34:	fba2 0103 	umull	r0, r1, r2, r3
    5d38:	1a53      	subs	r3, r2, r1
    5d3a:	085b      	lsrs	r3, r3, #1
    5d3c:	440b      	add	r3, r1
    5d3e:	0899      	lsrs	r1, r3, #2
    5d40:	460b      	mov	r3, r1
    5d42:	00db      	lsls	r3, r3, #3
    5d44:	1a5b      	subs	r3, r3, r1
    5d46:	1ad3      	subs	r3, r2, r3
    5d48:	81fb      	strh	r3, [r7, #14]
  return (uint8_t)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
    5d4a:	89fb      	ldrh	r3, [r7, #14]
    5d4c:	b2db      	uxtb	r3, r3
}
    5d4e:	4618      	mov	r0, r3
    5d50:	3710      	adds	r7, #16
    5d52:	46bd      	mov	sp, r7
    5d54:	bd80      	pop	{r7, pc}
    5d56:	bf00      	nop
    5d58:	24924925 	.word	0x24924925
    5d5c:	00007420 	.word	0x00007420

00005d60 <UTIL1_ReadEscapedName>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ReadEscapedName(const unsigned char *filename, uint8_t *destname, size_t maxlen, size_t *lenRead, size_t *lenWritten, const char *terminators)
{
    5d60:	b580      	push	{r7, lr}
    5d62:	b088      	sub	sp, #32
    5d64:	af00      	add	r7, sp, #0
    5d66:	60f8      	str	r0, [r7, #12]
    5d68:	60b9      	str	r1, [r7, #8]
    5d6a:	607a      	str	r2, [r7, #4]
    5d6c:	603b      	str	r3, [r7, #0]
  size_t lenCopied = 0, lenOverread = 0;
    5d6e:	2300      	movs	r3, #0
    5d70:	61fb      	str	r3, [r7, #28]
    5d72:	2300      	movs	r3, #0
    5d74:	61bb      	str	r3, [r7, #24]
  bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a second single quote "
    5d76:	2300      	movs	r3, #0
    5d78:	75fb      	strb	r3, [r7, #23]
                              terminates the string. In !quoteMode a space or a '\0' may also terminate it correctly */
  bool res = ERR_OK;
    5d7a:	2300      	movs	r3, #0
    5d7c:	75bb      	strb	r3, [r7, #22]
  #define IS_SPACE(ch) ((ch)==' '||(ch)=='\t'||(ch)=='\n'||(ch)=='\v'||(ch)=='\f'||(ch)=='\r')

  if (filename==NULL || (destname!=NULL && maxlen==0)) {
    5d7e:	68fb      	ldr	r3, [r7, #12]
    5d80:	2b00      	cmp	r3, #0
    5d82:	d005      	beq.n	5d90 <UTIL1_ReadEscapedName+0x30>
    5d84:	68bb      	ldr	r3, [r7, #8]
    5d86:	2b00      	cmp	r3, #0
    5d88:	d004      	beq.n	5d94 <UTIL1_ReadEscapedName+0x34>
    5d8a:	687b      	ldr	r3, [r7, #4]
    5d8c:	2b00      	cmp	r3, #0
    5d8e:	d101      	bne.n	5d94 <UTIL1_ReadEscapedName+0x34>
    return ERR_FAILED;
    5d90:	231b      	movs	r3, #27
    5d92:	e080      	b.n	5e96 <UTIL1_ReadEscapedName+0x136>
  }
  if (filename[0] == '"') { /* translated mode */
    5d94:	68fb      	ldr	r3, [r7, #12]
    5d96:	781b      	ldrb	r3, [r3, #0]
    5d98:	2b22      	cmp	r3, #34	; 0x22
    5d9a:	d107      	bne.n	5dac <UTIL1_ReadEscapedName+0x4c>
    filename++; /* overread '"' */
    5d9c:	68fb      	ldr	r3, [r7, #12]
    5d9e:	3301      	adds	r3, #1
    5da0:	60fb      	str	r3, [r7, #12]
    lenOverread++;
    5da2:	69bb      	ldr	r3, [r7, #24]
    5da4:	3301      	adds	r3, #1
    5da6:	61bb      	str	r3, [r7, #24]
    quoteMode=TRUE;
    5da8:	2301      	movs	r3, #1
    5daa:	75fb      	strb	r3, [r7, #23]
  }
  if (terminators == NULL) {
    5dac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    5dae:	2b00      	cmp	r3, #0
    5db0:	d101      	bne.n	5db6 <UTIL1_ReadEscapedName+0x56>
    terminators = "";
    5db2:	4b3b      	ldr	r3, [pc, #236]	; (5ea0 <UTIL1_ReadEscapedName+0x140>)
    5db4:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
  for (;;) {
    if (quoteMode) {
    5db6:	7dfb      	ldrb	r3, [r7, #23]
    5db8:	2b00      	cmp	r3, #0
    5dba:	d015      	beq.n	5de8 <UTIL1_ReadEscapedName+0x88>
      if (filename[0] == '"') {
    5dbc:	68fb      	ldr	r3, [r7, #12]
    5dbe:	781b      	ldrb	r3, [r3, #0]
    5dc0:	2b22      	cmp	r3, #34	; 0x22
    5dc2:	d10a      	bne.n	5dda <UTIL1_ReadEscapedName+0x7a>
        filename++; /* overread '"' */
    5dc4:	68fb      	ldr	r3, [r7, #12]
    5dc6:	3301      	adds	r3, #1
    5dc8:	60fb      	str	r3, [r7, #12]
        lenOverread++;
    5dca:	69bb      	ldr	r3, [r7, #24]
    5dcc:	3301      	adds	r3, #1
    5dce:	61bb      	str	r3, [r7, #24]
        if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is treated like a single quote and does not terminate it ! */
    5dd0:	68fb      	ldr	r3, [r7, #12]
    5dd2:	781b      	ldrb	r3, [r3, #0]
    5dd4:	2b22      	cmp	r3, #34	; 0x22
    5dd6:	d000      	beq.n	5dda <UTIL1_ReadEscapedName+0x7a>
          break; /* successfully finished with this name */
    5dd8:	e047      	b.n	5e6a <UTIL1_ReadEscapedName+0x10a>
        } /* else we copy the second quote " */
      }
      if (filename[0] == '\0') { /* unexpected 0. stop */
    5dda:	68fb      	ldr	r3, [r7, #12]
    5ddc:	781b      	ldrb	r3, [r3, #0]
    5dde:	2b00      	cmp	r3, #0
    5de0:	d127      	bne.n	5e32 <UTIL1_ReadEscapedName+0xd2>
        res = ERR_FAILED;
    5de2:	231b      	movs	r3, #27
    5de4:	75bb      	strb	r3, [r7, #22]
        break; /* error case: no terminating double quote (") was found */
    5de6:	e040      	b.n	5e6a <UTIL1_ReadEscapedName+0x10a>
      }
    } else { /* copy mode */
      if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL) { /* !quoteMode is terminated by space, '\0' or by any char in terminators */
    5de8:	68fb      	ldr	r3, [r7, #12]
    5dea:	781b      	ldrb	r3, [r3, #0]
    5dec:	2b20      	cmp	r3, #32
    5dee:	d03c      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5df0:	68fb      	ldr	r3, [r7, #12]
    5df2:	781b      	ldrb	r3, [r3, #0]
    5df4:	2b09      	cmp	r3, #9
    5df6:	d038      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5df8:	68fb      	ldr	r3, [r7, #12]
    5dfa:	781b      	ldrb	r3, [r3, #0]
    5dfc:	2b0a      	cmp	r3, #10
    5dfe:	d034      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5e00:	68fb      	ldr	r3, [r7, #12]
    5e02:	781b      	ldrb	r3, [r3, #0]
    5e04:	2b0b      	cmp	r3, #11
    5e06:	d030      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5e08:	68fb      	ldr	r3, [r7, #12]
    5e0a:	781b      	ldrb	r3, [r3, #0]
    5e0c:	2b0c      	cmp	r3, #12
    5e0e:	d02c      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5e10:	68fb      	ldr	r3, [r7, #12]
    5e12:	781b      	ldrb	r3, [r3, #0]
    5e14:	2b0d      	cmp	r3, #13
    5e16:	d028      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5e18:	68fb      	ldr	r3, [r7, #12]
    5e1a:	781b      	ldrb	r3, [r3, #0]
    5e1c:	2b00      	cmp	r3, #0
    5e1e:	d024      	beq.n	5e6a <UTIL1_ReadEscapedName+0x10a>
    5e20:	68fb      	ldr	r3, [r7, #12]
    5e22:	781b      	ldrb	r3, [r3, #0]
    5e24:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    5e26:	4619      	mov	r1, r3
    5e28:	f001 f9f1 	bl	720e <strchr>
    5e2c:	4603      	mov	r3, r0
    5e2e:	2b00      	cmp	r3, #0
    5e30:	d11b      	bne.n	5e6a <UTIL1_ReadEscapedName+0x10a>
        break;
      }
    }
    if (destname != NULL) {
    5e32:	68bb      	ldr	r3, [r7, #8]
    5e34:	2b00      	cmp	r3, #0
    5e36:	d011      	beq.n	5e5c <UTIL1_ReadEscapedName+0xfc>
      if (lenCopied + 1 < maxlen) {
    5e38:	69fb      	ldr	r3, [r7, #28]
    5e3a:	1c5a      	adds	r2, r3, #1
    5e3c:	687b      	ldr	r3, [r7, #4]
    5e3e:	429a      	cmp	r2, r3
    5e40:	d207      	bcs.n	5e52 <UTIL1_ReadEscapedName+0xf2>
        destname[0] = filename[0];
    5e42:	68fb      	ldr	r3, [r7, #12]
    5e44:	781a      	ldrb	r2, [r3, #0]
    5e46:	68bb      	ldr	r3, [r7, #8]
    5e48:	701a      	strb	r2, [r3, #0]
        destname++;
    5e4a:	68bb      	ldr	r3, [r7, #8]
    5e4c:	3301      	adds	r3, #1
    5e4e:	60bb      	str	r3, [r7, #8]
    5e50:	e004      	b.n	5e5c <UTIL1_ReadEscapedName+0xfc>
      } else {
        destname[0] = '\0'; /* terminate string */
    5e52:	68bb      	ldr	r3, [r7, #8]
    5e54:	2200      	movs	r2, #0
    5e56:	701a      	strb	r2, [r3, #0]
        destname = NULL; /* avoid it to overwrite not allocated space */
    5e58:	2300      	movs	r3, #0
    5e5a:	60bb      	str	r3, [r7, #8]
      }
    }
    lenCopied++;
    5e5c:	69fb      	ldr	r3, [r7, #28]
    5e5e:	3301      	adds	r3, #1
    5e60:	61fb      	str	r3, [r7, #28]
    filename++;
    5e62:	68fb      	ldr	r3, [r7, #12]
    5e64:	3301      	adds	r3, #1
    5e66:	60fb      	str	r3, [r7, #12]
  }
    5e68:	e7a5      	b.n	5db6 <UTIL1_ReadEscapedName+0x56>
  if (destname != NULL) {
    5e6a:	68bb      	ldr	r3, [r7, #8]
    5e6c:	2b00      	cmp	r3, #0
    5e6e:	d002      	beq.n	5e76 <UTIL1_ReadEscapedName+0x116>
    destname[0] = '\0';
    5e70:	68bb      	ldr	r3, [r7, #8]
    5e72:	2200      	movs	r2, #0
    5e74:	701a      	strb	r2, [r3, #0]
  }
  if (lenRead != NULL) {
    5e76:	683b      	ldr	r3, [r7, #0]
    5e78:	2b00      	cmp	r3, #0
    5e7a:	d004      	beq.n	5e86 <UTIL1_ReadEscapedName+0x126>
    *lenRead = lenCopied+lenOverread;
    5e7c:	69fa      	ldr	r2, [r7, #28]
    5e7e:	69bb      	ldr	r3, [r7, #24]
    5e80:	441a      	add	r2, r3
    5e82:	683b      	ldr	r3, [r7, #0]
    5e84:	601a      	str	r2, [r3, #0]
  }
  if (lenWritten != NULL) {
    5e86:	6abb      	ldr	r3, [r7, #40]	; 0x28
    5e88:	2b00      	cmp	r3, #0
    5e8a:	d003      	beq.n	5e94 <UTIL1_ReadEscapedName+0x134>
    *lenWritten = lenCopied + 1; /* additionally a zero uint8_t written */
    5e8c:	69fb      	ldr	r3, [r7, #28]
    5e8e:	1c5a      	adds	r2, r3, #1
    5e90:	6abb      	ldr	r3, [r7, #40]	; 0x28
    5e92:	601a      	str	r2, [r3, #0]
  }
  return res;
    5e94:	7dbb      	ldrb	r3, [r7, #22]
}
    5e96:	4618      	mov	r0, r3
    5e98:	3720      	adds	r7, #32
    5e9a:	46bd      	mov	sp, r7
    5e9c:	bd80      	pop	{r7, pc}
    5e9e:	bf00      	nop
    5ea0:	0000741c 	.word	0x0000741c

00005ea4 <UTIL1_xatoi>:
/-------------------------------------------------------------------------*/
#ifdef __HC12__
  #pragma MESSAGE DISABLE C12056  /* message about SP debug info */
#endif
uint8_t UTIL1_xatoi(const unsigned char **str, int32_t *res)
{
    5ea4:	b480      	push	{r7}
    5ea6:	b085      	sub	sp, #20
    5ea8:	af00      	add	r7, sp, #0
    5eaa:	6078      	str	r0, [r7, #4]
    5eac:	6039      	str	r1, [r7, #0]
                               ^      6th call returns 3 and next ptr, caller needs to read '.'
                                 ^    7th call returns 25 and next ptr
                                    ^ 8th call fails and returns ERR_FAILED
*/
  uint32_t val;
  uint8_t c, r, s = 0;
    5eae:	2300      	movs	r3, #0
    5eb0:	727b      	strb	r3, [r7, #9]

  *res = 0;
    5eb2:	683b      	ldr	r3, [r7, #0]
    5eb4:	2200      	movs	r2, #0
    5eb6:	601a      	str	r2, [r3, #0]
  while (**str==' ') {
    5eb8:	e004      	b.n	5ec4 <UTIL1_xatoi+0x20>
    (*str)++;                          /* Skip leading spaces */
    5eba:	687b      	ldr	r3, [r7, #4]
    5ebc:	681b      	ldr	r3, [r3, #0]
    5ebe:	1c5a      	adds	r2, r3, #1
    5ec0:	687b      	ldr	r3, [r7, #4]
    5ec2:	601a      	str	r2, [r3, #0]
*/
  uint32_t val;
  uint8_t c, r, s = 0;

  *res = 0;
  while (**str==' ') {
    5ec4:	687b      	ldr	r3, [r7, #4]
    5ec6:	681b      	ldr	r3, [r3, #0]
    5ec8:	781b      	ldrb	r3, [r3, #0]
    5eca:	2b20      	cmp	r3, #32
    5ecc:	d0f5      	beq.n	5eba <UTIL1_xatoi+0x16>
    (*str)++;                          /* Skip leading spaces */
  }
  c = **str;
    5ece:	687b      	ldr	r3, [r7, #4]
    5ed0:	681b      	ldr	r3, [r3, #0]
    5ed2:	781b      	ldrb	r3, [r3, #0]
    5ed4:	72fb      	strb	r3, [r7, #11]
  if (c == '-') {                      /* negative? */
    5ed6:	7afb      	ldrb	r3, [r7, #11]
    5ed8:	2b2d      	cmp	r3, #45	; 0x2d
    5eda:	d10a      	bne.n	5ef2 <UTIL1_xatoi+0x4e>
    s = 1;
    5edc:	2301      	movs	r3, #1
    5ede:	727b      	strb	r3, [r7, #9]
    c = *(++(*str));
    5ee0:	687b      	ldr	r3, [r7, #4]
    5ee2:	681b      	ldr	r3, [r3, #0]
    5ee4:	1c5a      	adds	r2, r3, #1
    5ee6:	687b      	ldr	r3, [r7, #4]
    5ee8:	601a      	str	r2, [r3, #0]
    5eea:	687b      	ldr	r3, [r7, #4]
    5eec:	681b      	ldr	r3, [r3, #0]
    5eee:	781b      	ldrb	r3, [r3, #0]
    5ef0:	72fb      	strb	r3, [r7, #11]
  }
  if (c == '0') {
    5ef2:	7afb      	ldrb	r3, [r7, #11]
    5ef4:	2b30      	cmp	r3, #48	; 0x30
    5ef6:	d139      	bne.n	5f6c <UTIL1_xatoi+0xc8>
    c = *(++(*str));
    5ef8:	687b      	ldr	r3, [r7, #4]
    5efa:	681b      	ldr	r3, [r3, #0]
    5efc:	1c5a      	adds	r2, r3, #1
    5efe:	687b      	ldr	r3, [r7, #4]
    5f00:	601a      	str	r2, [r3, #0]
    5f02:	687b      	ldr	r3, [r7, #4]
    5f04:	681b      	ldr	r3, [r3, #0]
    5f06:	781b      	ldrb	r3, [r3, #0]
    5f08:	72fb      	strb	r3, [r7, #11]
    switch (c) {
    5f0a:	7afb      	ldrb	r3, [r7, #11]
    5f0c:	2b62      	cmp	r3, #98	; 0x62
    5f0e:	d00d      	beq.n	5f2c <UTIL1_xatoi+0x88>
    5f10:	2b78      	cmp	r3, #120	; 0x78
    5f12:	d117      	bne.n	5f44 <UTIL1_xatoi+0xa0>
      case 'x':                        /* hexadecimal */
        r = 16; c = *(++(*str));
    5f14:	2310      	movs	r3, #16
    5f16:	72bb      	strb	r3, [r7, #10]
    5f18:	687b      	ldr	r3, [r7, #4]
    5f1a:	681b      	ldr	r3, [r3, #0]
    5f1c:	1c5a      	adds	r2, r3, #1
    5f1e:	687b      	ldr	r3, [r7, #4]
    5f20:	601a      	str	r2, [r3, #0]
    5f22:	687b      	ldr	r3, [r7, #4]
    5f24:	681b      	ldr	r3, [r3, #0]
    5f26:	781b      	ldrb	r3, [r3, #0]
    5f28:	72fb      	strb	r3, [r7, #11]
        break;
    5f2a:	e01e      	b.n	5f6a <UTIL1_xatoi+0xc6>
      case 'b':                        /* binary */
        r = 2; c = *(++(*str));
    5f2c:	2302      	movs	r3, #2
    5f2e:	72bb      	strb	r3, [r7, #10]
    5f30:	687b      	ldr	r3, [r7, #4]
    5f32:	681b      	ldr	r3, [r3, #0]
    5f34:	1c5a      	adds	r2, r3, #1
    5f36:	687b      	ldr	r3, [r7, #4]
    5f38:	601a      	str	r2, [r3, #0]
    5f3a:	687b      	ldr	r3, [r7, #4]
    5f3c:	681b      	ldr	r3, [r3, #0]
    5f3e:	781b      	ldrb	r3, [r3, #0]
    5f40:	72fb      	strb	r3, [r7, #11]
        break;
    5f42:	e012      	b.n	5f6a <UTIL1_xatoi+0xc6>
      default:
        if (c <= ' ' || c == '.') {
    5f44:	7afb      	ldrb	r3, [r7, #11]
    5f46:	2b20      	cmp	r3, #32
    5f48:	d902      	bls.n	5f50 <UTIL1_xatoi+0xac>
    5f4a:	7afb      	ldrb	r3, [r7, #11]
    5f4c:	2b2e      	cmp	r3, #46	; 0x2e
    5f4e:	d101      	bne.n	5f54 <UTIL1_xatoi+0xb0>
          return ERR_OK;               /* single zero */
    5f50:	2300      	movs	r3, #0
    5f52:	e052      	b.n	5ffa <UTIL1_xatoi+0x156>
        }
        if (c < '0' || c > '9') {
    5f54:	7afb      	ldrb	r3, [r7, #11]
    5f56:	2b2f      	cmp	r3, #47	; 0x2f
    5f58:	d902      	bls.n	5f60 <UTIL1_xatoi+0xbc>
    5f5a:	7afb      	ldrb	r3, [r7, #11]
    5f5c:	2b39      	cmp	r3, #57	; 0x39
    5f5e:	d901      	bls.n	5f64 <UTIL1_xatoi+0xc0>
          return ERR_FAILED;           /* invalid char */
    5f60:	231b      	movs	r3, #27
    5f62:	e04a      	b.n	5ffa <UTIL1_xatoi+0x156>
        }
        r = 8;                         /* octal */
    5f64:	2308      	movs	r3, #8
    5f66:	72bb      	strb	r3, [r7, #10]
        break;
    5f68:	bf00      	nop
    5f6a:	e009      	b.n	5f80 <UTIL1_xatoi+0xdc>
    } /* switch */
  } else {
    if (c < '0' || c > '9') {
    5f6c:	7afb      	ldrb	r3, [r7, #11]
    5f6e:	2b2f      	cmp	r3, #47	; 0x2f
    5f70:	d902      	bls.n	5f78 <UTIL1_xatoi+0xd4>
    5f72:	7afb      	ldrb	r3, [r7, #11]
    5f74:	2b39      	cmp	r3, #57	; 0x39
    5f76:	d901      	bls.n	5f7c <UTIL1_xatoi+0xd8>
      return ERR_FAILED;               /* EOL or invalid char */
    5f78:	231b      	movs	r3, #27
    5f7a:	e03e      	b.n	5ffa <UTIL1_xatoi+0x156>
    }
    r = 10;                            /* decimal */
    5f7c:	230a      	movs	r3, #10
    5f7e:	72bb      	strb	r3, [r7, #10]
  }
  val = 0;
    5f80:	2300      	movs	r3, #0
    5f82:	60fb      	str	r3, [r7, #12]
  while (c > ' ' && c != '.') {
    5f84:	e029      	b.n	5fda <UTIL1_xatoi+0x136>
    if (c >= 'a') c -= 0x20;
    5f86:	7afb      	ldrb	r3, [r7, #11]
    5f88:	2b60      	cmp	r3, #96	; 0x60
    5f8a:	d902      	bls.n	5f92 <UTIL1_xatoi+0xee>
    5f8c:	7afb      	ldrb	r3, [r7, #11]
    5f8e:	3b20      	subs	r3, #32
    5f90:	72fb      	strb	r3, [r7, #11]
    c -= '0';
    5f92:	7afb      	ldrb	r3, [r7, #11]
    5f94:	3b30      	subs	r3, #48	; 0x30
    5f96:	72fb      	strb	r3, [r7, #11]
    if (c >= 17) {
    5f98:	7afb      	ldrb	r3, [r7, #11]
    5f9a:	2b10      	cmp	r3, #16
    5f9c:	d907      	bls.n	5fae <UTIL1_xatoi+0x10a>
      c -= 7;
    5f9e:	7afb      	ldrb	r3, [r7, #11]
    5fa0:	3b07      	subs	r3, #7
    5fa2:	72fb      	strb	r3, [r7, #11]
      if (c <= 9) return ERR_FAILED;   /* invalid char */
    5fa4:	7afb      	ldrb	r3, [r7, #11]
    5fa6:	2b09      	cmp	r3, #9
    5fa8:	d801      	bhi.n	5fae <UTIL1_xatoi+0x10a>
    5faa:	231b      	movs	r3, #27
    5fac:	e025      	b.n	5ffa <UTIL1_xatoi+0x156>
    }
    if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
    5fae:	7afa      	ldrb	r2, [r7, #11]
    5fb0:	7abb      	ldrb	r3, [r7, #10]
    5fb2:	429a      	cmp	r2, r3
    5fb4:	d301      	bcc.n	5fba <UTIL1_xatoi+0x116>
    5fb6:	231b      	movs	r3, #27
    5fb8:	e01f      	b.n	5ffa <UTIL1_xatoi+0x156>
    val = val * r + c;
    5fba:	7abb      	ldrb	r3, [r7, #10]
    5fbc:	68fa      	ldr	r2, [r7, #12]
    5fbe:	fb02 f203 	mul.w	r2, r2, r3
    5fc2:	7afb      	ldrb	r3, [r7, #11]
    5fc4:	4413      	add	r3, r2
    5fc6:	60fb      	str	r3, [r7, #12]
    c = *(++(*str));
    5fc8:	687b      	ldr	r3, [r7, #4]
    5fca:	681b      	ldr	r3, [r3, #0]
    5fcc:	1c5a      	adds	r2, r3, #1
    5fce:	687b      	ldr	r3, [r7, #4]
    5fd0:	601a      	str	r2, [r3, #0]
    5fd2:	687b      	ldr	r3, [r7, #4]
    5fd4:	681b      	ldr	r3, [r3, #0]
    5fd6:	781b      	ldrb	r3, [r3, #0]
    5fd8:	72fb      	strb	r3, [r7, #11]
      return ERR_FAILED;               /* EOL or invalid char */
    }
    r = 10;                            /* decimal */
  }
  val = 0;
  while (c > ' ' && c != '.') {
    5fda:	7afb      	ldrb	r3, [r7, #11]
    5fdc:	2b20      	cmp	r3, #32
    5fde:	d902      	bls.n	5fe6 <UTIL1_xatoi+0x142>
    5fe0:	7afb      	ldrb	r3, [r7, #11]
    5fe2:	2b2e      	cmp	r3, #46	; 0x2e
    5fe4:	d1cf      	bne.n	5f86 <UTIL1_xatoi+0xe2>
    }
    if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
    val = val * r + c;
    c = *(++(*str));
  } /* while */
  if (s) val = 0 - val;                /* apply sign if needed */
    5fe6:	7a7b      	ldrb	r3, [r7, #9]
    5fe8:	2b00      	cmp	r3, #0
    5fea:	d002      	beq.n	5ff2 <UTIL1_xatoi+0x14e>
    5fec:	68fb      	ldr	r3, [r7, #12]
    5fee:	425b      	negs	r3, r3
    5ff0:	60fb      	str	r3, [r7, #12]
  *res = (long)val;
    5ff2:	68fa      	ldr	r2, [r7, #12]
    5ff4:	683b      	ldr	r3, [r7, #0]
    5ff6:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    5ff8:	2300      	movs	r3, #0
}
    5ffa:	4618      	mov	r0, r3
    5ffc:	3714      	adds	r7, #20
    5ffe:	46bd      	mov	sp, r7
    6000:	f85d 7b04 	ldr.w	r7, [sp], #4
    6004:	4770      	bx	lr
    6006:	bf00      	nop

00006008 <UTIL1_ScanDate>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDate(const unsigned char **str, uint8_t *day, uint8_t *month, uint16_t *year)
{
    6008:	b580      	push	{r7, lr}
    600a:	b086      	sub	sp, #24
    600c:	af00      	add	r7, sp, #0
    600e:	60f8      	str	r0, [r7, #12]
    6010:	60b9      	str	r1, [r7, #8]
    6012:	607a      	str	r2, [r7, #4]
    6014:	603b      	str	r3, [r7, #0]
  /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is in format dd.mm.yy or dd.mm.yyyy */
  const unsigned char *p;

  p = *str;
    6016:	68fb      	ldr	r3, [r7, #12]
    6018:	681b      	ldr	r3, [r3, #0]
    601a:	617b      	str	r3, [r7, #20]
  while(*p==' ') {
    601c:	e002      	b.n	6024 <UTIL1_ScanDate+0x1c>
    p++; /* skip leading spaces */
    601e:	697b      	ldr	r3, [r7, #20]
    6020:	3301      	adds	r3, #1
    6022:	617b      	str	r3, [r7, #20]
{
  /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is in format dd.mm.yy or dd.mm.yyyy */
  const unsigned char *p;

  p = *str;
  while(*p==' ') {
    6024:	697b      	ldr	r3, [r7, #20]
    6026:	781b      	ldrb	r3, [r3, #0]
    6028:	2b20      	cmp	r3, #32
    602a:	d0f8      	beq.n	601e <UTIL1_ScanDate+0x16>
    p++; /* skip leading spaces */
  }
  if (   UTIL1_ScanDecimal8uNumber(&p, day)==ERR_OK
    602c:	f107 0314 	add.w	r3, r7, #20
    6030:	4618      	mov	r0, r3
    6032:	68b9      	ldr	r1, [r7, #8]
    6034:	f000 f918 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    6038:	4603      	mov	r3, r0
    603a:	2b00      	cmp	r3, #0
    603c:	d151      	bne.n	60e2 <UTIL1_ScanDate+0xda>
      && *day > 0 && *day <= 31
    603e:	68bb      	ldr	r3, [r7, #8]
    6040:	781b      	ldrb	r3, [r3, #0]
    6042:	2b00      	cmp	r3, #0
    6044:	d04d      	beq.n	60e2 <UTIL1_ScanDate+0xda>
    6046:	68bb      	ldr	r3, [r7, #8]
    6048:	781b      	ldrb	r3, [r3, #0]
    604a:	2b1f      	cmp	r3, #31
    604c:	d849      	bhi.n	60e2 <UTIL1_ScanDate+0xda>
      && (*p=='.' || *p=='-')
    604e:	697b      	ldr	r3, [r7, #20]
    6050:	781b      	ldrb	r3, [r3, #0]
    6052:	2b2e      	cmp	r3, #46	; 0x2e
    6054:	d003      	beq.n	605e <UTIL1_ScanDate+0x56>
    6056:	697b      	ldr	r3, [r7, #20]
    6058:	781b      	ldrb	r3, [r3, #0]
    605a:	2b2d      	cmp	r3, #45	; 0x2d
    605c:	d141      	bne.n	60e2 <UTIL1_ScanDate+0xda>
     )
  {
    p++;
    605e:	697b      	ldr	r3, [r7, #20]
    6060:	3301      	adds	r3, #1
    6062:	617b      	str	r3, [r7, #20]
    if (   UTIL1_ScanDecimal8uNumber(&p, month)==ERR_OK
    6064:	f107 0314 	add.w	r3, r7, #20
    6068:	4618      	mov	r0, r3
    606a:	6879      	ldr	r1, [r7, #4]
    606c:	f000 f8fc 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    6070:	4603      	mov	r3, r0
    6072:	2b00      	cmp	r3, #0
    6074:	d135      	bne.n	60e2 <UTIL1_ScanDate+0xda>
        && *month > 0 && *month <= 12
    6076:	687b      	ldr	r3, [r7, #4]
    6078:	781b      	ldrb	r3, [r3, #0]
    607a:	2b00      	cmp	r3, #0
    607c:	d031      	beq.n	60e2 <UTIL1_ScanDate+0xda>
    607e:	687b      	ldr	r3, [r7, #4]
    6080:	781b      	ldrb	r3, [r3, #0]
    6082:	2b0c      	cmp	r3, #12
    6084:	d82d      	bhi.n	60e2 <UTIL1_ScanDate+0xda>
        && (*p=='.' || *p=='-')
    6086:	697b      	ldr	r3, [r7, #20]
    6088:	781b      	ldrb	r3, [r3, #0]
    608a:	2b2e      	cmp	r3, #46	; 0x2e
    608c:	d003      	beq.n	6096 <UTIL1_ScanDate+0x8e>
    608e:	697b      	ldr	r3, [r7, #20]
    6090:	781b      	ldrb	r3, [r3, #0]
    6092:	2b2d      	cmp	r3, #45	; 0x2d
    6094:	d125      	bne.n	60e2 <UTIL1_ScanDate+0xda>
       )
    {
      p++;
    6096:	697b      	ldr	r3, [r7, #20]
    6098:	3301      	adds	r3, #1
    609a:	617b      	str	r3, [r7, #20]
      if (   UTIL1_ScanDecimal16uNumber(&p, year)==ERR_OK
    609c:	f107 0314 	add.w	r3, r7, #20
    60a0:	4618      	mov	r0, r3
    60a2:	6839      	ldr	r1, [r7, #0]
    60a4:	f000 f96e 	bl	6384 <UTIL1_ScanDecimal16uNumber>
    60a8:	4603      	mov	r3, r0
    60aa:	2b00      	cmp	r3, #0
    60ac:	d119      	bne.n	60e2 <UTIL1_ScanDate+0xda>
          && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
    60ae:	683b      	ldr	r3, [r7, #0]
    60b0:	881b      	ldrh	r3, [r3, #0]
    60b2:	2b00      	cmp	r3, #0
    60b4:	d015      	beq.n	60e2 <UTIL1_ScanDate+0xda>
    60b6:	683b      	ldr	r3, [r7, #0]
    60b8:	881a      	ldrh	r2, [r3, #0]
    60ba:	f640 33b8 	movw	r3, #3000	; 0xbb8
    60be:	429a      	cmp	r2, r3
    60c0:	d80f      	bhi.n	60e2 <UTIL1_ScanDate+0xda>
         )
      {
        if (*year < 100) {
    60c2:	683b      	ldr	r3, [r7, #0]
    60c4:	881b      	ldrh	r3, [r3, #0]
    60c6:	2b63      	cmp	r3, #99	; 0x63
    60c8:	d806      	bhi.n	60d8 <UTIL1_ScanDate+0xd0>
          *year += 2000; /* transform '10' into '2010' */
    60ca:	683b      	ldr	r3, [r7, #0]
    60cc:	881b      	ldrh	r3, [r3, #0]
    60ce:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
    60d2:	b29a      	uxth	r2, r3
    60d4:	683b      	ldr	r3, [r7, #0]
    60d6:	801a      	strh	r2, [r3, #0]
        }
        *str = p; /* advance pointer for caller */
    60d8:	697a      	ldr	r2, [r7, #20]
    60da:	68fb      	ldr	r3, [r7, #12]
    60dc:	601a      	str	r2, [r3, #0]
        return ERR_OK;
    60de:	2300      	movs	r3, #0
    60e0:	e009      	b.n	60f6 <UTIL1_ScanDate+0xee>
      }
    }
  }
  *day = 0;
    60e2:	68bb      	ldr	r3, [r7, #8]
    60e4:	2200      	movs	r2, #0
    60e6:	701a      	strb	r2, [r3, #0]
  *month = 0;
    60e8:	687b      	ldr	r3, [r7, #4]
    60ea:	2200      	movs	r2, #0
    60ec:	701a      	strb	r2, [r3, #0]
  *year = 0;
    60ee:	683b      	ldr	r3, [r7, #0]
    60f0:	2200      	movs	r2, #0
    60f2:	801a      	strh	r2, [r3, #0]
  return ERR_FAILED; /* wrong format */
    60f4:	231b      	movs	r3, #27
}
    60f6:	4618      	mov	r0, r3
    60f8:	3718      	adds	r7, #24
    60fa:	46bd      	mov	sp, r7
    60fc:	bd80      	pop	{r7, pc}
    60fe:	bf00      	nop

00006100 <UTIL1_ScanTime>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanTime(const unsigned char **str, uint8_t *hour, uint8_t *minute, uint8_t *second, uint8_t *hSecond)
{
    6100:	b580      	push	{r7, lr}
    6102:	b086      	sub	sp, #24
    6104:	af00      	add	r7, sp, #0
    6106:	60f8      	str	r0, [r7, #12]
    6108:	60b9      	str	r1, [r7, #8]
    610a:	607a      	str	r2, [r7, #4]
    610c:	603b      	str	r3, [r7, #0]
  /* precondition: string points to starting of time string, e.g. "03:15:05" or "03:15:05,3" or "03:15:05,17", and time is in format hh:mm:ss[,hh] */
  const unsigned char *p;
  #define SCAN_IS_DIGIT(ch) ((ch)>='0'&&(ch)<='9')

  *hour = 0;
    610e:	68bb      	ldr	r3, [r7, #8]
    6110:	2200      	movs	r2, #0
    6112:	701a      	strb	r2, [r3, #0]
  *minute = 0;
    6114:	687b      	ldr	r3, [r7, #4]
    6116:	2200      	movs	r2, #0
    6118:	701a      	strb	r2, [r3, #0]
  *second = 0;
    611a:	683b      	ldr	r3, [r7, #0]
    611c:	2200      	movs	r2, #0
    611e:	701a      	strb	r2, [r3, #0]
  *hSecond = 0;
    6120:	6a3b      	ldr	r3, [r7, #32]
    6122:	2200      	movs	r2, #0
    6124:	701a      	strb	r2, [r3, #0]
  p = *str;
    6126:	68fb      	ldr	r3, [r7, #12]
    6128:	681b      	ldr	r3, [r3, #0]
    612a:	617b      	str	r3, [r7, #20]
  while(*p==' ') {
    612c:	e002      	b.n	6134 <UTIL1_ScanTime+0x34>
    p++; /* skip leading spaces */
    612e:	697b      	ldr	r3, [r7, #20]
    6130:	3301      	adds	r3, #1
    6132:	617b      	str	r3, [r7, #20]
  *hour = 0;
  *minute = 0;
  *second = 0;
  *hSecond = 0;
  p = *str;
  while(*p==' ') {
    6134:	697b      	ldr	r3, [r7, #20]
    6136:	781b      	ldrb	r3, [r3, #0]
    6138:	2b20      	cmp	r3, #32
    613a:	d0f8      	beq.n	612e <UTIL1_ScanTime+0x2e>
    p++; /* skip leading spaces */
  }
  if (   UTIL1_ScanDecimal8uNumber(&p, hour)==ERR_OK
    613c:	f107 0314 	add.w	r3, r7, #20
    6140:	4618      	mov	r0, r3
    6142:	68b9      	ldr	r1, [r7, #8]
    6144:	f000 f890 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    6148:	4603      	mov	r3, r0
    614a:	2b00      	cmp	r3, #0
    614c:	f040 8087 	bne.w	625e <UTIL1_ScanTime+0x15e>
      && *hour <= 24
    6150:	68bb      	ldr	r3, [r7, #8]
    6152:	781b      	ldrb	r3, [r3, #0]
    6154:	2b18      	cmp	r3, #24
    6156:	f200 8082 	bhi.w	625e <UTIL1_ScanTime+0x15e>
      && *p==':'
    615a:	697b      	ldr	r3, [r7, #20]
    615c:	781b      	ldrb	r3, [r3, #0]
    615e:	2b3a      	cmp	r3, #58	; 0x3a
    6160:	d17d      	bne.n	625e <UTIL1_ScanTime+0x15e>
     )
  {
    p++; /* skip ':' */
    6162:	697b      	ldr	r3, [r7, #20]
    6164:	3301      	adds	r3, #1
    6166:	617b      	str	r3, [r7, #20]
    if (   UTIL1_ScanDecimal8uNumber(&p, minute)==ERR_OK
    6168:	f107 0314 	add.w	r3, r7, #20
    616c:	4618      	mov	r0, r3
    616e:	6879      	ldr	r1, [r7, #4]
    6170:	f000 f87a 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    6174:	4603      	mov	r3, r0
    6176:	2b00      	cmp	r3, #0
    6178:	d171      	bne.n	625e <UTIL1_ScanTime+0x15e>
        && *minute <= 60
    617a:	687b      	ldr	r3, [r7, #4]
    617c:	781b      	ldrb	r3, [r3, #0]
    617e:	2b3c      	cmp	r3, #60	; 0x3c
    6180:	d86d      	bhi.n	625e <UTIL1_ScanTime+0x15e>
       )
    {
      if (*p==':') { /* there is more after the minute */
    6182:	697b      	ldr	r3, [r7, #20]
    6184:	781b      	ldrb	r3, [r3, #0]
    6186:	2b3a      	cmp	r3, #58	; 0x3a
    6188:	d15c      	bne.n	6244 <UTIL1_ScanTime+0x144>
        p++; /* skip ':' */
    618a:	697b      	ldr	r3, [r7, #20]
    618c:	3301      	adds	r3, #1
    618e:	617b      	str	r3, [r7, #20]
        if (   UTIL1_ScanDecimal8uNumber(&p, second)==ERR_OK
    6190:	f107 0314 	add.w	r3, r7, #20
    6194:	4618      	mov	r0, r3
    6196:	6839      	ldr	r1, [r7, #0]
    6198:	f000 f866 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    619c:	4603      	mov	r3, r0
    619e:	2b00      	cmp	r3, #0
    61a0:	d15d      	bne.n	625e <UTIL1_ScanTime+0x15e>
            && *second <= 60
    61a2:	683b      	ldr	r3, [r7, #0]
    61a4:	781b      	ldrb	r3, [r3, #0]
    61a6:	2b3c      	cmp	r3, #60	; 0x3c
    61a8:	d859      	bhi.n	625e <UTIL1_ScanTime+0x15e>
           )
        {
          if (*p==',') { /* we do have either ",z" or ",hh" */
    61aa:	697b      	ldr	r3, [r7, #20]
    61ac:	781b      	ldrb	r3, [r3, #0]
    61ae:	2b2c      	cmp	r3, #44	; 0x2c
    61b0:	d143      	bne.n	623a <UTIL1_ScanTime+0x13a>
            p++; /* skip ',' */
    61b2:	697b      	ldr	r3, [r7, #20]
    61b4:	3301      	adds	r3, #1
    61b6:	617b      	str	r3, [r7, #20]
            if (SCAN_IS_DIGIT(*p)) {
    61b8:	697b      	ldr	r3, [r7, #20]
    61ba:	781b      	ldrb	r3, [r3, #0]
    61bc:	2b2f      	cmp	r3, #47	; 0x2f
    61be:	d93a      	bls.n	6236 <UTIL1_ScanTime+0x136>
    61c0:	697b      	ldr	r3, [r7, #20]
    61c2:	781b      	ldrb	r3, [r3, #0]
    61c4:	2b39      	cmp	r3, #57	; 0x39
    61c6:	d836      	bhi.n	6236 <UTIL1_ScanTime+0x136>
              if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
    61c8:	697b      	ldr	r3, [r7, #20]
    61ca:	3301      	adds	r3, #1
    61cc:	781b      	ldrb	r3, [r3, #0]
    61ce:	2b2f      	cmp	r3, #47	; 0x2f
    61d0:	d91e      	bls.n	6210 <UTIL1_ScanTime+0x110>
    61d2:	697b      	ldr	r3, [r7, #20]
    61d4:	3301      	adds	r3, #1
    61d6:	781b      	ldrb	r3, [r3, #0]
    61d8:	2b39      	cmp	r3, #57	; 0x39
    61da:	d819      	bhi.n	6210 <UTIL1_ScanTime+0x110>
                *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
    61dc:	697b      	ldr	r3, [r7, #20]
    61de:	781b      	ldrb	r3, [r3, #0]
    61e0:	3b30      	subs	r3, #48	; 0x30
    61e2:	b2db      	uxtb	r3, r3
    61e4:	461a      	mov	r2, r3
    61e6:	0092      	lsls	r2, r2, #2
    61e8:	4413      	add	r3, r2
    61ea:	005b      	lsls	r3, r3, #1
    61ec:	b2da      	uxtb	r2, r3
    61ee:	697b      	ldr	r3, [r7, #20]
    61f0:	3301      	adds	r3, #1
    61f2:	781b      	ldrb	r3, [r3, #0]
    61f4:	4413      	add	r3, r2
    61f6:	b2db      	uxtb	r3, r3
    61f8:	3b30      	subs	r3, #48	; 0x30
    61fa:	b2da      	uxtb	r2, r3
    61fc:	6a3b      	ldr	r3, [r7, #32]
    61fe:	701a      	strb	r2, [r3, #0]
                p++; p++;
    6200:	697b      	ldr	r3, [r7, #20]
    6202:	3301      	adds	r3, #1
    6204:	617b      	str	r3, [r7, #20]
    6206:	697b      	ldr	r3, [r7, #20]
    6208:	3301      	adds	r3, #1
    620a:	617b      	str	r3, [r7, #20]
                return ERR_OK;
    620c:	2300      	movs	r3, #0
    620e:	e027      	b.n	6260 <UTIL1_ScanTime+0x160>
              } else { /* ,z format */
                *hSecond = (uint8_t)((*p-'0')*10);
    6210:	697b      	ldr	r3, [r7, #20]
    6212:	781b      	ldrb	r3, [r3, #0]
    6214:	3b30      	subs	r3, #48	; 0x30
    6216:	b2db      	uxtb	r3, r3
    6218:	461a      	mov	r2, r3
    621a:	0092      	lsls	r2, r2, #2
    621c:	4413      	add	r3, r2
    621e:	005b      	lsls	r3, r3, #1
    6220:	b2da      	uxtb	r2, r3
    6222:	6a3b      	ldr	r3, [r7, #32]
    6224:	701a      	strb	r2, [r3, #0]
                p++;
    6226:	697b      	ldr	r3, [r7, #20]
    6228:	3301      	adds	r3, #1
    622a:	617b      	str	r3, [r7, #20]
                *str = p; /* advance pointer for caller */
    622c:	697a      	ldr	r2, [r7, #20]
    622e:	68fb      	ldr	r3, [r7, #12]
    6230:	601a      	str	r2, [r3, #0]
                return ERR_OK;
    6232:	2300      	movs	r3, #0
    6234:	e014      	b.n	6260 <UTIL1_ScanTime+0x160>
              }
            } else {
              return ERR_FAILED; /* illegal format, not a number, e.g. ",x" */
    6236:	231b      	movs	r3, #27
    6238:	e012      	b.n	6260 <UTIL1_ScanTime+0x160>
            }
          }
          *str = p; /* advance pointer for caller */
    623a:	697a      	ldr	r2, [r7, #20]
    623c:	68fb      	ldr	r3, [r7, #12]
    623e:	601a      	str	r2, [r3, #0]
          return ERR_OK;
    6240:	2300      	movs	r3, #0
    6242:	e00d      	b.n	6260 <UTIL1_ScanTime+0x160>
        }
      } else if (*p==' ' || *p=='\0') { /* nothing more after the minute? Assume zero seconds */
    6244:	697b      	ldr	r3, [r7, #20]
    6246:	781b      	ldrb	r3, [r3, #0]
    6248:	2b20      	cmp	r3, #32
    624a:	d003      	beq.n	6254 <UTIL1_ScanTime+0x154>
    624c:	697b      	ldr	r3, [r7, #20]
    624e:	781b      	ldrb	r3, [r3, #0]
    6250:	2b00      	cmp	r3, #0
    6252:	d104      	bne.n	625e <UTIL1_ScanTime+0x15e>
        *str = p; /* advance pointer for caller */
    6254:	697a      	ldr	r2, [r7, #20]
    6256:	68fb      	ldr	r3, [r7, #12]
    6258:	601a      	str	r2, [r3, #0]
        return ERR_OK;
    625a:	2300      	movs	r3, #0
    625c:	e000      	b.n	6260 <UTIL1_ScanTime+0x160>
      }
    }
  }
  return ERR_FAILED; /* wrong format */
    625e:	231b      	movs	r3, #27
}
    6260:	4618      	mov	r0, r3
    6262:	3718      	adds	r7, #24
    6264:	46bd      	mov	sp, r7
    6266:	bd80      	pop	{r7, pc}

00006268 <UTIL1_ScanDecimal8uNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal8uNumber(const unsigned char **str, uint8_t *val)
{
    6268:	b480      	push	{r7}
    626a:	b085      	sub	sp, #20
    626c:	af00      	add	r7, sp, #0
    626e:	6078      	str	r0, [r7, #4]
    6270:	6039      	str	r1, [r7, #0]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _8_NOF_DIGITS  (3+1)
  uint8_t nofDigits = _8_NOF_DIGITS; /* maximum number of digits to avoid overflow */
    6272:	2304      	movs	r3, #4
    6274:	73fb      	strb	r3, [r7, #15]
  const unsigned char *p = *str;
    6276:	687b      	ldr	r3, [r7, #4]
    6278:	681b      	ldr	r3, [r3, #0]
    627a:	60bb      	str	r3, [r7, #8]

  while(*p==' ') { /* skip leading spaces */
    627c:	e002      	b.n	6284 <UTIL1_ScanDecimal8uNumber+0x1c>
    p++;
    627e:	68bb      	ldr	r3, [r7, #8]
    6280:	3301      	adds	r3, #1
    6282:	60bb      	str	r3, [r7, #8]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _8_NOF_DIGITS  (3+1)
  uint8_t nofDigits = _8_NOF_DIGITS; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    6284:	68bb      	ldr	r3, [r7, #8]
    6286:	781b      	ldrb	r3, [r3, #0]
    6288:	2b20      	cmp	r3, #32
    628a:	d0f8      	beq.n	627e <UTIL1_ScanDecimal8uNumber+0x16>
    p++;
  }
  *val = 0;
    628c:	683b      	ldr	r3, [r7, #0]
    628e:	2200      	movs	r2, #0
    6290:	701a      	strb	r2, [r3, #0]
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    6292:	e014      	b.n	62be <UTIL1_ScanDecimal8uNumber+0x56>
    *val = (uint8_t)((*val)*10 + *p-'0');
    6294:	683b      	ldr	r3, [r7, #0]
    6296:	781b      	ldrb	r3, [r3, #0]
    6298:	461a      	mov	r2, r3
    629a:	0092      	lsls	r2, r2, #2
    629c:	4413      	add	r3, r2
    629e:	005b      	lsls	r3, r3, #1
    62a0:	b2da      	uxtb	r2, r3
    62a2:	68bb      	ldr	r3, [r7, #8]
    62a4:	781b      	ldrb	r3, [r3, #0]
    62a6:	4413      	add	r3, r2
    62a8:	b2db      	uxtb	r3, r3
    62aa:	3b30      	subs	r3, #48	; 0x30
    62ac:	b2da      	uxtb	r2, r3
    62ae:	683b      	ldr	r3, [r7, #0]
    62b0:	701a      	strb	r2, [r3, #0]
    nofDigits--;
    62b2:	7bfb      	ldrb	r3, [r7, #15]
    62b4:	3b01      	subs	r3, #1
    62b6:	73fb      	strb	r3, [r7, #15]
    p++;
    62b8:	68bb      	ldr	r3, [r7, #8]
    62ba:	3301      	adds	r3, #1
    62bc:	60bb      	str	r3, [r7, #8]

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    62be:	68bb      	ldr	r3, [r7, #8]
    62c0:	781b      	ldrb	r3, [r3, #0]
    62c2:	2b2f      	cmp	r3, #47	; 0x2f
    62c4:	d906      	bls.n	62d4 <UTIL1_ScanDecimal8uNumber+0x6c>
    62c6:	68bb      	ldr	r3, [r7, #8]
    62c8:	781b      	ldrb	r3, [r3, #0]
    62ca:	2b39      	cmp	r3, #57	; 0x39
    62cc:	d802      	bhi.n	62d4 <UTIL1_ScanDecimal8uNumber+0x6c>
    62ce:	7bfb      	ldrb	r3, [r7, #15]
    62d0:	2b00      	cmp	r3, #0
    62d2:	d1df      	bne.n	6294 <UTIL1_ScanDecimal8uNumber+0x2c>
    *val = (uint8_t)((*val)*10 + *p-'0');
    nofDigits--;
    p++;
  } /* while */
  if (nofDigits==0) {
    62d4:	7bfb      	ldrb	r3, [r7, #15]
    62d6:	2b00      	cmp	r3, #0
    62d8:	d101      	bne.n	62de <UTIL1_ScanDecimal8uNumber+0x76>
    return ERR_OVERFLOW;
    62da:	2304      	movs	r3, #4
    62dc:	e008      	b.n	62f0 <UTIL1_ScanDecimal8uNumber+0x88>
  }
  if (nofDigits==_8_NOF_DIGITS) { /* no digits at all? */
    62de:	7bfb      	ldrb	r3, [r7, #15]
    62e0:	2b04      	cmp	r3, #4
    62e2:	d101      	bne.n	62e8 <UTIL1_ScanDecimal8uNumber+0x80>
    return ERR_FAILED;
    62e4:	231b      	movs	r3, #27
    62e6:	e003      	b.n	62f0 <UTIL1_ScanDecimal8uNumber+0x88>
  }
  *str = p;
    62e8:	687b      	ldr	r3, [r7, #4]
    62ea:	68ba      	ldr	r2, [r7, #8]
    62ec:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    62ee:	2300      	movs	r3, #0
}
    62f0:	4618      	mov	r0, r3
    62f2:	3714      	adds	r7, #20
    62f4:	46bd      	mov	sp, r7
    62f6:	f85d 7b04 	ldr.w	r7, [sp], #4
    62fa:	4770      	bx	lr

000062fc <UTIL1_ScanDecimal8sNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal8sNumber(const unsigned char **str, signed char *val)
{
    62fc:	b580      	push	{r7, lr}
    62fe:	b086      	sub	sp, #24
    6300:	af00      	add	r7, sp, #0
    6302:	6078      	str	r0, [r7, #4]
    6304:	6039      	str	r1, [r7, #0]
  /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
  const unsigned char *p = *str;
    6306:	687b      	ldr	r3, [r7, #4]
    6308:	681b      	ldr	r3, [r3, #0]
    630a:	613b      	str	r3, [r7, #16]
  bool isNeg;
  uint8_t val8u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    630c:	e002      	b.n	6314 <UTIL1_ScanDecimal8sNumber+0x18>
    p++;
    630e:	693b      	ldr	r3, [r7, #16]
    6310:	3301      	adds	r3, #1
    6312:	613b      	str	r3, [r7, #16]
  const unsigned char *p = *str;
  bool isNeg;
  uint8_t val8u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    6314:	693b      	ldr	r3, [r7, #16]
    6316:	781b      	ldrb	r3, [r3, #0]
    6318:	2b20      	cmp	r3, #32
    631a:	d0f8      	beq.n	630e <UTIL1_ScanDecimal8sNumber+0x12>
    p++;
  }
  *val = 0;
    631c:	683b      	ldr	r3, [r7, #0]
    631e:	2200      	movs	r2, #0
    6320:	701a      	strb	r2, [r3, #0]
  if (*p=='-') {
    6322:	693b      	ldr	r3, [r7, #16]
    6324:	781b      	ldrb	r3, [r3, #0]
    6326:	2b2d      	cmp	r3, #45	; 0x2d
    6328:	d105      	bne.n	6336 <UTIL1_ScanDecimal8sNumber+0x3a>
    isNeg = TRUE;
    632a:	2301      	movs	r3, #1
    632c:	75fb      	strb	r3, [r7, #23]
    p++; /* skip minus */
    632e:	693b      	ldr	r3, [r7, #16]
    6330:	3301      	adds	r3, #1
    6332:	613b      	str	r3, [r7, #16]
    6334:	e001      	b.n	633a <UTIL1_ScanDecimal8sNumber+0x3e>
  } else {
    isNeg = FALSE;
    6336:	2300      	movs	r3, #0
    6338:	75fb      	strb	r3, [r7, #23]
  }
  res = UTIL1_ScanDecimal8uNumber(&p, &val8u);
    633a:	f107 0210 	add.w	r2, r7, #16
    633e:	f107 030f 	add.w	r3, r7, #15
    6342:	4610      	mov	r0, r2
    6344:	4619      	mov	r1, r3
    6346:	f7ff ff8f 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    634a:	4603      	mov	r3, r0
    634c:	75bb      	strb	r3, [r7, #22]
  if (res != ERR_OK) {
    634e:	7dbb      	ldrb	r3, [r7, #22]
    6350:	2b00      	cmp	r3, #0
    6352:	d001      	beq.n	6358 <UTIL1_ScanDecimal8sNumber+0x5c>
    return res;
    6354:	7dbb      	ldrb	r3, [r7, #22]
    6356:	e011      	b.n	637c <UTIL1_ScanDecimal8sNumber+0x80>
  }
  if (isNeg) {
    6358:	7dfb      	ldrb	r3, [r7, #23]
    635a:	2b00      	cmp	r3, #0
    635c:	d006      	beq.n	636c <UTIL1_ScanDecimal8sNumber+0x70>
    *val = - (int8_t)val8u;
    635e:	7bfb      	ldrb	r3, [r7, #15]
    6360:	425b      	negs	r3, r3
    6362:	b2db      	uxtb	r3, r3
    6364:	b2da      	uxtb	r2, r3
    6366:	683b      	ldr	r3, [r7, #0]
    6368:	701a      	strb	r2, [r3, #0]
    636a:	e003      	b.n	6374 <UTIL1_ScanDecimal8sNumber+0x78>
  } else {
    *val = (int8_t)val8u;
    636c:	7bfb      	ldrb	r3, [r7, #15]
    636e:	b2da      	uxtb	r2, r3
    6370:	683b      	ldr	r3, [r7, #0]
    6372:	701a      	strb	r2, [r3, #0]
  }
  *str = p;
    6374:	693a      	ldr	r2, [r7, #16]
    6376:	687b      	ldr	r3, [r7, #4]
    6378:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    637a:	2300      	movs	r3, #0
}
    637c:	4618      	mov	r0, r3
    637e:	3718      	adds	r7, #24
    6380:	46bd      	mov	sp, r7
    6382:	bd80      	pop	{r7, pc}

00006384 <UTIL1_ScanDecimal16uNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal16uNumber(const unsigned char **str, uint16_t *val)
{
    6384:	b480      	push	{r7}
    6386:	b085      	sub	sp, #20
    6388:	af00      	add	r7, sp, #0
    638a:	6078      	str	r0, [r7, #4]
    638c:	6039      	str	r1, [r7, #0]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _16_NOF_DIGITS  (5+1)
  uint8_t nofDigits = _16_NOF_DIGITS; /* maximum number of digits to avoid overflow */
    638e:	2306      	movs	r3, #6
    6390:	73fb      	strb	r3, [r7, #15]
  const unsigned char *p = *str;
    6392:	687b      	ldr	r3, [r7, #4]
    6394:	681b      	ldr	r3, [r3, #0]
    6396:	60bb      	str	r3, [r7, #8]

  while(*p==' ') { /* skip leading spaces */
    6398:	e002      	b.n	63a0 <UTIL1_ScanDecimal16uNumber+0x1c>
    p++;
    639a:	68bb      	ldr	r3, [r7, #8]
    639c:	3301      	adds	r3, #1
    639e:	60bb      	str	r3, [r7, #8]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _16_NOF_DIGITS  (5+1)
  uint8_t nofDigits = _16_NOF_DIGITS; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    63a0:	68bb      	ldr	r3, [r7, #8]
    63a2:	781b      	ldrb	r3, [r3, #0]
    63a4:	2b20      	cmp	r3, #32
    63a6:	d0f8      	beq.n	639a <UTIL1_ScanDecimal16uNumber+0x16>
    p++;
  }
  *val = 0;
    63a8:	683b      	ldr	r3, [r7, #0]
    63aa:	2200      	movs	r2, #0
    63ac:	801a      	strh	r2, [r3, #0]
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    63ae:	e014      	b.n	63da <UTIL1_ScanDecimal16uNumber+0x56>
    *val = (uint16_t)((*val)*10 + *p-'0');
    63b0:	683b      	ldr	r3, [r7, #0]
    63b2:	881b      	ldrh	r3, [r3, #0]
    63b4:	461a      	mov	r2, r3
    63b6:	0092      	lsls	r2, r2, #2
    63b8:	4413      	add	r3, r2
    63ba:	005b      	lsls	r3, r3, #1
    63bc:	b29a      	uxth	r2, r3
    63be:	68bb      	ldr	r3, [r7, #8]
    63c0:	781b      	ldrb	r3, [r3, #0]
    63c2:	4413      	add	r3, r2
    63c4:	b29b      	uxth	r3, r3
    63c6:	3b30      	subs	r3, #48	; 0x30
    63c8:	b29a      	uxth	r2, r3
    63ca:	683b      	ldr	r3, [r7, #0]
    63cc:	801a      	strh	r2, [r3, #0]
    nofDigits--;
    63ce:	7bfb      	ldrb	r3, [r7, #15]
    63d0:	3b01      	subs	r3, #1
    63d2:	73fb      	strb	r3, [r7, #15]
    p++;
    63d4:	68bb      	ldr	r3, [r7, #8]
    63d6:	3301      	adds	r3, #1
    63d8:	60bb      	str	r3, [r7, #8]

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    63da:	68bb      	ldr	r3, [r7, #8]
    63dc:	781b      	ldrb	r3, [r3, #0]
    63de:	2b2f      	cmp	r3, #47	; 0x2f
    63e0:	d906      	bls.n	63f0 <UTIL1_ScanDecimal16uNumber+0x6c>
    63e2:	68bb      	ldr	r3, [r7, #8]
    63e4:	781b      	ldrb	r3, [r3, #0]
    63e6:	2b39      	cmp	r3, #57	; 0x39
    63e8:	d802      	bhi.n	63f0 <UTIL1_ScanDecimal16uNumber+0x6c>
    63ea:	7bfb      	ldrb	r3, [r7, #15]
    63ec:	2b00      	cmp	r3, #0
    63ee:	d1df      	bne.n	63b0 <UTIL1_ScanDecimal16uNumber+0x2c>
    *val = (uint16_t)((*val)*10 + *p-'0');
    nofDigits--;
    p++;
  } /* while */
  if (nofDigits==0) {
    63f0:	7bfb      	ldrb	r3, [r7, #15]
    63f2:	2b00      	cmp	r3, #0
    63f4:	d101      	bne.n	63fa <UTIL1_ScanDecimal16uNumber+0x76>
    return ERR_OVERFLOW;
    63f6:	2304      	movs	r3, #4
    63f8:	e008      	b.n	640c <UTIL1_ScanDecimal16uNumber+0x88>
  }
  if (nofDigits==_16_NOF_DIGITS) { /* no digits at all? */
    63fa:	7bfb      	ldrb	r3, [r7, #15]
    63fc:	2b06      	cmp	r3, #6
    63fe:	d101      	bne.n	6404 <UTIL1_ScanDecimal16uNumber+0x80>
    return ERR_FAILED;
    6400:	231b      	movs	r3, #27
    6402:	e003      	b.n	640c <UTIL1_ScanDecimal16uNumber+0x88>
  }
  *str = p;
    6404:	687b      	ldr	r3, [r7, #4]
    6406:	68ba      	ldr	r2, [r7, #8]
    6408:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    640a:	2300      	movs	r3, #0
}
    640c:	4618      	mov	r0, r3
    640e:	3714      	adds	r7, #20
    6410:	46bd      	mov	sp, r7
    6412:	f85d 7b04 	ldr.w	r7, [sp], #4
    6416:	4770      	bx	lr

00006418 <UTIL1_ScanDecimal16sNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal16sNumber(const unsigned char **str, int16_t *val)
{
    6418:	b580      	push	{r7, lr}
    641a:	b086      	sub	sp, #24
    641c:	af00      	add	r7, sp, #0
    641e:	6078      	str	r0, [r7, #4]
    6420:	6039      	str	r1, [r7, #0]
  /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
  const unsigned char *p = *str;
    6422:	687b      	ldr	r3, [r7, #4]
    6424:	681b      	ldr	r3, [r3, #0]
    6426:	613b      	str	r3, [r7, #16]
  bool isNeg;
  uint16_t val16u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    6428:	e002      	b.n	6430 <UTIL1_ScanDecimal16sNumber+0x18>
    p++;
    642a:	693b      	ldr	r3, [r7, #16]
    642c:	3301      	adds	r3, #1
    642e:	613b      	str	r3, [r7, #16]
  const unsigned char *p = *str;
  bool isNeg;
  uint16_t val16u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    6430:	693b      	ldr	r3, [r7, #16]
    6432:	781b      	ldrb	r3, [r3, #0]
    6434:	2b20      	cmp	r3, #32
    6436:	d0f8      	beq.n	642a <UTIL1_ScanDecimal16sNumber+0x12>
    p++;
  }
  *val = 0;
    6438:	683b      	ldr	r3, [r7, #0]
    643a:	2200      	movs	r2, #0
    643c:	801a      	strh	r2, [r3, #0]
  if (*p=='-') {
    643e:	693b      	ldr	r3, [r7, #16]
    6440:	781b      	ldrb	r3, [r3, #0]
    6442:	2b2d      	cmp	r3, #45	; 0x2d
    6444:	d105      	bne.n	6452 <UTIL1_ScanDecimal16sNumber+0x3a>
    isNeg = TRUE;
    6446:	2301      	movs	r3, #1
    6448:	75fb      	strb	r3, [r7, #23]
    p++; /* skip minus */
    644a:	693b      	ldr	r3, [r7, #16]
    644c:	3301      	adds	r3, #1
    644e:	613b      	str	r3, [r7, #16]
    6450:	e001      	b.n	6456 <UTIL1_ScanDecimal16sNumber+0x3e>
  } else {
    isNeg = FALSE;
    6452:	2300      	movs	r3, #0
    6454:	75fb      	strb	r3, [r7, #23]
  }
  res = UTIL1_ScanDecimal16uNumber(&p, (uint16_t*)&val16u);
    6456:	f107 0210 	add.w	r2, r7, #16
    645a:	f107 030e 	add.w	r3, r7, #14
    645e:	4610      	mov	r0, r2
    6460:	4619      	mov	r1, r3
    6462:	f7ff ff8f 	bl	6384 <UTIL1_ScanDecimal16uNumber>
    6466:	4603      	mov	r3, r0
    6468:	75bb      	strb	r3, [r7, #22]
  if (res != ERR_OK) {
    646a:	7dbb      	ldrb	r3, [r7, #22]
    646c:	2b00      	cmp	r3, #0
    646e:	d001      	beq.n	6474 <UTIL1_ScanDecimal16sNumber+0x5c>
    return res;
    6470:	7dbb      	ldrb	r3, [r7, #22]
    6472:	e011      	b.n	6498 <UTIL1_ScanDecimal16sNumber+0x80>
  }
  if (isNeg) {
    6474:	7dfb      	ldrb	r3, [r7, #23]
    6476:	2b00      	cmp	r3, #0
    6478:	d006      	beq.n	6488 <UTIL1_ScanDecimal16sNumber+0x70>
    *val = - (int16_t)val16u;
    647a:	89fb      	ldrh	r3, [r7, #14]
    647c:	425b      	negs	r3, r3
    647e:	b29b      	uxth	r3, r3
    6480:	b29a      	uxth	r2, r3
    6482:	683b      	ldr	r3, [r7, #0]
    6484:	801a      	strh	r2, [r3, #0]
    6486:	e003      	b.n	6490 <UTIL1_ScanDecimal16sNumber+0x78>
  } else {
    *val = (int16_t)val16u;
    6488:	89fb      	ldrh	r3, [r7, #14]
    648a:	b29a      	uxth	r2, r3
    648c:	683b      	ldr	r3, [r7, #0]
    648e:	801a      	strh	r2, [r3, #0]
  }
  *str = p;
    6490:	693a      	ldr	r2, [r7, #16]
    6492:	687b      	ldr	r3, [r7, #4]
    6494:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    6496:	2300      	movs	r3, #0
}
    6498:	4618      	mov	r0, r3
    649a:	3718      	adds	r7, #24
    649c:	46bd      	mov	sp, r7
    649e:	bd80      	pop	{r7, pc}

000064a0 <UTIL1_ScanDecimal32uNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal32uNumber(const unsigned char **str, uint32_t *val)
{
    64a0:	b480      	push	{r7}
    64a2:	b085      	sub	sp, #20
    64a4:	af00      	add	r7, sp, #0
    64a6:	6078      	str	r0, [r7, #4]
    64a8:	6039      	str	r1, [r7, #0]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _32_NOF_DIGITS  (10+1)
  uint8_t nofDigits = _32_NOF_DIGITS; /* maximum number of digits to avoid overflow */
    64aa:	230b      	movs	r3, #11
    64ac:	73fb      	strb	r3, [r7, #15]
  const unsigned char *p = *str;
    64ae:	687b      	ldr	r3, [r7, #4]
    64b0:	681b      	ldr	r3, [r3, #0]
    64b2:	60bb      	str	r3, [r7, #8]

  while(*p==' ') { /* skip leading spaces */
    64b4:	e002      	b.n	64bc <UTIL1_ScanDecimal32uNumber+0x1c>
    p++;
    64b6:	68bb      	ldr	r3, [r7, #8]
    64b8:	3301      	adds	r3, #1
    64ba:	60bb      	str	r3, [r7, #8]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  #define _32_NOF_DIGITS  (10+1)
  uint8_t nofDigits = _32_NOF_DIGITS; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    64bc:	68bb      	ldr	r3, [r7, #8]
    64be:	781b      	ldrb	r3, [r3, #0]
    64c0:	2b20      	cmp	r3, #32
    64c2:	d0f8      	beq.n	64b6 <UTIL1_ScanDecimal32uNumber+0x16>
    p++;
  }
  *val = 0;
    64c4:	683b      	ldr	r3, [r7, #0]
    64c6:	2200      	movs	r2, #0
    64c8:	601a      	str	r2, [r3, #0]
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    64ca:	e013      	b.n	64f4 <UTIL1_ScanDecimal32uNumber+0x54>
    *val = (uint32_t)((*val)*10 + *p-'0');
    64cc:	683b      	ldr	r3, [r7, #0]
    64ce:	681a      	ldr	r2, [r3, #0]
    64d0:	4613      	mov	r3, r2
    64d2:	009b      	lsls	r3, r3, #2
    64d4:	4413      	add	r3, r2
    64d6:	005b      	lsls	r3, r3, #1
    64d8:	461a      	mov	r2, r3
    64da:	68bb      	ldr	r3, [r7, #8]
    64dc:	781b      	ldrb	r3, [r3, #0]
    64de:	4413      	add	r3, r2
    64e0:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
    64e4:	683b      	ldr	r3, [r7, #0]
    64e6:	601a      	str	r2, [r3, #0]
    nofDigits--;
    64e8:	7bfb      	ldrb	r3, [r7, #15]
    64ea:	3b01      	subs	r3, #1
    64ec:	73fb      	strb	r3, [r7, #15]
    p++;
    64ee:	68bb      	ldr	r3, [r7, #8]
    64f0:	3301      	adds	r3, #1
    64f2:	60bb      	str	r3, [r7, #8]

  while(*p==' ') { /* skip leading spaces */
    p++;
  }
  *val = 0;
  while(*p>='0' && *p<='9' && nofDigits > 0) {
    64f4:	68bb      	ldr	r3, [r7, #8]
    64f6:	781b      	ldrb	r3, [r3, #0]
    64f8:	2b2f      	cmp	r3, #47	; 0x2f
    64fa:	d906      	bls.n	650a <UTIL1_ScanDecimal32uNumber+0x6a>
    64fc:	68bb      	ldr	r3, [r7, #8]
    64fe:	781b      	ldrb	r3, [r3, #0]
    6500:	2b39      	cmp	r3, #57	; 0x39
    6502:	d802      	bhi.n	650a <UTIL1_ScanDecimal32uNumber+0x6a>
    6504:	7bfb      	ldrb	r3, [r7, #15]
    6506:	2b00      	cmp	r3, #0
    6508:	d1e0      	bne.n	64cc <UTIL1_ScanDecimal32uNumber+0x2c>
    *val = (uint32_t)((*val)*10 + *p-'0');
    nofDigits--;
    p++;
  } /* while */
  if (nofDigits==0) {
    650a:	7bfb      	ldrb	r3, [r7, #15]
    650c:	2b00      	cmp	r3, #0
    650e:	d101      	bne.n	6514 <UTIL1_ScanDecimal32uNumber+0x74>
    return ERR_OVERFLOW;
    6510:	2304      	movs	r3, #4
    6512:	e008      	b.n	6526 <UTIL1_ScanDecimal32uNumber+0x86>
  }
  if (nofDigits==_32_NOF_DIGITS) { /* no digits at all? */
    6514:	7bfb      	ldrb	r3, [r7, #15]
    6516:	2b0b      	cmp	r3, #11
    6518:	d101      	bne.n	651e <UTIL1_ScanDecimal32uNumber+0x7e>
    return ERR_FAILED;
    651a:	231b      	movs	r3, #27
    651c:	e003      	b.n	6526 <UTIL1_ScanDecimal32uNumber+0x86>
  }
  *str = p;
    651e:	687b      	ldr	r3, [r7, #4]
    6520:	68ba      	ldr	r2, [r7, #8]
    6522:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    6524:	2300      	movs	r3, #0
}
    6526:	4618      	mov	r0, r3
    6528:	3714      	adds	r7, #20
    652a:	46bd      	mov	sp, r7
    652c:	f85d 7b04 	ldr.w	r7, [sp], #4
    6530:	4770      	bx	lr
    6532:	bf00      	nop

00006534 <UTIL1_ScanDecimal32sNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal32sNumber(const unsigned char **str, int32_t *val)
{
    6534:	b580      	push	{r7, lr}
    6536:	b086      	sub	sp, #24
    6538:	af00      	add	r7, sp, #0
    653a:	6078      	str	r0, [r7, #4]
    653c:	6039      	str	r1, [r7, #0]
  /* Scans a decimal number, and stops at any non-number. Number can have any preceding spaces. */
  const unsigned char *p = *str;
    653e:	687b      	ldr	r3, [r7, #4]
    6540:	681b      	ldr	r3, [r3, #0]
    6542:	613b      	str	r3, [r7, #16]
  bool isNeg;
  uint32_t val32u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    6544:	e002      	b.n	654c <UTIL1_ScanDecimal32sNumber+0x18>
    p++;
    6546:	693b      	ldr	r3, [r7, #16]
    6548:	3301      	adds	r3, #1
    654a:	613b      	str	r3, [r7, #16]
  const unsigned char *p = *str;
  bool isNeg;
  uint32_t val32u;
  uint8_t res;

  while(*p==' ') { /* skip leading spaces */
    654c:	693b      	ldr	r3, [r7, #16]
    654e:	781b      	ldrb	r3, [r3, #0]
    6550:	2b20      	cmp	r3, #32
    6552:	d0f8      	beq.n	6546 <UTIL1_ScanDecimal32sNumber+0x12>
    p++;
  }
  *val = 0;
    6554:	683b      	ldr	r3, [r7, #0]
    6556:	2200      	movs	r2, #0
    6558:	601a      	str	r2, [r3, #0]
  if (*p=='-') {
    655a:	693b      	ldr	r3, [r7, #16]
    655c:	781b      	ldrb	r3, [r3, #0]
    655e:	2b2d      	cmp	r3, #45	; 0x2d
    6560:	d105      	bne.n	656e <UTIL1_ScanDecimal32sNumber+0x3a>
    isNeg = TRUE;
    6562:	2301      	movs	r3, #1
    6564:	75fb      	strb	r3, [r7, #23]
    p++; /* skip minus */
    6566:	693b      	ldr	r3, [r7, #16]
    6568:	3301      	adds	r3, #1
    656a:	613b      	str	r3, [r7, #16]
    656c:	e001      	b.n	6572 <UTIL1_ScanDecimal32sNumber+0x3e>
  } else {
    isNeg = FALSE;
    656e:	2300      	movs	r3, #0
    6570:	75fb      	strb	r3, [r7, #23]
  }
  res = UTIL1_ScanDecimal32uNumber(&p, &val32u);
    6572:	f107 0210 	add.w	r2, r7, #16
    6576:	f107 030c 	add.w	r3, r7, #12
    657a:	4610      	mov	r0, r2
    657c:	4619      	mov	r1, r3
    657e:	f7ff ff8f 	bl	64a0 <UTIL1_ScanDecimal32uNumber>
    6582:	4603      	mov	r3, r0
    6584:	75bb      	strb	r3, [r7, #22]
  if (res != ERR_OK) {
    6586:	7dbb      	ldrb	r3, [r7, #22]
    6588:	2b00      	cmp	r3, #0
    658a:	d001      	beq.n	6590 <UTIL1_ScanDecimal32sNumber+0x5c>
    return res;
    658c:	7dbb      	ldrb	r3, [r7, #22]
    658e:	e00f      	b.n	65b0 <UTIL1_ScanDecimal32sNumber+0x7c>
  }
  if (isNeg) {
    6590:	7dfb      	ldrb	r3, [r7, #23]
    6592:	2b00      	cmp	r3, #0
    6594:	d004      	beq.n	65a0 <UTIL1_ScanDecimal32sNumber+0x6c>
    *val = (int32_t)(-(int32_t)val32u);
    6596:	68fb      	ldr	r3, [r7, #12]
    6598:	425a      	negs	r2, r3
    659a:	683b      	ldr	r3, [r7, #0]
    659c:	601a      	str	r2, [r3, #0]
    659e:	e003      	b.n	65a8 <UTIL1_ScanDecimal32sNumber+0x74>
  } else {
    *val = (int32_t)val32u;
    65a0:	68fb      	ldr	r3, [r7, #12]
    65a2:	461a      	mov	r2, r3
    65a4:	683b      	ldr	r3, [r7, #0]
    65a6:	601a      	str	r2, [r3, #0]
  }
  *str = p;
    65a8:	693a      	ldr	r2, [r7, #16]
    65aa:	687b      	ldr	r3, [r7, #4]
    65ac:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    65ae:	2300      	movs	r3, #0
}
    65b0:	4618      	mov	r0, r3
    65b2:	3718      	adds	r7, #24
    65b4:	46bd      	mov	sp, r7
    65b6:	bd80      	pop	{r7, pc}

000065b8 <UTIL1_ScanDecimal32sDotNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDecimal32sDotNumber(const unsigned char **str, int32_t *integral, uint32_t *fractional, uint8_t *nofFractionalZeros)
{
    65b8:	b580      	push	{r7, lr}
    65ba:	b086      	sub	sp, #24
    65bc:	af00      	add	r7, sp, #0
    65be:	60f8      	str	r0, [r7, #12]
    65c0:	60b9      	str	r1, [r7, #8]
    65c2:	607a      	str	r2, [r7, #4]
    65c4:	603b      	str	r3, [r7, #0]
  /* scans e.g. "-3445.071" and returns -3445 in integral part, and 71 in fractional part */
  uint8_t res;
  const unsigned char *p = *str;
    65c6:	68fb      	ldr	r3, [r7, #12]
    65c8:	681b      	ldr	r3, [r3, #0]
    65ca:	613b      	str	r3, [r7, #16]

  *integral = 0;
    65cc:	68bb      	ldr	r3, [r7, #8]
    65ce:	2200      	movs	r2, #0
    65d0:	601a      	str	r2, [r3, #0]
  *fractional = 0;
    65d2:	687b      	ldr	r3, [r7, #4]
    65d4:	2200      	movs	r2, #0
    65d6:	601a      	str	r2, [r3, #0]
  *nofFractionalZeros = 0;
    65d8:	683b      	ldr	r3, [r7, #0]
    65da:	2200      	movs	r2, #0
    65dc:	701a      	strb	r2, [r3, #0]
  res = UTIL1_ScanDecimal32sNumber(&p, integral);
    65de:	f107 0310 	add.w	r3, r7, #16
    65e2:	4618      	mov	r0, r3
    65e4:	68b9      	ldr	r1, [r7, #8]
    65e6:	f7ff ffa5 	bl	6534 <UTIL1_ScanDecimal32sNumber>
    65ea:	4603      	mov	r3, r0
    65ec:	75fb      	strb	r3, [r7, #23]
  if (res != ERR_OK) {
    65ee:	7dfb      	ldrb	r3, [r7, #23]
    65f0:	2b00      	cmp	r3, #0
    65f2:	d001      	beq.n	65f8 <UTIL1_ScanDecimal32sDotNumber+0x40>
    return res;
    65f4:	7dfb      	ldrb	r3, [r7, #23]
    65f6:	e02d      	b.n	6654 <UTIL1_ScanDecimal32sDotNumber+0x9c>
  }
  if (*p=='.') {
    65f8:	693b      	ldr	r3, [r7, #16]
    65fa:	781b      	ldrb	r3, [r3, #0]
    65fc:	2b2e      	cmp	r3, #46	; 0x2e
    65fe:	d125      	bne.n	664c <UTIL1_ScanDecimal32sDotNumber+0x94>
    p++; /* skip '.' */
    6600:	693b      	ldr	r3, [r7, #16]
    6602:	3301      	adds	r3, #1
    6604:	613b      	str	r3, [r7, #16]
    while (*p=='0') { /* count leading zeros */
    6606:	e008      	b.n	661a <UTIL1_ScanDecimal32sDotNumber+0x62>
      (*nofFractionalZeros)++;
    6608:	683b      	ldr	r3, [r7, #0]
    660a:	781b      	ldrb	r3, [r3, #0]
    660c:	3301      	adds	r3, #1
    660e:	b2da      	uxtb	r2, r3
    6610:	683b      	ldr	r3, [r7, #0]
    6612:	701a      	strb	r2, [r3, #0]
      p++; /* skip leading zero */
    6614:	693b      	ldr	r3, [r7, #16]
    6616:	3301      	adds	r3, #1
    6618:	613b      	str	r3, [r7, #16]
  if (res != ERR_OK) {
    return res;
  }
  if (*p=='.') {
    p++; /* skip '.' */
    while (*p=='0') { /* count leading zeros */
    661a:	693b      	ldr	r3, [r7, #16]
    661c:	781b      	ldrb	r3, [r3, #0]
    661e:	2b30      	cmp	r3, #48	; 0x30
    6620:	d0f2      	beq.n	6608 <UTIL1_ScanDecimal32sDotNumber+0x50>
      (*nofFractionalZeros)++;
      p++; /* skip leading zero */
    }
    if (*p>='0' && *p<='9') { /* number */
    6622:	693b      	ldr	r3, [r7, #16]
    6624:	781b      	ldrb	r3, [r3, #0]
    6626:	2b2f      	cmp	r3, #47	; 0x2f
    6628:	d910      	bls.n	664c <UTIL1_ScanDecimal32sDotNumber+0x94>
    662a:	693b      	ldr	r3, [r7, #16]
    662c:	781b      	ldrb	r3, [r3, #0]
    662e:	2b39      	cmp	r3, #57	; 0x39
    6630:	d80c      	bhi.n	664c <UTIL1_ScanDecimal32sDotNumber+0x94>
      res = UTIL1_ScanDecimal32uNumber(&p, fractional);
    6632:	f107 0310 	add.w	r3, r7, #16
    6636:	4618      	mov	r0, r3
    6638:	6879      	ldr	r1, [r7, #4]
    663a:	f7ff ff31 	bl	64a0 <UTIL1_ScanDecimal32uNumber>
    663e:	4603      	mov	r3, r0
    6640:	75fb      	strb	r3, [r7, #23]
      if (res != ERR_OK) {
    6642:	7dfb      	ldrb	r3, [r7, #23]
    6644:	2b00      	cmp	r3, #0
    6646:	d001      	beq.n	664c <UTIL1_ScanDecimal32sDotNumber+0x94>
        return res;
    6648:	7dfb      	ldrb	r3, [r7, #23]
    664a:	e003      	b.n	6654 <UTIL1_ScanDecimal32sDotNumber+0x9c>
      }
    }
  }
  *str = p; /* store parsing pointer */
    664c:	693a      	ldr	r2, [r7, #16]
    664e:	68fb      	ldr	r3, [r7, #12]
    6650:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    6652:	2300      	movs	r3, #0
}
    6654:	4618      	mov	r0, r3
    6656:	3718      	adds	r7, #24
    6658:	46bd      	mov	sp, r7
    665a:	bd80      	pop	{r7, pc}

0000665c <PreScanHexNumber>:
  Method is implemented as macro in the header file as wrapper to the standard strlen() function
}
*/

static uint8_t PreScanHexNumber(const unsigned char **str)
{
    665c:	b480      	push	{r7}
    665e:	b085      	sub	sp, #20
    6660:	af00      	add	r7, sp, #0
    6662:	6078      	str	r0, [r7, #4]
  const unsigned char *p = *str;
    6664:	687b      	ldr	r3, [r7, #4]
    6666:	681b      	ldr	r3, [r3, #0]
    6668:	60fb      	str	r3, [r7, #12]

  while(*p==' ') { /* skip leading spaces */
    666a:	e002      	b.n	6672 <PreScanHexNumber+0x16>
    p++; /* skip space */
    666c:	68fb      	ldr	r3, [r7, #12]
    666e:	3301      	adds	r3, #1
    6670:	60fb      	str	r3, [r7, #12]

static uint8_t PreScanHexNumber(const unsigned char **str)
{
  const unsigned char *p = *str;

  while(*p==' ') { /* skip leading spaces */
    6672:	68fb      	ldr	r3, [r7, #12]
    6674:	781b      	ldrb	r3, [r3, #0]
    6676:	2b20      	cmp	r3, #32
    6678:	d0f8      	beq.n	666c <PreScanHexNumber+0x10>
    p++; /* skip space */
  }
  if (*p!='0') { /* must start with 0x */
    667a:	68fb      	ldr	r3, [r7, #12]
    667c:	781b      	ldrb	r3, [r3, #0]
    667e:	2b30      	cmp	r3, #48	; 0x30
    6680:	d001      	beq.n	6686 <PreScanHexNumber+0x2a>
    return ERR_FAILED;
    6682:	231b      	movs	r3, #27
    6684:	e00f      	b.n	66a6 <PreScanHexNumber+0x4a>
  }
  p++; /* skip '0' */
    6686:	68fb      	ldr	r3, [r7, #12]
    6688:	3301      	adds	r3, #1
    668a:	60fb      	str	r3, [r7, #12]
  if (*p!='x') { /* must start with 0x */
    668c:	68fb      	ldr	r3, [r7, #12]
    668e:	781b      	ldrb	r3, [r3, #0]
    6690:	2b78      	cmp	r3, #120	; 0x78
    6692:	d001      	beq.n	6698 <PreScanHexNumber+0x3c>
    return ERR_FAILED;
    6694:	231b      	movs	r3, #27
    6696:	e006      	b.n	66a6 <PreScanHexNumber+0x4a>
  }
  p++; /* skip 'x' */
    6698:	68fb      	ldr	r3, [r7, #12]
    669a:	3301      	adds	r3, #1
    669c:	60fb      	str	r3, [r7, #12]
  *str = p;
    669e:	687b      	ldr	r3, [r7, #4]
    66a0:	68fa      	ldr	r2, [r7, #12]
    66a2:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    66a4:	2300      	movs	r3, #0
}
    66a6:	4618      	mov	r0, r3
    66a8:	3714      	adds	r7, #20
    66aa:	46bd      	mov	sp, r7
    66ac:	f85d 7b04 	ldr.w	r7, [sp], #4
    66b0:	4770      	bx	lr
    66b2:	bf00      	nop

000066b4 <HexToDec>:

static uint8_t HexToDec(const unsigned char **p, unsigned char *val) {
    66b4:	b480      	push	{r7}
    66b6:	b085      	sub	sp, #20
    66b8:	af00      	add	r7, sp, #0
    66ba:	6078      	str	r0, [r7, #4]
    66bc:	6039      	str	r1, [r7, #0]
  /* convert a hexadecimal character into a decimal value */
  unsigned char ch = **p;
    66be:	687b      	ldr	r3, [r7, #4]
    66c0:	681b      	ldr	r3, [r3, #0]
    66c2:	781b      	ldrb	r3, [r3, #0]
    66c4:	73fb      	strb	r3, [r7, #15]

  if (ch>='0' && ch<='9') {
    66c6:	7bfb      	ldrb	r3, [r7, #15]
    66c8:	2b2f      	cmp	r3, #47	; 0x2f
    66ca:	d90e      	bls.n	66ea <HexToDec+0x36>
    66cc:	7bfb      	ldrb	r3, [r7, #15]
    66ce:	2b39      	cmp	r3, #57	; 0x39
    66d0:	d80b      	bhi.n	66ea <HexToDec+0x36>
    *val = (unsigned char)(ch-'0');
    66d2:	7bfb      	ldrb	r3, [r7, #15]
    66d4:	3b30      	subs	r3, #48	; 0x30
    66d6:	b2da      	uxtb	r2, r3
    66d8:	683b      	ldr	r3, [r7, #0]
    66da:	701a      	strb	r2, [r3, #0]
    (*p)++;
    66dc:	687b      	ldr	r3, [r7, #4]
    66de:	681b      	ldr	r3, [r3, #0]
    66e0:	1c5a      	adds	r2, r3, #1
    66e2:	687b      	ldr	r3, [r7, #4]
    66e4:	601a      	str	r2, [r3, #0]
    return ERR_OK;
    66e6:	2300      	movs	r3, #0
    66e8:	e024      	b.n	6734 <HexToDec+0x80>
  } else if (ch>='a' && ch<='f') {
    66ea:	7bfb      	ldrb	r3, [r7, #15]
    66ec:	2b60      	cmp	r3, #96	; 0x60
    66ee:	d90e      	bls.n	670e <HexToDec+0x5a>
    66f0:	7bfb      	ldrb	r3, [r7, #15]
    66f2:	2b66      	cmp	r3, #102	; 0x66
    66f4:	d80b      	bhi.n	670e <HexToDec+0x5a>
    *val = (unsigned char)(ch-'a'+10);
    66f6:	7bfb      	ldrb	r3, [r7, #15]
    66f8:	3b57      	subs	r3, #87	; 0x57
    66fa:	b2da      	uxtb	r2, r3
    66fc:	683b      	ldr	r3, [r7, #0]
    66fe:	701a      	strb	r2, [r3, #0]
    (*p)++;
    6700:	687b      	ldr	r3, [r7, #4]
    6702:	681b      	ldr	r3, [r3, #0]
    6704:	1c5a      	adds	r2, r3, #1
    6706:	687b      	ldr	r3, [r7, #4]
    6708:	601a      	str	r2, [r3, #0]
    return ERR_OK;
    670a:	2300      	movs	r3, #0
    670c:	e012      	b.n	6734 <HexToDec+0x80>
  } else if (ch>='A' && ch<='F') {
    670e:	7bfb      	ldrb	r3, [r7, #15]
    6710:	2b40      	cmp	r3, #64	; 0x40
    6712:	d90e      	bls.n	6732 <HexToDec+0x7e>
    6714:	7bfb      	ldrb	r3, [r7, #15]
    6716:	2b46      	cmp	r3, #70	; 0x46
    6718:	d80b      	bhi.n	6732 <HexToDec+0x7e>
    *val = (unsigned char)(ch-'A'+10);
    671a:	7bfb      	ldrb	r3, [r7, #15]
    671c:	3b37      	subs	r3, #55	; 0x37
    671e:	b2da      	uxtb	r2, r3
    6720:	683b      	ldr	r3, [r7, #0]
    6722:	701a      	strb	r2, [r3, #0]
    (*p)++;
    6724:	687b      	ldr	r3, [r7, #4]
    6726:	681b      	ldr	r3, [r3, #0]
    6728:	1c5a      	adds	r2, r3, #1
    672a:	687b      	ldr	r3, [r7, #4]
    672c:	601a      	str	r2, [r3, #0]
    return ERR_OK;
    672e:	2300      	movs	r3, #0
    6730:	e000      	b.n	6734 <HexToDec+0x80>
  }
  return ERR_FAILED;
    6732:	231b      	movs	r3, #27
}
    6734:	4618      	mov	r0, r3
    6736:	3714      	adds	r7, #20
    6738:	46bd      	mov	sp, r7
    673a:	f85d 7b04 	ldr.w	r7, [sp], #4
    673e:	4770      	bx	lr

00006740 <UTIL1_ScanHex32uNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanHex32uNumber(const unsigned char **str, uint32_t *val)
{
    6740:	b580      	push	{r7, lr}
    6742:	b086      	sub	sp, #24
    6744:	af00      	add	r7, sp, #0
    6746:	6078      	str	r0, [r7, #4]
    6748:	6039      	str	r1, [r7, #0]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 8+1; /* maximum number of digits to avoid overflow */
    674a:	2309      	movs	r3, #9
    674c:	75fb      	strb	r3, [r7, #23]
  const unsigned char *p = *str;
    674e:	687b      	ldr	r3, [r7, #4]
    6750:	681b      	ldr	r3, [r3, #0]
    6752:	613b      	str	r3, [r7, #16]
  uint8_t v;

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    6754:	f107 0310 	add.w	r3, r7, #16
    6758:	4618      	mov	r0, r3
    675a:	f7ff ff7f 	bl	665c <PreScanHexNumber>
    675e:	4603      	mov	r3, r0
    6760:	2b00      	cmp	r3, #0
    6762:	d001      	beq.n	6768 <UTIL1_ScanHex32uNumber+0x28>
    return ERR_FAILED;
    6764:	231b      	movs	r3, #27
    6766:	e024      	b.n	67b2 <UTIL1_ScanHex32uNumber+0x72>
  }
  *val = 0;
    6768:	683b      	ldr	r3, [r7, #0]
    676a:	2200      	movs	r2, #0
    676c:	601a      	str	r2, [r3, #0]
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    676e:	e009      	b.n	6784 <UTIL1_ScanHex32uNumber+0x44>
    *val = (uint32_t)((*val)*16 + v);
    6770:	683b      	ldr	r3, [r7, #0]
    6772:	681b      	ldr	r3, [r3, #0]
    6774:	011a      	lsls	r2, r3, #4
    6776:	7bfb      	ldrb	r3, [r7, #15]
    6778:	441a      	add	r2, r3
    677a:	683b      	ldr	r3, [r7, #0]
    677c:	601a      	str	r2, [r3, #0]
    nofDigits--;
    677e:	7dfb      	ldrb	r3, [r7, #23]
    6780:	3b01      	subs	r3, #1
    6782:	75fb      	strb	r3, [r7, #23]

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    return ERR_FAILED;
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    6784:	f107 0210 	add.w	r2, r7, #16
    6788:	f107 030f 	add.w	r3, r7, #15
    678c:	4610      	mov	r0, r2
    678e:	4619      	mov	r1, r3
    6790:	f7ff ff90 	bl	66b4 <HexToDec>
    6794:	4603      	mov	r3, r0
    6796:	2b00      	cmp	r3, #0
    6798:	d102      	bne.n	67a0 <UTIL1_ScanHex32uNumber+0x60>
    679a:	7dfb      	ldrb	r3, [r7, #23]
    679c:	2b00      	cmp	r3, #0
    679e:	d1e7      	bne.n	6770 <UTIL1_ScanHex32uNumber+0x30>
    *val = (uint32_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    67a0:	7dfb      	ldrb	r3, [r7, #23]
    67a2:	2b00      	cmp	r3, #0
    67a4:	d101      	bne.n	67aa <UTIL1_ScanHex32uNumber+0x6a>
    return ERR_OVERFLOW;
    67a6:	2304      	movs	r3, #4
    67a8:	e003      	b.n	67b2 <UTIL1_ScanHex32uNumber+0x72>
  }
  *str = p;
    67aa:	693a      	ldr	r2, [r7, #16]
    67ac:	687b      	ldr	r3, [r7, #4]
    67ae:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    67b0:	2300      	movs	r3, #0
}
    67b2:	4618      	mov	r0, r3
    67b4:	3718      	adds	r7, #24
    67b6:	46bd      	mov	sp, r7
    67b8:	bd80      	pop	{r7, pc}
    67ba:	bf00      	nop

000067bc <UTIL1_ScanHex16uNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanHex16uNumber(const unsigned char **str, uint16_t *val)
{
    67bc:	b580      	push	{r7, lr}
    67be:	b086      	sub	sp, #24
    67c0:	af00      	add	r7, sp, #0
    67c2:	6078      	str	r0, [r7, #4]
    67c4:	6039      	str	r1, [r7, #0]
  /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 4+1; /* maximum number of digits to avoid overflow */
    67c6:	2305      	movs	r3, #5
    67c8:	75fb      	strb	r3, [r7, #23]
  const unsigned char *p = *str;
    67ca:	687b      	ldr	r3, [r7, #4]
    67cc:	681b      	ldr	r3, [r3, #0]
    67ce:	613b      	str	r3, [r7, #16]
  uint8_t v;

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    67d0:	f107 0310 	add.w	r3, r7, #16
    67d4:	4618      	mov	r0, r3
    67d6:	f7ff ff41 	bl	665c <PreScanHexNumber>
    67da:	4603      	mov	r3, r0
    67dc:	2b00      	cmp	r3, #0
    67de:	d001      	beq.n	67e4 <UTIL1_ScanHex16uNumber+0x28>
    return ERR_FAILED;
    67e0:	231b      	movs	r3, #27
    67e2:	e026      	b.n	6832 <UTIL1_ScanHex16uNumber+0x76>
  }
  *val = 0;
    67e4:	683b      	ldr	r3, [r7, #0]
    67e6:	2200      	movs	r2, #0
    67e8:	801a      	strh	r2, [r3, #0]
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    67ea:	e00b      	b.n	6804 <UTIL1_ScanHex16uNumber+0x48>
    *val = (uint16_t)((*val)*16 + v);
    67ec:	683b      	ldr	r3, [r7, #0]
    67ee:	881b      	ldrh	r3, [r3, #0]
    67f0:	011b      	lsls	r3, r3, #4
    67f2:	b29a      	uxth	r2, r3
    67f4:	7bfb      	ldrb	r3, [r7, #15]
    67f6:	4413      	add	r3, r2
    67f8:	b29a      	uxth	r2, r3
    67fa:	683b      	ldr	r3, [r7, #0]
    67fc:	801a      	strh	r2, [r3, #0]
    nofDigits--;
    67fe:	7dfb      	ldrb	r3, [r7, #23]
    6800:	3b01      	subs	r3, #1
    6802:	75fb      	strb	r3, [r7, #23]

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    return ERR_FAILED;
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    6804:	f107 0210 	add.w	r2, r7, #16
    6808:	f107 030f 	add.w	r3, r7, #15
    680c:	4610      	mov	r0, r2
    680e:	4619      	mov	r1, r3
    6810:	f7ff ff50 	bl	66b4 <HexToDec>
    6814:	4603      	mov	r3, r0
    6816:	2b00      	cmp	r3, #0
    6818:	d102      	bne.n	6820 <UTIL1_ScanHex16uNumber+0x64>
    681a:	7dfb      	ldrb	r3, [r7, #23]
    681c:	2b00      	cmp	r3, #0
    681e:	d1e5      	bne.n	67ec <UTIL1_ScanHex16uNumber+0x30>
    *val = (uint16_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    6820:	7dfb      	ldrb	r3, [r7, #23]
    6822:	2b00      	cmp	r3, #0
    6824:	d101      	bne.n	682a <UTIL1_ScanHex16uNumber+0x6e>
    return ERR_OVERFLOW;
    6826:	2304      	movs	r3, #4
    6828:	e003      	b.n	6832 <UTIL1_ScanHex16uNumber+0x76>
  }
  *str = p;
    682a:	693a      	ldr	r2, [r7, #16]
    682c:	687b      	ldr	r3, [r7, #4]
    682e:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    6830:	2300      	movs	r3, #0
}
    6832:	4618      	mov	r0, r3
    6834:	3718      	adds	r7, #24
    6836:	46bd      	mov	sp, r7
    6838:	bd80      	pop	{r7, pc}
    683a:	bf00      	nop

0000683c <UTIL1_ScanHex8uNumber>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanHex8uNumber(const unsigned char **str, uint8_t *val)
{
    683c:	b580      	push	{r7, lr}
    683e:	b086      	sub	sp, #24
    6840:	af00      	add	r7, sp, #0
    6842:	6078      	str	r0, [r7, #4]
    6844:	6039      	str	r1, [r7, #0]
  /* scans a hex number with 0x, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
    6846:	2303      	movs	r3, #3
    6848:	75fb      	strb	r3, [r7, #23]
  const unsigned char *p = *str;
    684a:	687b      	ldr	r3, [r7, #4]
    684c:	681b      	ldr	r3, [r3, #0]
    684e:	613b      	str	r3, [r7, #16]
  uint8_t v;

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    6850:	f107 0310 	add.w	r3, r7, #16
    6854:	4618      	mov	r0, r3
    6856:	f7ff ff01 	bl	665c <PreScanHexNumber>
    685a:	4603      	mov	r3, r0
    685c:	2b00      	cmp	r3, #0
    685e:	d001      	beq.n	6864 <UTIL1_ScanHex8uNumber+0x28>
    return ERR_FAILED;
    6860:	231b      	movs	r3, #27
    6862:	e026      	b.n	68b2 <UTIL1_ScanHex8uNumber+0x76>
  }
  *val = 0;
    6864:	683b      	ldr	r3, [r7, #0]
    6866:	2200      	movs	r2, #0
    6868:	701a      	strb	r2, [r3, #0]
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    686a:	e00b      	b.n	6884 <UTIL1_ScanHex8uNumber+0x48>
    *val = (uint8_t)((*val)*16 + v);
    686c:	683b      	ldr	r3, [r7, #0]
    686e:	781b      	ldrb	r3, [r3, #0]
    6870:	011b      	lsls	r3, r3, #4
    6872:	b2da      	uxtb	r2, r3
    6874:	7bfb      	ldrb	r3, [r7, #15]
    6876:	4413      	add	r3, r2
    6878:	b2da      	uxtb	r2, r3
    687a:	683b      	ldr	r3, [r7, #0]
    687c:	701a      	strb	r2, [r3, #0]
    nofDigits--;
    687e:	7dfb      	ldrb	r3, [r7, #23]
    6880:	3b01      	subs	r3, #1
    6882:	75fb      	strb	r3, [r7, #23]

  if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
    return ERR_FAILED;
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    6884:	f107 0210 	add.w	r2, r7, #16
    6888:	f107 030f 	add.w	r3, r7, #15
    688c:	4610      	mov	r0, r2
    688e:	4619      	mov	r1, r3
    6890:	f7ff ff10 	bl	66b4 <HexToDec>
    6894:	4603      	mov	r3, r0
    6896:	2b00      	cmp	r3, #0
    6898:	d102      	bne.n	68a0 <UTIL1_ScanHex8uNumber+0x64>
    689a:	7dfb      	ldrb	r3, [r7, #23]
    689c:	2b00      	cmp	r3, #0
    689e:	d1e5      	bne.n	686c <UTIL1_ScanHex8uNumber+0x30>
    *val = (uint8_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    68a0:	7dfb      	ldrb	r3, [r7, #23]
    68a2:	2b00      	cmp	r3, #0
    68a4:	d101      	bne.n	68aa <UTIL1_ScanHex8uNumber+0x6e>
    return ERR_OVERFLOW;
    68a6:	2304      	movs	r3, #4
    68a8:	e003      	b.n	68b2 <UTIL1_ScanHex8uNumber+0x76>
  }
  *str = p;
    68aa:	693a      	ldr	r2, [r7, #16]
    68ac:	687b      	ldr	r3, [r7, #4]
    68ae:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    68b0:	2300      	movs	r3, #0
}
    68b2:	4618      	mov	r0, r3
    68b4:	3718      	adds	r7, #24
    68b6:	46bd      	mov	sp, r7
    68b8:	bd80      	pop	{r7, pc}
    68ba:	bf00      	nop

000068bc <UTIL1_ScanHex8uNumberNoPrefix>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanHex8uNumberNoPrefix(const unsigned char **str, uint8_t *val)
{
    68bc:	b580      	push	{r7, lr}
    68be:	b086      	sub	sp, #24
    68c0:	af00      	add	r7, sp, #0
    68c2:	6078      	str	r0, [r7, #4]
    68c4:	6039      	str	r1, [r7, #0]
  /* scans a hex number without 0x, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
    68c6:	2303      	movs	r3, #3
    68c8:	75fb      	strb	r3, [r7, #23]
  const unsigned char *p = *str;
    68ca:	687b      	ldr	r3, [r7, #4]
    68cc:	681b      	ldr	r3, [r3, #0]
    68ce:	613b      	str	r3, [r7, #16]
  uint8_t v;

  while(*p==' ') { /* skip leading spaces */
    68d0:	e002      	b.n	68d8 <UTIL1_ScanHex8uNumberNoPrefix+0x1c>
    p++; /* skip space */
    68d2:	693b      	ldr	r3, [r7, #16]
    68d4:	3301      	adds	r3, #1
    68d6:	613b      	str	r3, [r7, #16]
  /* scans a hex number without 0x, and stops at any non-number. Number can have any preceding zeros or spaces. */
  uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
  const unsigned char *p = *str;
  uint8_t v;

  while(*p==' ') { /* skip leading spaces */
    68d8:	693b      	ldr	r3, [r7, #16]
    68da:	781b      	ldrb	r3, [r3, #0]
    68dc:	2b20      	cmp	r3, #32
    68de:	d0f8      	beq.n	68d2 <UTIL1_ScanHex8uNumberNoPrefix+0x16>
    p++; /* skip space */
  }
  *val = 0;
    68e0:	683b      	ldr	r3, [r7, #0]
    68e2:	2200      	movs	r2, #0
    68e4:	701a      	strb	r2, [r3, #0]
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    68e6:	e00b      	b.n	6900 <UTIL1_ScanHex8uNumberNoPrefix+0x44>
    *val = (uint8_t)((*val)*16 + v);
    68e8:	683b      	ldr	r3, [r7, #0]
    68ea:	781b      	ldrb	r3, [r3, #0]
    68ec:	011b      	lsls	r3, r3, #4
    68ee:	b2da      	uxtb	r2, r3
    68f0:	7bfb      	ldrb	r3, [r7, #15]
    68f2:	4413      	add	r3, r2
    68f4:	b2da      	uxtb	r2, r3
    68f6:	683b      	ldr	r3, [r7, #0]
    68f8:	701a      	strb	r2, [r3, #0]
    nofDigits--;
    68fa:	7dfb      	ldrb	r3, [r7, #23]
    68fc:	3b01      	subs	r3, #1
    68fe:	75fb      	strb	r3, [r7, #23]

  while(*p==' ') { /* skip leading spaces */
    p++; /* skip space */
  }
  *val = 0;
  while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
    6900:	f107 0210 	add.w	r2, r7, #16
    6904:	f107 030f 	add.w	r3, r7, #15
    6908:	4610      	mov	r0, r2
    690a:	4619      	mov	r1, r3
    690c:	f7ff fed2 	bl	66b4 <HexToDec>
    6910:	4603      	mov	r3, r0
    6912:	2b00      	cmp	r3, #0
    6914:	d102      	bne.n	691c <UTIL1_ScanHex8uNumberNoPrefix+0x60>
    6916:	7dfb      	ldrb	r3, [r7, #23]
    6918:	2b00      	cmp	r3, #0
    691a:	d1e5      	bne.n	68e8 <UTIL1_ScanHex8uNumberNoPrefix+0x2c>
    *val = (uint8_t)((*val)*16 + v);
    nofDigits--;
  } /* while */
  if (nofDigits==0) {
    691c:	7dfb      	ldrb	r3, [r7, #23]
    691e:	2b00      	cmp	r3, #0
    6920:	d101      	bne.n	6926 <UTIL1_ScanHex8uNumberNoPrefix+0x6a>
    return ERR_OVERFLOW;
    6922:	2304      	movs	r3, #4
    6924:	e003      	b.n	692e <UTIL1_ScanHex8uNumberNoPrefix+0x72>
  }
  *str = p;
    6926:	693a      	ldr	r2, [r7, #16]
    6928:	687b      	ldr	r3, [r7, #4]
    692a:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    692c:	2300      	movs	r3, #0
}
    692e:	4618      	mov	r0, r3
    6930:	3718      	adds	r7, #24
    6932:	46bd      	mov	sp, r7
    6934:	bd80      	pop	{r7, pc}
    6936:	bf00      	nop

00006938 <UTIL1_strtailcmp>:
**     Returns     :
**         ---             - returns 0 if tail matches, -1 otherwise
** ===================================================================
*/
uint8_t UTIL1_strtailcmp(uint8_t *str, uint8_t *tail)
{
    6938:	b580      	push	{r7, lr}
    693a:	b084      	sub	sp, #16
    693c:	af00      	add	r7, sp, #0
    693e:	6078      	str	r0, [r7, #4]
    6940:	6039      	str	r1, [r7, #0]
  int i, j;

  i = (int)UTIL1_strlen((char*)str);
    6942:	6878      	ldr	r0, [r7, #4]
    6944:	f000 fc70 	bl	7228 <strlen>
    6948:	4603      	mov	r3, r0
    694a:	60fb      	str	r3, [r7, #12]
  j = (int)UTIL1_strlen((char*)tail);
    694c:	6838      	ldr	r0, [r7, #0]
    694e:	f000 fc6b 	bl	7228 <strlen>
    6952:	4603      	mov	r3, r0
    6954:	60bb      	str	r3, [r7, #8]
  if (j>i) { /* str is smaller than tail */
    6956:	68ba      	ldr	r2, [r7, #8]
    6958:	68fb      	ldr	r3, [r7, #12]
    695a:	429a      	cmp	r2, r3
    695c:	dd01      	ble.n	6962 <UTIL1_strtailcmp+0x2a>
    return 1; /* cannot match */
    695e:	2301      	movs	r3, #1
    6960:	e016      	b.n	6990 <UTIL1_strtailcmp+0x58>
  }
  /* compare strings */
  while(str[i]==tail[j]) {
    6962:	e00a      	b.n	697a <UTIL1_strtailcmp+0x42>
    i--;
    6964:	68fb      	ldr	r3, [r7, #12]
    6966:	3b01      	subs	r3, #1
    6968:	60fb      	str	r3, [r7, #12]
    j--;
    696a:	68bb      	ldr	r3, [r7, #8]
    696c:	3b01      	subs	r3, #1
    696e:	60bb      	str	r3, [r7, #8]
    if (j<0) {
    6970:	68bb      	ldr	r3, [r7, #8]
    6972:	2b00      	cmp	r3, #0
    6974:	da01      	bge.n	697a <UTIL1_strtailcmp+0x42>
      return 0; /* match */
    6976:	2300      	movs	r3, #0
    6978:	e00a      	b.n	6990 <UTIL1_strtailcmp+0x58>
  j = (int)UTIL1_strlen((char*)tail);
  if (j>i) { /* str is smaller than tail */
    return 1; /* cannot match */
  }
  /* compare strings */
  while(str[i]==tail[j]) {
    697a:	68fb      	ldr	r3, [r7, #12]
    697c:	687a      	ldr	r2, [r7, #4]
    697e:	4413      	add	r3, r2
    6980:	781a      	ldrb	r2, [r3, #0]
    6982:	68bb      	ldr	r3, [r7, #8]
    6984:	6839      	ldr	r1, [r7, #0]
    6986:	440b      	add	r3, r1
    6988:	781b      	ldrb	r3, [r3, #0]
    698a:	429a      	cmp	r2, r3
    698c:	d0ea      	beq.n	6964 <UTIL1_strtailcmp+0x2c>
    j--;
    if (j<0) {
      return 0; /* match */
    }
  }
  return 1; /* !=0 means no match */
    698e:	2301      	movs	r3, #1
}
    6990:	4618      	mov	r0, r3
    6992:	3710      	adds	r7, #16
    6994:	46bd      	mov	sp, r7
    6996:	bd80      	pop	{r7, pc}

00006998 <UTIL1_strCutTail>:
**         ---             - Error code, ERR_OK if no error, otherwise
**                           ERR_FAIL if tail is not found
** ===================================================================
*/
uint8_t UTIL1_strCutTail(uint8_t *str, uint8_t *tail)
{
    6998:	b580      	push	{r7, lr}
    699a:	b084      	sub	sp, #16
    699c:	af00      	add	r7, sp, #0
    699e:	6078      	str	r0, [r7, #4]
    69a0:	6039      	str	r1, [r7, #0]
  /* cut the tail from the string */
  size_t strLen, tailLen;

  if (UTIL1_strtailcmp(str, tail)!=0) { /* check if tail is present */
    69a2:	6878      	ldr	r0, [r7, #4]
    69a4:	6839      	ldr	r1, [r7, #0]
    69a6:	f7ff ffc7 	bl	6938 <UTIL1_strtailcmp>
    69aa:	4603      	mov	r3, r0
    69ac:	2b00      	cmp	r3, #0
    69ae:	d001      	beq.n	69b4 <UTIL1_strCutTail+0x1c>
    return ERR_FAILED; /* tail not found */
    69b0:	231b      	movs	r3, #27
    69b2:	e00f      	b.n	69d4 <UTIL1_strCutTail+0x3c>
  }
  tailLen = UTIL1_strlen((char*)tail);
    69b4:	6838      	ldr	r0, [r7, #0]
    69b6:	f000 fc37 	bl	7228 <strlen>
    69ba:	60f8      	str	r0, [r7, #12]
  strLen = UTIL1_strlen((char*)str);
    69bc:	6878      	ldr	r0, [r7, #4]
    69be:	f000 fc33 	bl	7228 <strlen>
    69c2:	60b8      	str	r0, [r7, #8]
  /* write \0 to cut the tail */
  str[strLen-tailLen] = '\0';
    69c4:	68ba      	ldr	r2, [r7, #8]
    69c6:	68fb      	ldr	r3, [r7, #12]
    69c8:	1ad3      	subs	r3, r2, r3
    69ca:	687a      	ldr	r2, [r7, #4]
    69cc:	4413      	add	r3, r2
    69ce:	2200      	movs	r2, #0
    69d0:	701a      	strb	r2, [r3, #0]
  return ERR_OK;
    69d2:	2300      	movs	r3, #0
}
    69d4:	4618      	mov	r0, r3
    69d6:	3710      	adds	r7, #16
    69d8:	46bd      	mov	sp, r7
    69da:	bd80      	pop	{r7, pc}

000069dc <UTIL1_strcatNum32sDotValue100>:
**         num             - Value to convert.
**     Returns     : Nothing
** ===================================================================
*/
void UTIL1_strcatNum32sDotValue100(uint8_t *dst, size_t dstSize, int32_t num)
{
    69dc:	b580      	push	{r7, lr}
    69de:	b086      	sub	sp, #24
    69e0:	af02      	add	r7, sp, #8
    69e2:	60f8      	str	r0, [r7, #12]
    69e4:	60b9      	str	r1, [r7, #8]
    69e6:	607a      	str	r2, [r7, #4]
  if (num<0 && (num/100)==0) { /* e.g. -53 ==> write sign, as strcatNum32() below will not know that it is negative */
    69e8:	687b      	ldr	r3, [r7, #4]
    69ea:	2b00      	cmp	r3, #0
    69ec:	da08      	bge.n	6a00 <UTIL1_strcatNum32sDotValue100+0x24>
    69ee:	687b      	ldr	r3, [r7, #4]
    69f0:	3363      	adds	r3, #99	; 0x63
    69f2:	2bc6      	cmp	r3, #198	; 0xc6
    69f4:	d804      	bhi.n	6a00 <UTIL1_strcatNum32sDotValue100+0x24>
    UTIL1_chcat(dst, dstSize, '-');
    69f6:	68f8      	ldr	r0, [r7, #12]
    69f8:	68b9      	ldr	r1, [r7, #8]
    69fa:	222d      	movs	r2, #45	; 0x2d
    69fc:	f7fe fc32 	bl	5264 <UTIL1_chcat>
  }
  UTIL1_strcatNum32s(dst, dstSize, num/100);
    6a00:	687b      	ldr	r3, [r7, #4]
    6a02:	4a16      	ldr	r2, [pc, #88]	; (6a5c <UTIL1_strcatNum32sDotValue100+0x80>)
    6a04:	fb82 1203 	smull	r1, r2, r2, r3
    6a08:	1152      	asrs	r2, r2, #5
    6a0a:	17db      	asrs	r3, r3, #31
    6a0c:	1ad3      	subs	r3, r2, r3
    6a0e:	68f8      	ldr	r0, [r7, #12]
    6a10:	68b9      	ldr	r1, [r7, #8]
    6a12:	461a      	mov	r2, r3
    6a14:	f7fe ffd6 	bl	59c4 <UTIL1_strcatNum32s>
  UTIL1_chcat(dst, dstSize, '.');
    6a18:	68f8      	ldr	r0, [r7, #12]
    6a1a:	68b9      	ldr	r1, [r7, #8]
    6a1c:	222e      	movs	r2, #46	; 0x2e
    6a1e:	f7fe fc21 	bl	5264 <UTIL1_chcat>
  if (num<0) {
    6a22:	687b      	ldr	r3, [r7, #4]
    6a24:	2b00      	cmp	r3, #0
    6a26:	da02      	bge.n	6a2e <UTIL1_strcatNum32sDotValue100+0x52>
    num = -num;
    6a28:	687b      	ldr	r3, [r7, #4]
    6a2a:	425b      	negs	r3, r3
    6a2c:	607b      	str	r3, [r7, #4]
  }
  UTIL1_strcatNum16uFormatted(dst, dstSize, (uint16_t)(num%100), '0', 2);
    6a2e:	687a      	ldr	r2, [r7, #4]
    6a30:	4b0a      	ldr	r3, [pc, #40]	; (6a5c <UTIL1_strcatNum32sDotValue100+0x80>)
    6a32:	fb83 1302 	smull	r1, r3, r3, r2
    6a36:	1159      	asrs	r1, r3, #5
    6a38:	17d3      	asrs	r3, r2, #31
    6a3a:	1acb      	subs	r3, r1, r3
    6a3c:	2164      	movs	r1, #100	; 0x64
    6a3e:	fb01 f303 	mul.w	r3, r1, r3
    6a42:	1ad3      	subs	r3, r2, r3
    6a44:	b29b      	uxth	r3, r3
    6a46:	2202      	movs	r2, #2
    6a48:	9200      	str	r2, [sp, #0]
    6a4a:	68f8      	ldr	r0, [r7, #12]
    6a4c:	68b9      	ldr	r1, [r7, #8]
    6a4e:	461a      	mov	r2, r3
    6a50:	2330      	movs	r3, #48	; 0x30
    6a52:	f7fe fe7b 	bl	574c <UTIL1_strcatNum16uFormatted>
}
    6a56:	3710      	adds	r7, #16
    6a58:	46bd      	mov	sp, r7
    6a5a:	bd80      	pop	{r7, pc}
    6a5c:	51eb851f 	.word	0x51eb851f

00006a60 <UTIL1_strFind>:
**         ---             - -1 if not found, otherwise the character
**                           index.
** ===================================================================
*/
int16_t UTIL1_strFind(uint8_t *str, uint8_t *subStr)
{
    6a60:	b580      	push	{r7, lr}
    6a62:	b084      	sub	sp, #16
    6a64:	af00      	add	r7, sp, #0
    6a66:	6078      	str	r0, [r7, #4]
    6a68:	6039      	str	r1, [r7, #0]
  int16_t i, len;

  len = (int16_t)UTIL1_strlen((char*)subStr);
    6a6a:	6838      	ldr	r0, [r7, #0]
    6a6c:	f000 fbdc 	bl	7228 <strlen>
    6a70:	4603      	mov	r3, r0
    6a72:	81bb      	strh	r3, [r7, #12]
  for (i=0; *str!='\0'; i++, str++) {
    6a74:	2300      	movs	r3, #0
    6a76:	81fb      	strh	r3, [r7, #14]
    6a78:	e011      	b.n	6a9e <UTIL1_strFind+0x3e>
    if (UTIL1_strncmp((char*)str, (char*)subStr, len)==0) {
    6a7a:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
    6a7e:	6878      	ldr	r0, [r7, #4]
    6a80:	6839      	ldr	r1, [r7, #0]
    6a82:	461a      	mov	r2, r3
    6a84:	f000 fbd8 	bl	7238 <strncmp>
    6a88:	4603      	mov	r3, r0
    6a8a:	2b00      	cmp	r3, #0
    6a8c:	d101      	bne.n	6a92 <UTIL1_strFind+0x32>
      return i; /* found */
    6a8e:	89fb      	ldrh	r3, [r7, #14]
    6a90:	e00b      	b.n	6aaa <UTIL1_strFind+0x4a>
int16_t UTIL1_strFind(uint8_t *str, uint8_t *subStr)
{
  int16_t i, len;

  len = (int16_t)UTIL1_strlen((char*)subStr);
  for (i=0; *str!='\0'; i++, str++) {
    6a92:	89fb      	ldrh	r3, [r7, #14]
    6a94:	3301      	adds	r3, #1
    6a96:	81fb      	strh	r3, [r7, #14]
    6a98:	687b      	ldr	r3, [r7, #4]
    6a9a:	3301      	adds	r3, #1
    6a9c:	607b      	str	r3, [r7, #4]
    6a9e:	687b      	ldr	r3, [r7, #4]
    6aa0:	781b      	ldrb	r3, [r3, #0]
    6aa2:	2b00      	cmp	r3, #0
    6aa4:	d1e9      	bne.n	6a7a <UTIL1_strFind+0x1a>
    if (UTIL1_strncmp((char*)str, (char*)subStr, len)==0) {
      return i; /* found */
    }
  }
  return -1; /* not found */
    6aa6:	f64f 73ff 	movw	r3, #65535	; 0xffff
    6aaa:	b21b      	sxth	r3, r3
}
    6aac:	4618      	mov	r0, r3
    6aae:	3710      	adds	r7, #16
    6ab0:	46bd      	mov	sp, r7
    6ab2:	bd80      	pop	{r7, pc}

00006ab4 <UTIL1_ScanSeparatedNumbers>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanSeparatedNumbers(const unsigned char **str, uint8_t *values, uint8_t nofValues, char separator, UTIL1_SeparatedNumberType numberType)
{
    6ab4:	b580      	push	{r7, lr}
    6ab6:	b088      	sub	sp, #32
    6ab8:	af00      	add	r7, sp, #0
    6aba:	60f8      	str	r0, [r7, #12]
    6abc:	60b9      	str	r1, [r7, #8]
    6abe:	71fa      	strb	r2, [r7, #7]
    6ac0:	71bb      	strb	r3, [r7, #6]
  int i;
  uint8_t res;
  const unsigned char *p;

  if (nofValues<=1) {
    6ac2:	79fb      	ldrb	r3, [r7, #7]
    6ac4:	2b01      	cmp	r3, #1
    6ac6:	d801      	bhi.n	6acc <UTIL1_ScanSeparatedNumbers+0x18>
    return ERR_FAILED; /* need at least two values */
    6ac8:	231b      	movs	r3, #27
    6aca:	e047      	b.n	6b5c <UTIL1_ScanSeparatedNumbers+0xa8>
  }
  p = *str;
    6acc:	68fb      	ldr	r3, [r7, #12]
    6ace:	681b      	ldr	r3, [r3, #0]
    6ad0:	617b      	str	r3, [r7, #20]
  for(i=0;i<nofValues;i++) {
    6ad2:	2300      	movs	r3, #0
    6ad4:	61fb      	str	r3, [r7, #28]
    6ad6:	e039      	b.n	6b4c <UTIL1_ScanSeparatedNumbers+0x98>
    if (numberType==UTIL1_SEP_NUM_TYPE_UINT8) {
    6ad8:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    6adc:	2b00      	cmp	r3, #0
    6ade:	d10b      	bne.n	6af8 <UTIL1_ScanSeparatedNumbers+0x44>
      res = UTIL1_ScanDecimal8uNumber(&p, &values[i]);
    6ae0:	69fb      	ldr	r3, [r7, #28]
    6ae2:	68ba      	ldr	r2, [r7, #8]
    6ae4:	4413      	add	r3, r2
    6ae6:	f107 0214 	add.w	r2, r7, #20
    6aea:	4610      	mov	r0, r2
    6aec:	4619      	mov	r1, r3
    6aee:	f7ff fbbb 	bl	6268 <UTIL1_ScanDecimal8uNumber>
    6af2:	4603      	mov	r3, r0
    6af4:	76fb      	strb	r3, [r7, #27]
    6af6:	e011      	b.n	6b1c <UTIL1_ScanSeparatedNumbers+0x68>
    } else if (numberType==UTIL1_SEP_NUM_TYPE_UINT8_HEX_NO_PREFIX) {
    6af8:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
    6afc:	2b01      	cmp	r3, #1
    6afe:	d10b      	bne.n	6b18 <UTIL1_ScanSeparatedNumbers+0x64>
      res = UTIL1_ScanHex8uNumberNoPrefix(&p, &values[i]);
    6b00:	69fb      	ldr	r3, [r7, #28]
    6b02:	68ba      	ldr	r2, [r7, #8]
    6b04:	4413      	add	r3, r2
    6b06:	f107 0214 	add.w	r2, r7, #20
    6b0a:	4610      	mov	r0, r2
    6b0c:	4619      	mov	r1, r3
    6b0e:	f7ff fed5 	bl	68bc <UTIL1_ScanHex8uNumberNoPrefix>
    6b12:	4603      	mov	r3, r0
    6b14:	76fb      	strb	r3, [r7, #27]
    6b16:	e001      	b.n	6b1c <UTIL1_ScanSeparatedNumbers+0x68>
    } else {
      res = ERR_FAILED;
    6b18:	231b      	movs	r3, #27
    6b1a:	76fb      	strb	r3, [r7, #27]
    }
    if (res==ERR_OK) { /* parsing ok */
    6b1c:	7efb      	ldrb	r3, [r7, #27]
    6b1e:	2b00      	cmp	r3, #0
    6b20:	d10f      	bne.n	6b42 <UTIL1_ScanSeparatedNumbers+0x8e>
      if (i!=nofValues-1) {
    6b22:	79fb      	ldrb	r3, [r7, #7]
    6b24:	1e5a      	subs	r2, r3, #1
    6b26:	69fb      	ldr	r3, [r7, #28]
    6b28:	429a      	cmp	r2, r3
    6b2a:	d00c      	beq.n	6b46 <UTIL1_ScanSeparatedNumbers+0x92>
        if ((*p)!=separator) { /* not last one */
    6b2c:	697b      	ldr	r3, [r7, #20]
    6b2e:	781b      	ldrb	r3, [r3, #0]
    6b30:	79ba      	ldrb	r2, [r7, #6]
    6b32:	429a      	cmp	r2, r3
    6b34:	d001      	beq.n	6b3a <UTIL1_ScanSeparatedNumbers+0x86>
          return ERR_FAILED; /* wrong separator */
    6b36:	231b      	movs	r3, #27
    6b38:	e010      	b.n	6b5c <UTIL1_ScanSeparatedNumbers+0xa8>
        } /* if */
        p++; /* skip separator and continue scanning */
    6b3a:	697b      	ldr	r3, [r7, #20]
    6b3c:	3301      	adds	r3, #1
    6b3e:	617b      	str	r3, [r7, #20]
    6b40:	e001      	b.n	6b46 <UTIL1_ScanSeparatedNumbers+0x92>
      } /* if */
    } else {
      return ERR_FAILED; /* failed parsing number */
    6b42:	231b      	movs	r3, #27
    6b44:	e00a      	b.n	6b5c <UTIL1_ScanSeparatedNumbers+0xa8>

  if (nofValues<=1) {
    return ERR_FAILED; /* need at least two values */
  }
  p = *str;
  for(i=0;i<nofValues;i++) {
    6b46:	69fb      	ldr	r3, [r7, #28]
    6b48:	3301      	adds	r3, #1
    6b4a:	61fb      	str	r3, [r7, #28]
    6b4c:	79fa      	ldrb	r2, [r7, #7]
    6b4e:	69fb      	ldr	r3, [r7, #28]
    6b50:	429a      	cmp	r2, r3
    6b52:	dcc1      	bgt.n	6ad8 <UTIL1_ScanSeparatedNumbers+0x24>
      } /* if */
    } else {
      return ERR_FAILED; /* failed parsing number */
    } /* if */
  } /* for */
  *str = p;
    6b54:	697a      	ldr	r2, [r7, #20]
    6b56:	68fb      	ldr	r3, [r7, #12]
    6b58:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    6b5a:	2300      	movs	r3, #0
}
    6b5c:	4618      	mov	r0, r3
    6b5e:	3720      	adds	r7, #32
    6b60:	46bd      	mov	sp, r7
    6b62:	bd80      	pop	{r7, pc}

00006b64 <UTIL1_ScanDoubleQuotedString>:
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
uint8_t UTIL1_ScanDoubleQuotedString(const uint8_t **cmd, uint8_t *buf, size_t bufSize)
{
    6b64:	b480      	push	{r7}
    6b66:	b087      	sub	sp, #28
    6b68:	af00      	add	r7, sp, #0
    6b6a:	60f8      	str	r0, [r7, #12]
    6b6c:	60b9      	str	r1, [r7, #8]
    6b6e:	607a      	str	r2, [r7, #4]
  const uint8_t *p = *cmd;
    6b70:	68fb      	ldr	r3, [r7, #12]
    6b72:	681b      	ldr	r3, [r3, #0]
    6b74:	617b      	str	r3, [r7, #20]

  if (bufSize==1) {
    6b76:	687b      	ldr	r3, [r7, #4]
    6b78:	2b01      	cmp	r3, #1
    6b7a:	d101      	bne.n	6b80 <UTIL1_ScanDoubleQuotedString+0x1c>
    return ERR_FAILED; /* buffer too small */
    6b7c:	231b      	movs	r3, #27
    6b7e:	e038      	b.n	6bf2 <UTIL1_ScanDoubleQuotedString+0x8e>
  }
  buf[bufSize-1] = '\0'; /* terminate buffer */
    6b80:	687b      	ldr	r3, [r7, #4]
    6b82:	3b01      	subs	r3, #1
    6b84:	68ba      	ldr	r2, [r7, #8]
    6b86:	4413      	add	r3, r2
    6b88:	2200      	movs	r2, #0
    6b8a:	701a      	strb	r2, [r3, #0]
  bufSize--;
    6b8c:	687b      	ldr	r3, [r7, #4]
    6b8e:	3b01      	subs	r3, #1
    6b90:	607b      	str	r3, [r7, #4]
  if (*p!='\"') {
    6b92:	697b      	ldr	r3, [r7, #20]
    6b94:	781b      	ldrb	r3, [r3, #0]
    6b96:	2b22      	cmp	r3, #34	; 0x22
    6b98:	d001      	beq.n	6b9e <UTIL1_ScanDoubleQuotedString+0x3a>
    return ERR_FAILED; /* does not start with double quote */
    6b9a:	231b      	movs	r3, #27
    6b9c:	e029      	b.n	6bf2 <UTIL1_ScanDoubleQuotedString+0x8e>
  }
  p++; /* skip double quote */
    6b9e:	697b      	ldr	r3, [r7, #20]
    6ba0:	3301      	adds	r3, #1
    6ba2:	617b      	str	r3, [r7, #20]
  while(*p!='\"' && *p!='\0' && bufSize>0) {
    6ba4:	e00a      	b.n	6bbc <UTIL1_ScanDoubleQuotedString+0x58>
    *buf++ = *p++;
    6ba6:	68bb      	ldr	r3, [r7, #8]
    6ba8:	1c5a      	adds	r2, r3, #1
    6baa:	60ba      	str	r2, [r7, #8]
    6bac:	697a      	ldr	r2, [r7, #20]
    6bae:	1c51      	adds	r1, r2, #1
    6bb0:	6179      	str	r1, [r7, #20]
    6bb2:	7812      	ldrb	r2, [r2, #0]
    6bb4:	701a      	strb	r2, [r3, #0]
    bufSize--;
    6bb6:	687b      	ldr	r3, [r7, #4]
    6bb8:	3b01      	subs	r3, #1
    6bba:	607b      	str	r3, [r7, #4]
  bufSize--;
  if (*p!='\"') {
    return ERR_FAILED; /* does not start with double quote */
  }
  p++; /* skip double quote */
  while(*p!='\"' && *p!='\0' && bufSize>0) {
    6bbc:	697b      	ldr	r3, [r7, #20]
    6bbe:	781b      	ldrb	r3, [r3, #0]
    6bc0:	2b22      	cmp	r3, #34	; 0x22
    6bc2:	d006      	beq.n	6bd2 <UTIL1_ScanDoubleQuotedString+0x6e>
    6bc4:	697b      	ldr	r3, [r7, #20]
    6bc6:	781b      	ldrb	r3, [r3, #0]
    6bc8:	2b00      	cmp	r3, #0
    6bca:	d002      	beq.n	6bd2 <UTIL1_ScanDoubleQuotedString+0x6e>
    6bcc:	687b      	ldr	r3, [r7, #4]
    6bce:	2b00      	cmp	r3, #0
    6bd0:	d1e9      	bne.n	6ba6 <UTIL1_ScanDoubleQuotedString+0x42>
    *buf++ = *p++;
    bufSize--;
  }
  if (*p!='\"') {
    6bd2:	697b      	ldr	r3, [r7, #20]
    6bd4:	781b      	ldrb	r3, [r3, #0]
    6bd6:	2b22      	cmp	r3, #34	; 0x22
    6bd8:	d001      	beq.n	6bde <UTIL1_ScanDoubleQuotedString+0x7a>
    return ERR_FAILED; /* no terminating double quote */
    6bda:	231b      	movs	r3, #27
    6bdc:	e009      	b.n	6bf2 <UTIL1_ScanDoubleQuotedString+0x8e>
  } else {
    p++; /* skip double quote */
    6bde:	697b      	ldr	r3, [r7, #20]
    6be0:	3301      	adds	r3, #1
    6be2:	617b      	str	r3, [r7, #20]
    *buf = '\0'; /* terminate buffer */
    6be4:	68bb      	ldr	r3, [r7, #8]
    6be6:	2200      	movs	r2, #0
    6be8:	701a      	strb	r2, [r3, #0]
  }
  *cmd = p; /* advance pointer */
    6bea:	68fb      	ldr	r3, [r7, #12]
    6bec:	697a      	ldr	r2, [r7, #20]
    6bee:	601a      	str	r2, [r3, #0]
  return ERR_OK;
    6bf0:	2300      	movs	r3, #0
}
    6bf2:	4618      	mov	r0, r3
    6bf4:	371c      	adds	r7, #28
    6bf6:	46bd      	mov	sp, r7
    6bf8:	f85d 7b04 	ldr.w	r7, [sp], #4
    6bfc:	4770      	bx	lr
    6bfe:	bf00      	nop

00006c00 <UTIL1_strcatPad>:
**                           has to be padded.
**     Returns     : Nothing
** ===================================================================
*/
void UTIL1_strcatPad(uint8_t *dst, size_t dstSize, const unsigned char *src, char padChar, uint8_t srcPadSize)
{
    6c00:	b580      	push	{r7, lr}
    6c02:	b086      	sub	sp, #24
    6c04:	af00      	add	r7, sp, #0
    6c06:	60f8      	str	r0, [r7, #12]
    6c08:	60b9      	str	r1, [r7, #8]
    6c0a:	607a      	str	r2, [r7, #4]
    6c0c:	70fb      	strb	r3, [r7, #3]
  uint8_t *p;
  size_t nof = 0;
    6c0e:	2300      	movs	r3, #0
    6c10:	613b      	str	r3, [r7, #16]

  if (dstSize<2) {
    6c12:	68bb      	ldr	r3, [r7, #8]
    6c14:	2b01      	cmp	r3, #1
    6c16:	d800      	bhi.n	6c1a <UTIL1_strcatPad+0x1a>
    return; /* hmm, really to small for anything than the zero byte? */
    6c18:	e04a      	b.n	6cb0 <UTIL1_strcatPad+0xb0>
  }
  p = dst;
    6c1a:	68fb      	ldr	r3, [r7, #12]
    6c1c:	617b      	str	r3, [r7, #20]
  while(*p != '\0') { /* find end of string */
    6c1e:	e005      	b.n	6c2c <UTIL1_strcatPad+0x2c>
    p++;
    6c20:	697b      	ldr	r3, [r7, #20]
    6c22:	3301      	adds	r3, #1
    6c24:	617b      	str	r3, [r7, #20]
    nof++;
    6c26:	693b      	ldr	r3, [r7, #16]
    6c28:	3301      	adds	r3, #1
    6c2a:	613b      	str	r3, [r7, #16]

  if (dstSize<2) {
    return; /* hmm, really to small for anything than the zero byte? */
  }
  p = dst;
  while(*p != '\0') { /* find end of string */
    6c2c:	697b      	ldr	r3, [r7, #20]
    6c2e:	781b      	ldrb	r3, [r3, #0]
    6c30:	2b00      	cmp	r3, #0
    6c32:	d1f5      	bne.n	6c20 <UTIL1_strcatPad+0x20>
    p++;
    nof++;
  }
  UTIL1_strcat(dst+nof, dstSize-nof, src); /* add string */
    6c34:	68fa      	ldr	r2, [r7, #12]
    6c36:	693b      	ldr	r3, [r7, #16]
    6c38:	441a      	add	r2, r3
    6c3a:	68b9      	ldr	r1, [r7, #8]
    6c3c:	693b      	ldr	r3, [r7, #16]
    6c3e:	1acb      	subs	r3, r1, r3
    6c40:	4610      	mov	r0, r2
    6c42:	4619      	mov	r1, r3
    6c44:	687a      	ldr	r2, [r7, #4]
    6c46:	f7fe fadb 	bl	5200 <UTIL1_strcat>
  dstSize -= nof;
    6c4a:	68ba      	ldr	r2, [r7, #8]
    6c4c:	693b      	ldr	r3, [r7, #16]
    6c4e:	1ad3      	subs	r3, r2, r3
    6c50:	60bb      	str	r3, [r7, #8]
  while(*p != '\0' && srcPadSize>0 && dstSize>1) {
    6c52:	e00a      	b.n	6c6a <UTIL1_strcatPad+0x6a>
    p++;
    6c54:	697b      	ldr	r3, [r7, #20]
    6c56:	3301      	adds	r3, #1
    6c58:	617b      	str	r3, [r7, #20]
    srcPadSize--;
    6c5a:	f897 3020 	ldrb.w	r3, [r7, #32]
    6c5e:	3b01      	subs	r3, #1
    6c60:	f887 3020 	strb.w	r3, [r7, #32]
    dstSize--;
    6c64:	68bb      	ldr	r3, [r7, #8]
    6c66:	3b01      	subs	r3, #1
    6c68:	60bb      	str	r3, [r7, #8]
    p++;
    nof++;
  }
  UTIL1_strcat(dst+nof, dstSize-nof, src); /* add string */
  dstSize -= nof;
  while(*p != '\0' && srcPadSize>0 && dstSize>1) {
    6c6a:	697b      	ldr	r3, [r7, #20]
    6c6c:	781b      	ldrb	r3, [r3, #0]
    6c6e:	2b00      	cmp	r3, #0
    6c70:	d006      	beq.n	6c80 <UTIL1_strcatPad+0x80>
    6c72:	f897 3020 	ldrb.w	r3, [r7, #32]
    6c76:	2b00      	cmp	r3, #0
    6c78:	d002      	beq.n	6c80 <UTIL1_strcatPad+0x80>
    6c7a:	68bb      	ldr	r3, [r7, #8]
    6c7c:	2b01      	cmp	r3, #1
    6c7e:	d8e9      	bhi.n	6c54 <UTIL1_strcatPad+0x54>
    p++;
    srcPadSize--;
    dstSize--;
  }
  while(srcPadSize>0 && dstSize>1) {
    6c80:	e00c      	b.n	6c9c <UTIL1_strcatPad+0x9c>
    *p++ = padChar; /* add padding char */
    6c82:	697b      	ldr	r3, [r7, #20]
    6c84:	1c5a      	adds	r2, r3, #1
    6c86:	617a      	str	r2, [r7, #20]
    6c88:	78fa      	ldrb	r2, [r7, #3]
    6c8a:	701a      	strb	r2, [r3, #0]
    srcPadSize--;
    6c8c:	f897 3020 	ldrb.w	r3, [r7, #32]
    6c90:	3b01      	subs	r3, #1
    6c92:	f887 3020 	strb.w	r3, [r7, #32]
    dstSize--;
    6c96:	68bb      	ldr	r3, [r7, #8]
    6c98:	3b01      	subs	r3, #1
    6c9a:	60bb      	str	r3, [r7, #8]
  while(*p != '\0' && srcPadSize>0 && dstSize>1) {
    p++;
    srcPadSize--;
    dstSize--;
  }
  while(srcPadSize>0 && dstSize>1) {
    6c9c:	f897 3020 	ldrb.w	r3, [r7, #32]
    6ca0:	2b00      	cmp	r3, #0
    6ca2:	d002      	beq.n	6caa <UTIL1_strcatPad+0xaa>
    6ca4:	68bb      	ldr	r3, [r7, #8]
    6ca6:	2b01      	cmp	r3, #1
    6ca8:	d8eb      	bhi.n	6c82 <UTIL1_strcatPad+0x82>
    *p++ = padChar; /* add padding char */
    srcPadSize--;
    dstSize--;
  }
  *p = '\0'; /* terminate string */
    6caa:	697b      	ldr	r3, [r7, #20]
    6cac:	2200      	movs	r2, #0
    6cae:	701a      	strb	r2, [r3, #0]
}
    6cb0:	3718      	adds	r7, #24
    6cb2:	46bd      	mov	sp, r7
    6cb4:	bd80      	pop	{r7, pc}
    6cb6:	bf00      	nop

00006cb8 <PE_FillMemory>:
**     @param
**       len - Length of a memory block to fill.
*/
/* ===================================================================*/
void PE_FillMemory(register void* SourceAddressPtr, register uint8_t c, register uint32_t len)
{
    6cb8:	b490      	push	{r4, r7}
    6cba:	af00      	add	r7, sp, #0
    6cbc:	4613      	mov	r3, r2
  register uint8_t *ptr = (uint8_t*)SourceAddressPtr;
    6cbe:	4604      	mov	r4, r0

  if (len > 0U) {
    6cc0:	2b00      	cmp	r3, #0
    6cc2:	d008      	beq.n	6cd6 <PE_FillMemory+0x1e>
    while (len--) {
    6cc4:	e003      	b.n	6cce <PE_FillMemory+0x16>
      *ptr++ = c;
    6cc6:	4622      	mov	r2, r4
    6cc8:	1c54      	adds	r4, r2, #1
    6cca:	4608      	mov	r0, r1
    6ccc:	7010      	strb	r0, [r2, #0]
void PE_FillMemory(register void* SourceAddressPtr, register uint8_t c, register uint32_t len)
{
  register uint8_t *ptr = (uint8_t*)SourceAddressPtr;

  if (len > 0U) {
    while (len--) {
    6cce:	461a      	mov	r2, r3
    6cd0:	1e53      	subs	r3, r2, #1
    6cd2:	2a00      	cmp	r2, #0
    6cd4:	d1f7      	bne.n	6cc6 <PE_FillMemory+0xe>
      *ptr++ = c;
    }
  }
}
    6cd6:	46bd      	mov	sp, r7
    6cd8:	bc90      	pop	{r4, r7}
    6cda:	4770      	bx	lr

00006cdc <PE_PeripheralUsed>:
**     @return
**       TRUE if a peripheral is used by PEx or FALSE if it isn't used.
*/
/* ===================================================================*/
bool PE_PeripheralUsed(uint32_t PrphBaseAddress)
{
    6cdc:	b480      	push	{r7}
    6cde:	b085      	sub	sp, #20
    6ce0:	af00      	add	r7, sp, #0
    6ce2:	6078      	str	r0, [r7, #4]
  bool result = FALSE;
    6ce4:	2300      	movs	r3, #0
    6ce6:	73fb      	strb	r3, [r7, #15]

  switch (PrphBaseAddress) {
    6ce8:	687b      	ldr	r3, [r7, #4]
    6cea:	4a08      	ldr	r2, [pc, #32]	; (6d0c <PE_PeripheralUsed+0x30>)
    6cec:	4293      	cmp	r3, r2
    6cee:	d003      	beq.n	6cf8 <PE_PeripheralUsed+0x1c>
    6cf0:	4a07      	ldr	r2, [pc, #28]	; (6d10 <PE_PeripheralUsed+0x34>)
    6cf2:	4293      	cmp	r3, r2
    6cf4:	d000      	beq.n	6cf8 <PE_PeripheralUsed+0x1c>
    /* Base address allocated by peripheral(s) PTE */
    case 0x400FF100UL:
      result = TRUE;
      break;
    default:
      break;
    6cf6:	e002      	b.n	6cfe <PE_PeripheralUsed+0x22>
  switch (PrphBaseAddress) {
    /* Base address allocated by peripheral(s) PTB */
    case 0x400FF040UL:
    /* Base address allocated by peripheral(s) PTE */
    case 0x400FF100UL:
      result = TRUE;
    6cf8:	2301      	movs	r3, #1
    6cfa:	73fb      	strb	r3, [r7, #15]
      break;
    6cfc:	bf00      	nop
    default:
      break;
  }
  return result;
    6cfe:	7bfb      	ldrb	r3, [r7, #15]
}
    6d00:	4618      	mov	r0, r3
    6d02:	3714      	adds	r7, #20
    6d04:	46bd      	mov	sp, r7
    6d06:	f85d 7b04 	ldr.w	r7, [sp], #4
    6d0a:	4770      	bx	lr
    6d0c:	400ff040 	.word	0x400ff040
    6d10:	400ff100 	.word	0x400ff100

00006d14 <LDD_SetClockConfiguration>:
**     @param
**       ClockConfiguration - New CPU clock configuration changed by CPU SetClockConfiguration method.
*/
/* ===================================================================*/
void LDD_SetClockConfiguration(LDD_TClockConfiguration ClockConfiguration)
{
    6d14:	b480      	push	{r7}
    6d16:	b083      	sub	sp, #12
    6d18:	af00      	add	r7, sp, #0
    6d1a:	4603      	mov	r3, r0
    6d1c:	71fb      	strb	r3, [r7, #7]
  (void)ClockConfiguration;            /*!< Parameter is not used, suppress unused argument warning */
}
    6d1e:	370c      	adds	r7, #12
    6d20:	46bd      	mov	sp, r7
    6d22:	f85d 7b04 	ldr.w	r7, [sp], #4
    6d26:	4770      	bx	lr

00006d28 <LED_Red_Deinit>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void LED_Red_Deinit(void)
{
    6d28:	b480      	push	{r7}
    6d2a:	af00      	add	r7, sp, #0
}
    6d2c:	46bd      	mov	sp, r7
    6d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
    6d32:	4770      	bx	lr

00006d34 <LED_Red_SetRatio16>:
**                           0xffff means 'on'
**     Returns     : Nothing
** ===================================================================
*/
void LED_Red_SetRatio16(uint16_t ratio)
{
    6d34:	b580      	push	{r7, lr}
    6d36:	b082      	sub	sp, #8
    6d38:	af00      	add	r7, sp, #0
    6d3a:	4603      	mov	r3, r0
    6d3c:	80fb      	strh	r3, [r7, #6]
  /* on/off LED: binary on or off */
  if (ratio<(0xffff/2)) {
    6d3e:	88fa      	ldrh	r2, [r7, #6]
    6d40:	f647 73fe 	movw	r3, #32766	; 0x7ffe
    6d44:	429a      	cmp	r2, r3
    6d46:	d805      	bhi.n	6d54 <LED_Red_SetRatio16+0x20>
    LED_Red_Off();
    6d48:	4b06      	ldr	r3, [pc, #24]	; (6d64 <LED_Red_SetRatio16+0x30>)
    6d4a:	685b      	ldr	r3, [r3, #4]
    6d4c:	4618      	mov	r0, r3
    6d4e:	f000 f971 	bl	7034 <BitIoLdd2_SetVal>
    6d52:	e004      	b.n	6d5e <LED_Red_SetRatio16+0x2a>
  } else {
    LED_Red_On();
    6d54:	4b03      	ldr	r3, [pc, #12]	; (6d64 <LED_Red_SetRatio16+0x30>)
    6d56:	685b      	ldr	r3, [r3, #4]
    6d58:	4618      	mov	r0, r3
    6d5a:	f000 f95b 	bl	7014 <BitIoLdd2_ClrVal>
  }
}
    6d5e:	3708      	adds	r7, #8
    6d60:	46bd      	mov	sp, r7
    6d62:	bd80      	pop	{r7, pc}
    6d64:	2000119c 	.word	0x2000119c

00006d68 <LED_Green_Deinit>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void LED_Green_Deinit(void)
{
    6d68:	b480      	push	{r7}
    6d6a:	af00      	add	r7, sp, #0
}
    6d6c:	46bd      	mov	sp, r7
    6d6e:	f85d 7b04 	ldr.w	r7, [sp], #4
    6d72:	4770      	bx	lr

00006d74 <LED_Green_SetRatio16>:
**                           0xffff means 'on'
**     Returns     : Nothing
** ===================================================================
*/
void LED_Green_SetRatio16(uint16_t ratio)
{
    6d74:	b580      	push	{r7, lr}
    6d76:	b082      	sub	sp, #8
    6d78:	af00      	add	r7, sp, #0
    6d7a:	4603      	mov	r3, r0
    6d7c:	80fb      	strh	r3, [r7, #6]
  /* on/off LED: binary on or off */
  if (ratio<(0xffff/2)) {
    6d7e:	88fa      	ldrh	r2, [r7, #6]
    6d80:	f647 73fe 	movw	r3, #32766	; 0x7ffe
    6d84:	429a      	cmp	r2, r3
    6d86:	d805      	bhi.n	6d94 <LED_Green_SetRatio16+0x20>
    LED_Green_Off();
    6d88:	4b06      	ldr	r3, [pc, #24]	; (6da4 <LED_Green_SetRatio16+0x30>)
    6d8a:	689b      	ldr	r3, [r3, #8]
    6d8c:	4618      	mov	r0, r3
    6d8e:	f000 f8c9 	bl	6f24 <BitIoLdd3_SetVal>
    6d92:	e004      	b.n	6d9e <LED_Green_SetRatio16+0x2a>
  } else {
    LED_Green_On();
    6d94:	4b03      	ldr	r3, [pc, #12]	; (6da4 <LED_Green_SetRatio16+0x30>)
    6d96:	689b      	ldr	r3, [r3, #8]
    6d98:	4618      	mov	r0, r3
    6d9a:	f000 f8b3 	bl	6f04 <BitIoLdd3_ClrVal>
  }
}
    6d9e:	3708      	adds	r7, #8
    6da0:	46bd      	mov	sp, r7
    6da2:	bd80      	pop	{r7, pc}
    6da4:	2000119c 	.word	0x2000119c

00006da8 <LED_Blue_Deinit>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void LED_Blue_Deinit(void)
{
    6da8:	b480      	push	{r7}
    6daa:	af00      	add	r7, sp, #0
}
    6dac:	46bd      	mov	sp, r7
    6dae:	f85d 7b04 	ldr.w	r7, [sp], #4
    6db2:	4770      	bx	lr

00006db4 <LED_Blue_SetRatio16>:
**                           0xffff means 'on'
**     Returns     : Nothing
** ===================================================================
*/
void LED_Blue_SetRatio16(uint16_t ratio)
{
    6db4:	b580      	push	{r7, lr}
    6db6:	b082      	sub	sp, #8
    6db8:	af00      	add	r7, sp, #0
    6dba:	4603      	mov	r3, r0
    6dbc:	80fb      	strh	r3, [r7, #6]
  /* on/off LED: binary on or off */
  if (ratio<(0xffff/2)) {
    6dbe:	88fa      	ldrh	r2, [r7, #6]
    6dc0:	f647 73fe 	movw	r3, #32766	; 0x7ffe
    6dc4:	429a      	cmp	r2, r3
    6dc6:	d805      	bhi.n	6dd4 <LED_Blue_SetRatio16+0x20>
    LED_Blue_Off();
    6dc8:	4b06      	ldr	r3, [pc, #24]	; (6de4 <LED_Blue_SetRatio16+0x30>)
    6dca:	681b      	ldr	r3, [r3, #0]
    6dcc:	4618      	mov	r0, r3
    6dce:	f000 f9b9 	bl	7144 <BitIoLdd1_SetVal>
    6dd2:	e004      	b.n	6dde <LED_Blue_SetRatio16+0x2a>
  } else {
    LED_Blue_On();
    6dd4:	4b03      	ldr	r3, [pc, #12]	; (6de4 <LED_Blue_SetRatio16+0x30>)
    6dd6:	681b      	ldr	r3, [r3, #0]
    6dd8:	4618      	mov	r0, r3
    6dda:	f000 f9a3 	bl	7124 <BitIoLdd1_ClrVal>
  }
}
    6dde:	3708      	adds	r7, #8
    6de0:	46bd      	mov	sp, r7
    6de2:	bd80      	pop	{r7, pc}
    6de4:	2000119c 	.word	0x2000119c

00006de8 <FRTOS1_Init>:
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FRTOS1_Init(void)
{
    6de8:	b580      	push	{r7, lr}
    6dea:	af00      	add	r7, sp, #0
  vPortInitTickTimer();
    6dec:	f7fd fb9a 	bl	4524 <vPortInitTickTimer>
  vPortStopTickTimer();
    6df0:	f7fd fbc4 	bl	457c <vPortStopTickTimer>
}
    6df4:	bd80      	pop	{r7, pc}
    6df6:	bf00      	nop

00006df8 <Components_Init>:
**     Returns     : Nothing
** ===================================================================
*/
#if CPU_COMPONENTS_INIT
void Components_Init(void)
{
    6df8:	b580      	push	{r7, lr}
    6dfa:	af00      	add	r7, sp, #0
  /* ### FreeRTOS "FRTOS1" init code ... */
#if configSYSTICK_USE_LOW_POWER_TIMER
  /* enable clocking for low power timer, otherwise vPortStopTickTimer() will crash */
  SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_LPTMR0, PDD_ENABLE);
#endif
  vPortStopTickTimer(); /* tick timer shall not run until the RTOS scheduler is started */
    6dfc:	f7fd fbbe 	bl	457c <vPortStopTickTimer>
  /* ### BitIO_LDD "BitIoLdd1" component auto initialization. Auto initialization feature can be disabled by component property "Auto initialization". */
  (void)BitIoLdd1_Init(NULL);
    6e00:	2000      	movs	r0, #0
    6e02:	f000 f937 	bl	7074 <BitIoLdd1_Init>
  /* ### LED "LED_Blue" init code ... */
  LED_Blue_Init(); /* initialize LED driver */
    6e06:	4b0b      	ldr	r3, [pc, #44]	; (6e34 <Components_Init+0x3c>)
    6e08:	681b      	ldr	r3, [r3, #0]
    6e0a:	4618      	mov	r0, r3
    6e0c:	f000 f99a 	bl	7144 <BitIoLdd1_SetVal>
  /* ### BitIO_LDD "BitIoLdd2" component auto initialization. Auto initialization feature can be disabled by component property "Auto initialization". */
  (void)BitIoLdd2_Init(NULL);
    6e10:	2000      	movs	r0, #0
    6e12:	f000 f8a7 	bl	6f64 <BitIoLdd2_Init>
  /* ### LED "LED_Red" init code ... */
  LED_Red_Init(); /* initialize LED driver */
    6e16:	4b07      	ldr	r3, [pc, #28]	; (6e34 <Components_Init+0x3c>)
    6e18:	685b      	ldr	r3, [r3, #4]
    6e1a:	4618      	mov	r0, r3
    6e1c:	f000 f90a 	bl	7034 <BitIoLdd2_SetVal>
  /* ### BitIO_LDD "BitIoLdd3" component auto initialization. Auto initialization feature can be disabled by component property "Auto initialization". */
  (void)BitIoLdd3_Init(NULL);
    6e20:	2000      	movs	r0, #0
    6e22:	f000 f817 	bl	6e54 <BitIoLdd3_Init>
  /* ### LED "LED_Green" init code ... */
  LED_Green_Init(); /* initialize LED driver */
    6e26:	4b03      	ldr	r3, [pc, #12]	; (6e34 <Components_Init+0x3c>)
    6e28:	689b      	ldr	r3, [r3, #8]
    6e2a:	4618      	mov	r0, r3
    6e2c:	f000 f87a 	bl	6f24 <BitIoLdd3_SetVal>
}
    6e30:	bd80      	pop	{r7, pc}
    6e32:	bf00      	nop
    6e34:	2000119c 	.word	0x2000119c

00006e38 <Cpu_INT_NMIInterrupt>:
**         This ISR services the Non Maskable Interrupt interrupt.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(Cpu_INT_NMIInterrupt)
{
    6e38:	4668      	mov	r0, sp
    6e3a:	f020 0107 	bic.w	r1, r0, #7
    6e3e:	468d      	mov	sp, r1
    6e40:	b589      	push	{r0, r3, r7, lr}
    6e42:	af00      	add	r7, sp, #0
  Cpu_OnNMI();
    6e44:	f7fa fc96 	bl	1774 <Cpu_OnNMI>
}
    6e48:	46bd      	mov	sp, r7
    6e4a:	e8bd 4089 	ldmia.w	sp!, {r0, r3, r7, lr}
    6e4e:	4685      	mov	sp, r0
    6e50:	4770      	bx	lr
    6e52:	bf00      	nop

00006e54 <BitIoLdd3_Init>:
**                         - Pointer to the dynamically allocated private
**                           structure or NULL if there was an error.
*/
/* ===================================================================*/
LDD_TDeviceData* BitIoLdd3_Init(LDD_TUserData *UserDataPtr)
{
    6e54:	b480      	push	{r7}
    6e56:	b085      	sub	sp, #20
    6e58:	af00      	add	r7, sp, #0
    6e5a:	6078      	str	r0, [r7, #4]
  /* Allocate device structure */
  BitIoLdd3_TDeviceDataPtr DeviceDataPrv;

  /* {FreeRTOS RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
    6e5c:	4b18      	ldr	r3, [pc, #96]	; (6ec0 <BitIoLdd3_Init+0x6c>)
    6e5e:	60fb      	str	r3, [r7, #12]
  DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
    6e60:	68fb      	ldr	r3, [r7, #12]
    6e62:	687a      	ldr	r2, [r7, #4]
    6e64:	601a      	str	r2, [r3, #0]
  /* Enable device clock gate */
  /* SIM_SCGC5: PORTE=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTE_MASK;
    6e66:	4917      	ldr	r1, [pc, #92]	; (6ec4 <BitIoLdd3_Init+0x70>)
    6e68:	4b16      	ldr	r3, [pc, #88]	; (6ec4 <BitIoLdd3_Init+0x70>)
    6e6a:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6e6e:	3318      	adds	r3, #24
    6e70:	681b      	ldr	r3, [r3, #0]
    6e72:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
    6e76:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
    6e7a:	3318      	adds	r3, #24
    6e7c:	601a      	str	r2, [r3, #0]
  /* Configure pin as output */
  /* GPIOE_PDDR: PDD|=0x04000000 */
  GPIOE_PDDR |= GPIO_PDDR_PDD(0x04000000);
    6e7e:	4b12      	ldr	r3, [pc, #72]	; (6ec8 <BitIoLdd3_Init+0x74>)
    6e80:	4a11      	ldr	r2, [pc, #68]	; (6ec8 <BitIoLdd3_Init+0x74>)
    6e82:	6952      	ldr	r2, [r2, #20]
    6e84:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
    6e88:	615a      	str	r2, [r3, #20]
  /* Set initialization value */
  /* GPIOE_PDOR: PDO&=~0x04000000 */
  GPIOE_PDOR &= (uint32_t)~(uint32_t)(GPIO_PDOR_PDO(0x04000000));
    6e8a:	4b0f      	ldr	r3, [pc, #60]	; (6ec8 <BitIoLdd3_Init+0x74>)
    6e8c:	4a0e      	ldr	r2, [pc, #56]	; (6ec8 <BitIoLdd3_Init+0x74>)
    6e8e:	6812      	ldr	r2, [r2, #0]
    6e90:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
    6e94:	601a      	str	r2, [r3, #0]
  /* Initialization of pin routing */
  /* PORTE_PCR26: ISF=0,MUX=1 */
  PORTE_PCR26 = (uint32_t)((PORTE_PCR26 & (uint32_t)~(uint32_t)(
    6e96:	4a0d      	ldr	r2, [pc, #52]	; (6ecc <BitIoLdd3_Init+0x78>)
    6e98:	4b0c      	ldr	r3, [pc, #48]	; (6ecc <BitIoLdd3_Init+0x78>)
    6e9a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    6e9c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    6ea0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    6ea4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    6ea8:	6693      	str	r3, [r2, #104]	; 0x68
                 PORT_PCR_MUX(0x06)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x01)
                ));
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_BitIoLdd3_ID,DeviceDataPrv);
    6eaa:	4b09      	ldr	r3, [pc, #36]	; (6ed0 <BitIoLdd3_Init+0x7c>)
    6eac:	68fa      	ldr	r2, [r7, #12]
    6eae:	609a      	str	r2, [r3, #8]
  return ((LDD_TDeviceData *)DeviceDataPrv);
    6eb0:	68fb      	ldr	r3, [r7, #12]
}
    6eb2:	4618      	mov	r0, r3
    6eb4:	3714      	adds	r7, #20
    6eb6:	46bd      	mov	sp, r7
    6eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
    6ebc:	4770      	bx	lr
    6ebe:	bf00      	nop
    6ec0:	200011a8 	.word	0x200011a8
    6ec4:	40047000 	.word	0x40047000
    6ec8:	400ff100 	.word	0x400ff100
    6ecc:	4004d000 	.word	0x4004d000
    6ed0:	2000119c 	.word	0x2000119c

00006ed4 <BitIoLdd3_GetVal>:
**                           <false> - logical "0" (Low level)
**                           <true> - logical "1" (High level)
*/
/* ===================================================================*/
bool BitIoLdd3_GetVal(LDD_TDeviceData *DeviceDataPtr)
{
    6ed4:	b480      	push	{r7}
    6ed6:	b085      	sub	sp, #20
    6ed8:	af00      	add	r7, sp, #0
    6eda:	6078      	str	r0, [r7, #4]
  uint32_t PortData;                   /* Port data masked according to the bit used */

  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  PortData = GPIO_PDD_GetPortDataOutput(BitIoLdd3_MODULE_BASE_ADDRESS) & BitIoLdd3_PORT_MASK;
    6edc:	4b08      	ldr	r3, [pc, #32]	; (6f00 <BitIoLdd3_GetVal+0x2c>)
    6ede:	681b      	ldr	r3, [r3, #0]
    6ee0:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    6ee4:	60fb      	str	r3, [r7, #12]
  return (PortData != 0U) ? (bool)TRUE : (bool)FALSE;
    6ee6:	68fb      	ldr	r3, [r7, #12]
    6ee8:	2b00      	cmp	r3, #0
    6eea:	bf0c      	ite	eq
    6eec:	2300      	moveq	r3, #0
    6eee:	2301      	movne	r3, #1
    6ef0:	b2db      	uxtb	r3, r3
}
    6ef2:	4618      	mov	r0, r3
    6ef4:	3714      	adds	r7, #20
    6ef6:	46bd      	mov	sp, r7
    6ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
    6efc:	4770      	bx	lr
    6efe:	bf00      	nop
    6f00:	400ff100 	.word	0x400ff100

00006f04 <BitIoLdd3_ClrVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd3_ClrVal(LDD_TDeviceData *DeviceDataPtr)
{
    6f04:	b480      	push	{r7}
    6f06:	b083      	sub	sp, #12
    6f08:	af00      	add	r7, sp, #0
    6f0a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_ClearPortDataOutputMask(BitIoLdd3_MODULE_BASE_ADDRESS, BitIoLdd3_PORT_MASK);
    6f0c:	4b04      	ldr	r3, [pc, #16]	; (6f20 <BitIoLdd3_ClrVal+0x1c>)
    6f0e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
    6f12:	609a      	str	r2, [r3, #8]
}
    6f14:	370c      	adds	r7, #12
    6f16:	46bd      	mov	sp, r7
    6f18:	f85d 7b04 	ldr.w	r7, [sp], #4
    6f1c:	4770      	bx	lr
    6f1e:	bf00      	nop
    6f20:	400ff100 	.word	0x400ff100

00006f24 <BitIoLdd3_SetVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd3_SetVal(LDD_TDeviceData *DeviceDataPtr)
{
    6f24:	b480      	push	{r7}
    6f26:	b083      	sub	sp, #12
    6f28:	af00      	add	r7, sp, #0
    6f2a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_SetPortDataOutputMask(BitIoLdd3_MODULE_BASE_ADDRESS, BitIoLdd3_PORT_MASK);
    6f2c:	4b04      	ldr	r3, [pc, #16]	; (6f40 <BitIoLdd3_SetVal+0x1c>)
    6f2e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
    6f32:	605a      	str	r2, [r3, #4]
}
    6f34:	370c      	adds	r7, #12
    6f36:	46bd      	mov	sp, r7
    6f38:	f85d 7b04 	ldr.w	r7, [sp], #4
    6f3c:	4770      	bx	lr
    6f3e:	bf00      	nop
    6f40:	400ff100 	.word	0x400ff100

00006f44 <BitIoLdd3_NegVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd3_NegVal(LDD_TDeviceData *DeviceDataPtr)
{
    6f44:	b480      	push	{r7}
    6f46:	b083      	sub	sp, #12
    6f48:	af00      	add	r7, sp, #0
    6f4a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_TogglePortDataOutputMask(BitIoLdd3_MODULE_BASE_ADDRESS, BitIoLdd3_PORT_MASK);
    6f4c:	4b04      	ldr	r3, [pc, #16]	; (6f60 <BitIoLdd3_NegVal+0x1c>)
    6f4e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
    6f52:	60da      	str	r2, [r3, #12]
}
    6f54:	370c      	adds	r7, #12
    6f56:	46bd      	mov	sp, r7
    6f58:	f85d 7b04 	ldr.w	r7, [sp], #4
    6f5c:	4770      	bx	lr
    6f5e:	bf00      	nop
    6f60:	400ff100 	.word	0x400ff100

00006f64 <BitIoLdd2_Init>:
**                         - Pointer to the dynamically allocated private
**                           structure or NULL if there was an error.
*/
/* ===================================================================*/
LDD_TDeviceData* BitIoLdd2_Init(LDD_TUserData *UserDataPtr)
{
    6f64:	b480      	push	{r7}
    6f66:	b085      	sub	sp, #20
    6f68:	af00      	add	r7, sp, #0
    6f6a:	6078      	str	r0, [r7, #4]
  /* Allocate device structure */
  BitIoLdd2_TDeviceDataPtr DeviceDataPrv;

  /* {FreeRTOS RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
    6f6c:	4b18      	ldr	r3, [pc, #96]	; (6fd0 <BitIoLdd2_Init+0x6c>)
    6f6e:	60fb      	str	r3, [r7, #12]
  DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
    6f70:	68fb      	ldr	r3, [r7, #12]
    6f72:	687a      	ldr	r2, [r7, #4]
    6f74:	601a      	str	r2, [r3, #0]
  /* Enable device clock gate */
  /* SIM_SCGC5: PORTB=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
    6f76:	4917      	ldr	r1, [pc, #92]	; (6fd4 <BitIoLdd2_Init+0x70>)
    6f78:	4b16      	ldr	r3, [pc, #88]	; (6fd4 <BitIoLdd2_Init+0x70>)
    6f7a:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    6f7e:	3318      	adds	r3, #24
    6f80:	681b      	ldr	r3, [r3, #0]
    6f82:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
    6f86:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
    6f8a:	3318      	adds	r3, #24
    6f8c:	601a      	str	r2, [r3, #0]
  /* Configure pin as output */
  /* GPIOB_PDDR: PDD|=0x00400000 */
  GPIOB_PDDR |= GPIO_PDDR_PDD(0x00400000);
    6f8e:	4b12      	ldr	r3, [pc, #72]	; (6fd8 <BitIoLdd2_Init+0x74>)
    6f90:	4a11      	ldr	r2, [pc, #68]	; (6fd8 <BitIoLdd2_Init+0x74>)
    6f92:	6952      	ldr	r2, [r2, #20]
    6f94:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
    6f98:	615a      	str	r2, [r3, #20]
  /* Set initialization value */
  /* GPIOB_PDOR: PDO&=~0x00400000 */
  GPIOB_PDOR &= (uint32_t)~(uint32_t)(GPIO_PDOR_PDO(0x00400000));
    6f9a:	4b0f      	ldr	r3, [pc, #60]	; (6fd8 <BitIoLdd2_Init+0x74>)
    6f9c:	4a0e      	ldr	r2, [pc, #56]	; (6fd8 <BitIoLdd2_Init+0x74>)
    6f9e:	6812      	ldr	r2, [r2, #0]
    6fa0:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
    6fa4:	601a      	str	r2, [r3, #0]
  /* Initialization of pin routing */
  /* PORTB_PCR22: ISF=0,MUX=1 */
  PORTB_PCR22 = (uint32_t)((PORTB_PCR22 & (uint32_t)~(uint32_t)(
    6fa6:	4a0d      	ldr	r2, [pc, #52]	; (6fdc <BitIoLdd2_Init+0x78>)
    6fa8:	4b0c      	ldr	r3, [pc, #48]	; (6fdc <BitIoLdd2_Init+0x78>)
    6faa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    6fac:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    6fb0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    6fb4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    6fb8:	6593      	str	r3, [r2, #88]	; 0x58
                 PORT_PCR_MUX(0x06)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x01)
                ));
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_BitIoLdd2_ID,DeviceDataPrv);
    6fba:	4b09      	ldr	r3, [pc, #36]	; (6fe0 <BitIoLdd2_Init+0x7c>)
    6fbc:	68fa      	ldr	r2, [r7, #12]
    6fbe:	605a      	str	r2, [r3, #4]
  return ((LDD_TDeviceData *)DeviceDataPrv);
    6fc0:	68fb      	ldr	r3, [r7, #12]
}
    6fc2:	4618      	mov	r0, r3
    6fc4:	3714      	adds	r7, #20
    6fc6:	46bd      	mov	sp, r7
    6fc8:	f85d 7b04 	ldr.w	r7, [sp], #4
    6fcc:	4770      	bx	lr
    6fce:	bf00      	nop
    6fd0:	200011ac 	.word	0x200011ac
    6fd4:	40047000 	.word	0x40047000
    6fd8:	400ff040 	.word	0x400ff040
    6fdc:	4004a000 	.word	0x4004a000
    6fe0:	2000119c 	.word	0x2000119c

00006fe4 <BitIoLdd2_GetVal>:
**                           <false> - logical "0" (Low level)
**                           <true> - logical "1" (High level)
*/
/* ===================================================================*/
bool BitIoLdd2_GetVal(LDD_TDeviceData *DeviceDataPtr)
{
    6fe4:	b480      	push	{r7}
    6fe6:	b085      	sub	sp, #20
    6fe8:	af00      	add	r7, sp, #0
    6fea:	6078      	str	r0, [r7, #4]
  uint32_t PortData;                   /* Port data masked according to the bit used */

  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  PortData = GPIO_PDD_GetPortDataOutput(BitIoLdd2_MODULE_BASE_ADDRESS) & BitIoLdd2_PORT_MASK;
    6fec:	4b08      	ldr	r3, [pc, #32]	; (7010 <BitIoLdd2_GetVal+0x2c>)
    6fee:	681b      	ldr	r3, [r3, #0]
    6ff0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
    6ff4:	60fb      	str	r3, [r7, #12]
  return (PortData != 0U) ? (bool)TRUE : (bool)FALSE;
    6ff6:	68fb      	ldr	r3, [r7, #12]
    6ff8:	2b00      	cmp	r3, #0
    6ffa:	bf0c      	ite	eq
    6ffc:	2300      	moveq	r3, #0
    6ffe:	2301      	movne	r3, #1
    7000:	b2db      	uxtb	r3, r3
}
    7002:	4618      	mov	r0, r3
    7004:	3714      	adds	r7, #20
    7006:	46bd      	mov	sp, r7
    7008:	f85d 7b04 	ldr.w	r7, [sp], #4
    700c:	4770      	bx	lr
    700e:	bf00      	nop
    7010:	400ff040 	.word	0x400ff040

00007014 <BitIoLdd2_ClrVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd2_ClrVal(LDD_TDeviceData *DeviceDataPtr)
{
    7014:	b480      	push	{r7}
    7016:	b083      	sub	sp, #12
    7018:	af00      	add	r7, sp, #0
    701a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_ClearPortDataOutputMask(BitIoLdd2_MODULE_BASE_ADDRESS, BitIoLdd2_PORT_MASK);
    701c:	4b04      	ldr	r3, [pc, #16]	; (7030 <BitIoLdd2_ClrVal+0x1c>)
    701e:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    7022:	609a      	str	r2, [r3, #8]
}
    7024:	370c      	adds	r7, #12
    7026:	46bd      	mov	sp, r7
    7028:	f85d 7b04 	ldr.w	r7, [sp], #4
    702c:	4770      	bx	lr
    702e:	bf00      	nop
    7030:	400ff040 	.word	0x400ff040

00007034 <BitIoLdd2_SetVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd2_SetVal(LDD_TDeviceData *DeviceDataPtr)
{
    7034:	b480      	push	{r7}
    7036:	b083      	sub	sp, #12
    7038:	af00      	add	r7, sp, #0
    703a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_SetPortDataOutputMask(BitIoLdd2_MODULE_BASE_ADDRESS, BitIoLdd2_PORT_MASK);
    703c:	4b04      	ldr	r3, [pc, #16]	; (7050 <BitIoLdd2_SetVal+0x1c>)
    703e:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    7042:	605a      	str	r2, [r3, #4]
}
    7044:	370c      	adds	r7, #12
    7046:	46bd      	mov	sp, r7
    7048:	f85d 7b04 	ldr.w	r7, [sp], #4
    704c:	4770      	bx	lr
    704e:	bf00      	nop
    7050:	400ff040 	.word	0x400ff040

00007054 <BitIoLdd2_NegVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd2_NegVal(LDD_TDeviceData *DeviceDataPtr)
{
    7054:	b480      	push	{r7}
    7056:	b083      	sub	sp, #12
    7058:	af00      	add	r7, sp, #0
    705a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_TogglePortDataOutputMask(BitIoLdd2_MODULE_BASE_ADDRESS, BitIoLdd2_PORT_MASK);
    705c:	4b04      	ldr	r3, [pc, #16]	; (7070 <BitIoLdd2_NegVal+0x1c>)
    705e:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    7062:	60da      	str	r2, [r3, #12]
}
    7064:	370c      	adds	r7, #12
    7066:	46bd      	mov	sp, r7
    7068:	f85d 7b04 	ldr.w	r7, [sp], #4
    706c:	4770      	bx	lr
    706e:	bf00      	nop
    7070:	400ff040 	.word	0x400ff040

00007074 <BitIoLdd1_Init>:
**                         - Pointer to the dynamically allocated private
**                           structure or NULL if there was an error.
*/
/* ===================================================================*/
LDD_TDeviceData* BitIoLdd1_Init(LDD_TUserData *UserDataPtr)
{
    7074:	b480      	push	{r7}
    7076:	b085      	sub	sp, #20
    7078:	af00      	add	r7, sp, #0
    707a:	6078      	str	r0, [r7, #4]
  /* Allocate device structure */
  BitIoLdd1_TDeviceDataPtr DeviceDataPrv;

  /* {FreeRTOS RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
    707c:	4b18      	ldr	r3, [pc, #96]	; (70e0 <BitIoLdd1_Init+0x6c>)
    707e:	60fb      	str	r3, [r7, #12]
  DeviceDataPrv->UserDataPtr = UserDataPtr; /* Store the RTOS device structure */
    7080:	68fb      	ldr	r3, [r7, #12]
    7082:	687a      	ldr	r2, [r7, #4]
    7084:	601a      	str	r2, [r3, #0]
  /* Enable device clock gate */
  /* SIM_SCGC5: PORTB=1 */
  SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK;
    7086:	4917      	ldr	r1, [pc, #92]	; (70e4 <BitIoLdd1_Init+0x70>)
    7088:	4b16      	ldr	r3, [pc, #88]	; (70e4 <BitIoLdd1_Init+0x70>)
    708a:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    708e:	3318      	adds	r3, #24
    7090:	681b      	ldr	r3, [r3, #0]
    7092:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
    7096:	f501 5381 	add.w	r3, r1, #4128	; 0x1020
    709a:	3318      	adds	r3, #24
    709c:	601a      	str	r2, [r3, #0]
  /* Configure pin as output */
  /* GPIOB_PDDR: PDD|=0x00200000 */
  GPIOB_PDDR |= GPIO_PDDR_PDD(0x00200000);
    709e:	4b12      	ldr	r3, [pc, #72]	; (70e8 <BitIoLdd1_Init+0x74>)
    70a0:	4a11      	ldr	r2, [pc, #68]	; (70e8 <BitIoLdd1_Init+0x74>)
    70a2:	6952      	ldr	r2, [r2, #20]
    70a4:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
    70a8:	615a      	str	r2, [r3, #20]
  /* Set initialization value */
  /* GPIOB_PDOR: PDO&=~0x00200000 */
  GPIOB_PDOR &= (uint32_t)~(uint32_t)(GPIO_PDOR_PDO(0x00200000));
    70aa:	4b0f      	ldr	r3, [pc, #60]	; (70e8 <BitIoLdd1_Init+0x74>)
    70ac:	4a0e      	ldr	r2, [pc, #56]	; (70e8 <BitIoLdd1_Init+0x74>)
    70ae:	6812      	ldr	r2, [r2, #0]
    70b0:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
    70b4:	601a      	str	r2, [r3, #0]
  /* Initialization of pin routing */
  /* PORTB_PCR21: ISF=0,MUX=1 */
  PORTB_PCR21 = (uint32_t)((PORTB_PCR21 & (uint32_t)~(uint32_t)(
    70b6:	4a0d      	ldr	r2, [pc, #52]	; (70ec <BitIoLdd1_Init+0x78>)
    70b8:	4b0c      	ldr	r3, [pc, #48]	; (70ec <BitIoLdd1_Init+0x78>)
    70ba:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    70bc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    70c0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    70c4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    70c8:	6553      	str	r3, [r2, #84]	; 0x54
                 PORT_PCR_MUX(0x06)
                )) | (uint32_t)(
                 PORT_PCR_MUX(0x01)
                ));
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_BitIoLdd1_ID,DeviceDataPrv);
    70ca:	4b09      	ldr	r3, [pc, #36]	; (70f0 <BitIoLdd1_Init+0x7c>)
    70cc:	68fa      	ldr	r2, [r7, #12]
    70ce:	601a      	str	r2, [r3, #0]
  return ((LDD_TDeviceData *)DeviceDataPrv);
    70d0:	68fb      	ldr	r3, [r7, #12]
}
    70d2:	4618      	mov	r0, r3
    70d4:	3714      	adds	r7, #20
    70d6:	46bd      	mov	sp, r7
    70d8:	f85d 7b04 	ldr.w	r7, [sp], #4
    70dc:	4770      	bx	lr
    70de:	bf00      	nop
    70e0:	200011b0 	.word	0x200011b0
    70e4:	40047000 	.word	0x40047000
    70e8:	400ff040 	.word	0x400ff040
    70ec:	4004a000 	.word	0x4004a000
    70f0:	2000119c 	.word	0x2000119c

000070f4 <BitIoLdd1_GetVal>:
**                           <false> - logical "0" (Low level)
**                           <true> - logical "1" (High level)
*/
/* ===================================================================*/
bool BitIoLdd1_GetVal(LDD_TDeviceData *DeviceDataPtr)
{
    70f4:	b480      	push	{r7}
    70f6:	b085      	sub	sp, #20
    70f8:	af00      	add	r7, sp, #0
    70fa:	6078      	str	r0, [r7, #4]
  uint32_t PortData;                   /* Port data masked according to the bit used */

  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  PortData = GPIO_PDD_GetPortDataOutput(BitIoLdd1_MODULE_BASE_ADDRESS) & BitIoLdd1_PORT_MASK;
    70fc:	4b08      	ldr	r3, [pc, #32]	; (7120 <BitIoLdd1_GetVal+0x2c>)
    70fe:	681b      	ldr	r3, [r3, #0]
    7100:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    7104:	60fb      	str	r3, [r7, #12]
  return (PortData != 0U) ? (bool)TRUE : (bool)FALSE;
    7106:	68fb      	ldr	r3, [r7, #12]
    7108:	2b00      	cmp	r3, #0
    710a:	bf0c      	ite	eq
    710c:	2300      	moveq	r3, #0
    710e:	2301      	movne	r3, #1
    7110:	b2db      	uxtb	r3, r3
}
    7112:	4618      	mov	r0, r3
    7114:	3714      	adds	r7, #20
    7116:	46bd      	mov	sp, r7
    7118:	f85d 7b04 	ldr.w	r7, [sp], #4
    711c:	4770      	bx	lr
    711e:	bf00      	nop
    7120:	400ff040 	.word	0x400ff040

00007124 <BitIoLdd1_ClrVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd1_ClrVal(LDD_TDeviceData *DeviceDataPtr)
{
    7124:	b480      	push	{r7}
    7126:	b083      	sub	sp, #12
    7128:	af00      	add	r7, sp, #0
    712a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_ClearPortDataOutputMask(BitIoLdd1_MODULE_BASE_ADDRESS, BitIoLdd1_PORT_MASK);
    712c:	4b04      	ldr	r3, [pc, #16]	; (7140 <BitIoLdd1_ClrVal+0x1c>)
    712e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7132:	609a      	str	r2, [r3, #8]
}
    7134:	370c      	adds	r7, #12
    7136:	46bd      	mov	sp, r7
    7138:	f85d 7b04 	ldr.w	r7, [sp], #4
    713c:	4770      	bx	lr
    713e:	bf00      	nop
    7140:	400ff040 	.word	0x400ff040

00007144 <BitIoLdd1_SetVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd1_SetVal(LDD_TDeviceData *DeviceDataPtr)
{
    7144:	b480      	push	{r7}
    7146:	b083      	sub	sp, #12
    7148:	af00      	add	r7, sp, #0
    714a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_SetPortDataOutputMask(BitIoLdd1_MODULE_BASE_ADDRESS, BitIoLdd1_PORT_MASK);
    714c:	4b04      	ldr	r3, [pc, #16]	; (7160 <BitIoLdd1_SetVal+0x1c>)
    714e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7152:	605a      	str	r2, [r3, #4]
}
    7154:	370c      	adds	r7, #12
    7156:	46bd      	mov	sp, r7
    7158:	f85d 7b04 	ldr.w	r7, [sp], #4
    715c:	4770      	bx	lr
    715e:	bf00      	nop
    7160:	400ff040 	.word	0x400ff040

00007164 <BitIoLdd1_NegVal>:
**         DeviceDataPtr   - Pointer to device data
**                           structure returned by <Init> method.
*/
/* ===================================================================*/
void BitIoLdd1_NegVal(LDD_TDeviceData *DeviceDataPtr)
{
    7164:	b480      	push	{r7}
    7166:	b083      	sub	sp, #12
    7168:	af00      	add	r7, sp, #0
    716a:	6078      	str	r0, [r7, #4]
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  GPIO_PDD_TogglePortDataOutputMask(BitIoLdd1_MODULE_BASE_ADDRESS, BitIoLdd1_PORT_MASK);
    716c:	4b04      	ldr	r3, [pc, #16]	; (7180 <BitIoLdd1_NegVal+0x1c>)
    716e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7172:	60da      	str	r2, [r3, #12]
}
    7174:	370c      	adds	r7, #12
    7176:	46bd      	mov	sp, r7
    7178:	f85d 7b04 	ldr.w	r7, [sp], #4
    717c:	4770      	bx	lr
    717e:	bf00      	nop
    7180:	400ff040 	.word	0x400ff040

00007184 <setjmp>:
    7184:	46ec      	mov	ip, sp
    7186:	e8a0 5ff0 	stmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    718a:	f04f 0000 	mov.w	r0, #0
    718e:	4770      	bx	lr

00007190 <longjmp>:
    7190:	e8b0 5ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
    7194:	46e5      	mov	sp, ip
    7196:	0008      	movs	r0, r1
    7198:	bf08      	it	eq
    719a:	2001      	moveq	r0, #1
    719c:	4770      	bx	lr
    719e:	bf00      	nop

000071a0 <__libc_init_array>:
    71a0:	b570      	push	{r4, r5, r6, lr}
    71a2:	4b0e      	ldr	r3, [pc, #56]	; (71dc <__libc_init_array+0x3c>)
    71a4:	4d0e      	ldr	r5, [pc, #56]	; (71e0 <__libc_init_array+0x40>)
    71a6:	1aed      	subs	r5, r5, r3
    71a8:	10ad      	asrs	r5, r5, #2
    71aa:	2400      	movs	r4, #0
    71ac:	461e      	mov	r6, r3
    71ae:	42ac      	cmp	r4, r5
    71b0:	d004      	beq.n	71bc <__libc_init_array+0x1c>
    71b2:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
    71b6:	4790      	blx	r2
    71b8:	3401      	adds	r4, #1
    71ba:	e7f8      	b.n	71ae <__libc_init_array+0xe>
    71bc:	f000 f99c 	bl	74f8 <_init>
    71c0:	4d08      	ldr	r5, [pc, #32]	; (71e4 <__libc_init_array+0x44>)
    71c2:	4b09      	ldr	r3, [pc, #36]	; (71e8 <__libc_init_array+0x48>)
    71c4:	1aed      	subs	r5, r5, r3
    71c6:	10ad      	asrs	r5, r5, #2
    71c8:	2400      	movs	r4, #0
    71ca:	461e      	mov	r6, r3
    71cc:	42ac      	cmp	r4, r5
    71ce:	d004      	beq.n	71da <__libc_init_array+0x3a>
    71d0:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
    71d4:	4790      	blx	r2
    71d6:	3401      	adds	r4, #1
    71d8:	e7f8      	b.n	71cc <__libc_init_array+0x2c>
    71da:	bd70      	pop	{r4, r5, r6, pc}
    71dc:	00007510 	.word	0x00007510
    71e0:	00007510 	.word	0x00007510
    71e4:	00007514 	.word	0x00007514
    71e8:	00007510 	.word	0x00007510

000071ec <memcpy>:
    71ec:	b510      	push	{r4, lr}
    71ee:	2300      	movs	r3, #0
    71f0:	4293      	cmp	r3, r2
    71f2:	d003      	beq.n	71fc <memcpy+0x10>
    71f4:	5ccc      	ldrb	r4, [r1, r3]
    71f6:	54c4      	strb	r4, [r0, r3]
    71f8:	3301      	adds	r3, #1
    71fa:	e7f9      	b.n	71f0 <memcpy+0x4>
    71fc:	bd10      	pop	{r4, pc}

000071fe <memset>:
    71fe:	4402      	add	r2, r0
    7200:	4603      	mov	r3, r0
    7202:	4293      	cmp	r3, r2
    7204:	d002      	beq.n	720c <memset+0xe>
    7206:	f803 1b01 	strb.w	r1, [r3], #1
    720a:	e7fa      	b.n	7202 <memset+0x4>
    720c:	4770      	bx	lr

0000720e <strchr>:
    720e:	b2c9      	uxtb	r1, r1
    7210:	4602      	mov	r2, r0
    7212:	f810 3b01 	ldrb.w	r3, [r0], #1
    7216:	b11b      	cbz	r3, 7220 <strchr+0x12>
    7218:	428b      	cmp	r3, r1
    721a:	d1f9      	bne.n	7210 <strchr+0x2>
    721c:	4610      	mov	r0, r2
    721e:	4770      	bx	lr
    7220:	2900      	cmp	r1, #0
    7222:	d0fb      	beq.n	721c <strchr+0xe>
    7224:	4618      	mov	r0, r3
    7226:	4770      	bx	lr

00007228 <strlen>:
    7228:	4603      	mov	r3, r0
    722a:	f813 2b01 	ldrb.w	r2, [r3], #1
    722e:	2a00      	cmp	r2, #0
    7230:	d1fb      	bne.n	722a <strlen+0x2>
    7232:	1a18      	subs	r0, r3, r0
    7234:	3801      	subs	r0, #1
    7236:	4770      	bx	lr

00007238 <strncmp>:
    7238:	b570      	push	{r4, r5, r6, lr}
    723a:	b192      	cbz	r2, 7262 <strncmp+0x2a>
    723c:	460b      	mov	r3, r1
    723e:	4605      	mov	r5, r0
    7240:	781c      	ldrb	r4, [r3, #0]
    7242:	f810 6b01 	ldrb.w	r6, [r0], #1
    7246:	42b4      	cmp	r4, r6
    7248:	f101 0101 	add.w	r1, r1, #1
    724c:	d101      	bne.n	7252 <strncmp+0x1a>
    724e:	2a01      	cmp	r2, #1
    7250:	d103      	bne.n	725a <strncmp+0x22>
    7252:	7828      	ldrb	r0, [r5, #0]
    7254:	781b      	ldrb	r3, [r3, #0]
    7256:	1ac0      	subs	r0, r0, r3
    7258:	bd70      	pop	{r4, r5, r6, pc}
    725a:	3a01      	subs	r2, #1
    725c:	2c00      	cmp	r4, #0
    725e:	d1ed      	bne.n	723c <strncmp+0x4>
    7260:	e7f7      	b.n	7252 <strncmp+0x1a>
    7262:	4610      	mov	r0, r2
    7264:	bd70      	pop	{r4, r5, r6, pc}
	...

00007268 <ClockGenModeMatrix>:
    7268:	0000 0001 0001 0003 0004 0004 0004 0004     ................
    7278:	0000 0001 0002 0003 0004 0004 0004 0004     ................
    7288:	0001 0001 0002 0001 0001 0001 0001 0001     ................
    7298:	0000 0001 0001 0003 0004 0004 0004 0004     ................
    72a8:	0000 0001 0001 0003 0004 0005 0006 0006     ................
    72b8:	0004 0004 0004 0004 0004 0005 0006 0006     ................
    72c8:	0004 0004 0004 0004 0004 0005 0006 0007     ................
    72d8:	0006 0006 0006 0006 0006 0006 0006 0007     ................

000072e8 <CPU_ClockConfigDescriptors>:
    72e8:	0010 0600 0024 0000 0000 0000 0000 0008     ....$...........
    72f8:	0000 0000 0000 0011 0000 0140 0097 1a00     ..........@.....
    7308:	0024 4601 0000 0080 0000 0008 0000 0001     $..F............
    7318:	0000 0114 8700 0393 00a2 4600 0027 0000     ...........F'...
    7328:	0000 0080 0000 0008 0000 0003 0000 0004     ................
    7338:	0900 003d 0125 8200 0027 0000 0201 0000     ..=.%...'.......
    7348:	0000 0008 0000 0003 0000 0000 8000 0000     ................
    7358:	0097 1a00 0024 4601 0000 0080 0000 0008     ....$..F........
    7368:	0000 0001 0000 0114 8700 0393               ............

00007374 <CPU_DefaultFEI>:
    7374:	8004 0000 0000 0002                         ........

0000737c <CPU_DefaultFBI>:
    737c:	8044 0000 0000 0002                         D.......

00007384 <CPU_DefaultBLPI>:
    7384:	8244 0000 0000 0002                         D.......

0000738c <CPU_DefaultFEE>:
    738c:	a418 0000 0000 0002                         ........

00007394 <CPU_DefaultFBE>:
    7394:	a498 0000 0000 0002                         ........

0000739c <CPU_DefaultBLPE>:
    739c:	a658 0000 0000 0002                         X.......

000073a4 <CPU_DefaultPBE>:
    73a4:	a480 0100 0058 0002                         ....X...

000073ac <CPU_DefaultPEE>:
    73ac:	a418 0100 0058 0002                         ....X...

000073b4 <CPU_ClockGenModeRegs>:
    73b4:	7374 0000 737c 0000 7384 0000 738c 0000     ts..|s...s...s..
    73c4:	7394 0000 739c 0000 73a4 0000 73ac 0000     .s...s...s...s..
    73d4:	656c 5f64 6c62 6575 0000 0000 656c 5f64     led_blue....led_
    73e4:	6572 0064 656c 5f64 7267 6565 006e 0000     red.led_green...
    73f4:	4449 454c 0000 0000 0009 0000 0a0d 0000     IDLE............

00007404 <xHeapStructSize>:
    7404:	0008 0000 332d 3732 3836 0000 322d 3431     ....-32768..-214
    7414:	3437 3338 3436 0038 0000 0000               7483648.....

00007420 <skew.6970>:
    7420:	0300 0603 0401 0206 0005 0503               ............

0000742c <PE_CpuClockConfigurations>:
    742c:	0000 0140 0000 0140 0000 00a0 0000 00a0     ..@...@.........
    743c:	0000 0000 0000 0140 8000 0000 0000 0000     ......@.........
    744c:	8000 0000 8000 0000 0e00 0727 8700 0393     ..........'.....
    745c:	8700 0393 3600 016e 0000 0000 0e00 0727     .....6n.......'.
    746c:	8000 0000 1200 007a 8000 0000 7a12 0000     ......z......z..
    747c:	0900 003d 0900 003d 0900 003d 3500 000c     ..=...=...=..5..
    748c:	0000 0000 6c00 02dc 0900 003d 1200 007a     .....l....=...z.
    749c:	8000 0000 8000 0000 8000 0000 8000 0000     ................
    74ac:	8000 0000 8000 0000 0000 0000 6c00 02dc     .............l..
    74bc:	8480 001e 0000 0000 8000 0000 0000 0000     ................
    74cc:	0e00 0727 8700 0393 8700 0393 3600 016e     ..'..........6n.
    74dc:	0000 0000 0e00 0727 8000 0000 1200 007a     ......'.......z.
    74ec:	8000 0000 7a12 0000                         .....z..

000074f4 <__EH_FRAME_BEGIN__>:
    74f4:	0000 0000                                   ....

000074f8 <_init>:
    74f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    74fa:	bf00      	nop
    74fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    74fe:	bc08      	pop	{r3}
    7500:	469e      	mov	lr, r3
    7502:	4770      	bx	lr

00007504 <_fini>:
    7504:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7506:	bf00      	nop
    7508:	bcf8      	pop	{r3, r4, r5, r6, r7}
    750a:	bc08      	pop	{r3}
    750c:	469e      	mov	lr, r3
    750e:	4770      	bx	lr
